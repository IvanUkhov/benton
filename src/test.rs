#![feature(prelude_import)]
#![no_std]
//! A parser for OpenType fonts.
//!
//! ## Example
//!
//! ```
//! extern crate opentype;
//! extern crate truetype;
//!
//! use opentype::Font;
//! use truetype::{FontHeader, HorizontalHeader, NamingTable};
//!
//! macro_rules! ok(($result:expr) => ($result.unwrap()));
//!
//! # fn main() {
//! let path = "SourceSerifPro-Regular.otf";
//! # let path = "tests/fixtures/SourceSerifPro-Regular.otf";
//! let mut reader = ok!(std::fs::File::open(path));
//! let font = ok!(Font::read(&mut reader));
//!
//! let font_header: FontHeader = ok!(ok!(font.take(&mut reader)));
//! assert_eq!(font_header.units_per_em, 1000);
//!
//! let horizontal_header: HorizontalHeader = ok!(ok!(font.take(&mut reader)));
//! assert_eq!(horizontal_header.ascender, 918);
//!
//! let naming_table: NamingTable = ok!(ok!(font.take(&mut reader)));
//! match naming_table {
//!     NamingTable::Format0(ref table) => {
//!         let strings = ok!(table.strings());
//!         assert_eq!(&strings[1], "Source Serif Pro");
//!         assert_eq!(&strings[9], "Frank GrieÃŸhammer");
//!     },
//!     _ => unreachable!(),
//! }
//! # }
//! ```
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;

extern crate postscript;

#[macro_use(flags)]
extern crate truetype;

#[macro_use]
mod macros { }

mod file {


    use std::io::{Read, Seek};
    use std::ops::Deref;
    use truetype::{Result, Tag, Tape};
    use Font;
    /// A file.
    pub struct File {
        /// The fonts.
        pub fonts: Vec<Font>,
    }
    impl File {
        /// Read a file.
        pub fn read<T: Read + Seek>(tape: &mut T) -> Result<File> {
            if Tag::from(match Tape::peek::<u32>(tape) {
                             ::std::result::Result::Ok(val) => val,
                             ::std::result::Result::Err(err) => {
                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                             }
                         }) == Tag(*b"ttcf") {
                return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                  "TrueType collections are not supported yet"));
            }
            Ok(File{fonts:
                        <[_]>::into_vec(box
                                            [match Font::read(tape) {
                                                 ::std::result::Result::Ok(val)
                                                 => val,
                                                 ::std::result::Result::Err(err)
                                                 => {
                                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                                 }
                                             }]),})
        }
    }
    impl Deref for File {
        type
        Target
        =
        [Font];
        #[inline(always)]
        fn deref(&self) -> &Self::Target { &self.fonts }
    }
}
mod font {
    use std::io::{Read, Seek};
    use truetype::{Result, Tag, Tape};
    use truetype::offset_table::OffsetTable;
    use Table;
    /// A font.
    pub struct Font {
        /// The offset table.
        pub offset_table: OffsetTable,
    }
    impl Font {
        /// Read a font.
        #[inline]
        pub fn read<T>(tape: &mut T) -> Result<Font> where T: Read + Seek {
            Ok(Font{offset_table:
                        match Tape::take(tape) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        },})
        }
        /// Find, verify, and read a table.
        #[inline]
        pub fn take<'l, T, U>(&self, tape: &mut T) -> Result<Option<U>> where
         T: Read + Seek, U: Table<'l, Parameter = ()> {
            self.take_given(tape, ())
        }
        /// Find, verify, and read a table given a parameter.
        pub fn take_given<'l, T,
                          U>(&self, tape: &mut T, parameter: U::Parameter)
         -> Result<Option<U>> where T: Read + Seek, U: Table<'l> {
            let tag = U::tag();
            for record in &self.offset_table.records {
                if record.tag == tag {
                    let check =
                        if tag == Tag(*b"head") {
                            match record.checksum(tape,
                                                  |i, word|
                                                      if i == 2 {
                                                          0
                                                      } else { word }) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        } else {
                            match record.checksum(tape, |_, word| word) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    if !check {
                        return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                          "found a malformed font table"));
                    }
                    match Tape::jump(tape, record.offset as u64) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                    return Ok(Some(match Table::take(tape, parameter) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }));
                }
            }
            Ok(None)
        }
    }
}
mod table {
    use postscript;
    use postscript::compact::FontSet;
    use std::io::{Read, Seek};
    use truetype::{self, Result, Tag};
    use truetype::{CharMapping, FontHeader, GlyphData, GlyphMapping,
                   HorizontalHeader, HorizontalMetrics, MaximumProfile,
                   NamingTable, PostScript, WindowsMetrics};
    use {GlyphDefinition, GlyphPositioning, GlyphSubstitution};
    /// A font table.
    pub trait Table<'l>: Sized {
        #[doc(hidden)]
        type
        Parameter;
        #[doc(hidden)]
        fn tag()
        -> Tag;
        #[doc(hidden)]
        fn take<T>(&mut T, Self::Parameter)
        -> Result<Self>
        where
        T: Read +
        Seek;
    }
    impl Table<'static> for FontSet {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"CFF ") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            postscript::Tape::take(tape)
        }
    }
    impl Table<'static> for GlyphDefinition {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"GDEF") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for GlyphPositioning {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"GPOS") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for GlyphSubstitution {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"GSUB") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for WindowsMetrics {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"OS/2") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for CharMapping {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"cmap") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl <'l> Table<'l> for GlyphData {
        type
        Parameter
        =
        <GlyphData as truetype::Walue<'l>>::Parameter;
        #[inline]
        fn tag() -> Tag { Tag(*b"glyf") }
        #[inline]
        fn take<T>(tape: &mut T, parameter: Self::Parameter) -> Result<Self>
         where T: Read + Seek {
            truetype::Tape::take_given(tape, parameter)
        }
    }
    impl Table<'static> for FontHeader {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"head") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for HorizontalHeader {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"hhea") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl <'l> Table<'l> for HorizontalMetrics {
        type
        Parameter
        =
        <HorizontalMetrics as truetype::Walue<'l>>::Parameter;
        #[inline]
        fn tag() -> Tag { Tag(*b"hmtx") }
        #[inline]
        fn take<T>(tape: &mut T, parameter: Self::Parameter) -> Result<Self>
         where T: Read + Seek {
            truetype::Tape::take_given(tape, parameter)
        }
    }
    impl <'l> Table<'l> for GlyphMapping {
        type
        Parameter
        =
        <GlyphMapping as truetype::Walue<'l>>::Parameter;
        #[inline]
        fn tag() -> Tag { Tag(*b"loca") }
        #[inline]
        fn take<T>(tape: &mut T, parameter: Self::Parameter) -> Result<Self>
         where T: Read + Seek {
            truetype::Tape::take_given(tape, parameter)
        }
    }
    impl Table<'static> for MaximumProfile {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"maxp") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for NamingTable {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"name") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
    impl Table<'static> for PostScript {
        type
        Parameter
        =
        ();
        #[inline]
        fn tag() -> Tag { Tag(*b"post") }
        #[inline]
        fn take<T>(tape: &mut T, _: Self::Parameter) -> Result<Self> where
         T: Read + Seek {
            truetype::Tape::take(tape)
        }
    }
}
pub mod glyph_definition {
    //! The [glyph-definition table][1].
    //!
    //! [1]: https://www.microsoft.com/typography/otspec/GDEF.htm
    use truetype::{Result, Tape, Value};
    use layout::Class;
    mod element {
        use truetype::{Result, Tape, Value};
        use layout::{Coverage, Device};
        #[doc = "A glyph attachment."]
        pub struct Attachment {
            pub index_count: u16,
            pub indices: Vec<u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Attachment {
            #[inline]
            fn clone(&self) -> Attachment {
                match *self {
                    Attachment {
                    index_count: ref __self_0_0, indices: ref __self_0_1 } =>
                    Attachment{index_count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               indices:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Attachment {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Attachment {
                    index_count: ref __self_0_0, indices: ref __self_0_1 } =>
                    {
                        let mut builder = __arg_0.debug_struct("Attachment");
                        let _ = builder.field("index_count", &&(*__self_0_0));
                        let _ = builder.field("indices", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Attachment {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Attachment = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.index_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Attachment,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.index_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.indices,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of glyph attachments."]
        pub struct Attachments {
            pub coverage_offset: u16,
            pub count: u16,
            pub offsets: Vec<u16>,
            pub coverage: Coverage,
            pub records: Vec<Attachment>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Attachments {
            #[inline]
            fn clone(&self) -> Attachments {
                match *self {
                    Attachments {
                    coverage_offset: ref __self_0_0,
                    count: ref __self_0_1,
                    offsets: ref __self_0_2,
                    coverage: ref __self_0_3,
                    records: ref __self_0_4 } =>
                    Attachments{coverage_offset:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                count:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),
                                offsets:
                                    ::std::clone::Clone::clone(&(*__self_0_2)),
                                coverage:
                                    ::std::clone::Clone::clone(&(*__self_0_3)),
                                records:
                                    ::std::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Attachments {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Attachments {
                    coverage_offset: ref __self_0_0,
                    count: ref __self_0_1,
                    offsets: ref __self_0_2,
                    coverage: ref __self_0_3,
                    records: ref __self_0_4 } => {
                        let mut builder = __arg_0.debug_struct("Attachments");
                        let _ =
                            builder.field("coverage_offset", &&(*__self_0_0));
                        let _ = builder.field("count", &&(*__self_0_1));
                        let _ = builder.field("offsets", &&(*__self_0_2));
                        let _ = builder.field("coverage", &&(*__self_0_3));
                        let _ = builder.field("records", &&(*__self_0_4));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Attachments {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Attachments = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Attachments,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Attachments,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Coverage> {
                                Ok({
                                       match tape.jump(position +
                                                           (this.coverage_offset
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Attachments,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Attachment>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        /// A ligature caret.
        pub enum Caret {

            /// Format 1.
            Format1(Caret1),

            /// Format 2.
            Format2(Caret2),

            /// Format 3.
            Format3(Caret3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Caret {
            #[inline]
            fn clone(&self) -> Caret {
                match (&*self,) {
                    (&Caret::Format1(ref __self_0),) =>
                    Caret::Format1(::std::clone::Clone::clone(&(*__self_0))),
                    (&Caret::Format2(ref __self_0),) =>
                    Caret::Format2(::std::clone::Clone::clone(&(*__self_0))),
                    (&Caret::Format3(ref __self_0),) =>
                    Caret::Format3(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Caret {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Caret::Format1(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format1");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Caret::Format2(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format2");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Caret::Format3(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format3");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = r" A ligature caret in format 1."]
        pub struct Caret1 {
            pub format: u16,
            pub coordinate: i16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Caret1 {
            #[inline]
            fn clone(&self) -> Caret1 {
                match *self {
                    Caret1 {
                    format: ref __self_0_0, coordinate: ref __self_0_1 } =>
                    Caret1{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                           coordinate:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Caret1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Caret1 {
                    format: ref __self_0_0, coordinate: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Caret1");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("coordinate", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Caret1 { }
        impl ::truetype::Value for Caret1 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Caret1 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coordinate,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = r" A ligature caret in format 2."]
        pub struct Caret2 {
            pub format: u16,
            pub index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Caret2 {
            #[inline]
            fn clone(&self) -> Caret2 {
                match *self {
                    Caret2 { format: ref __self_0_0, index: ref __self_0_1 }
                    =>
                    Caret2{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                           index:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Caret2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Caret2 { format: ref __self_0_0, index: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Caret2");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("index", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Caret2 { }
        impl ::truetype::Value for Caret2 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Caret2 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.index,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = r" A ligature caret in format 3."]
        pub struct Caret3 {
            pub format: u16,
            pub coordinate: i16,
            pub device_offset: u16,
            pub device: Device,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Caret3 {
            #[inline]
            fn clone(&self) -> Caret3 {
                match *self {
                    Caret3 {
                    format: ref __self_0_0,
                    coordinate: ref __self_0_1,
                    device_offset: ref __self_0_2,
                    device: ref __self_0_3 } =>
                    Caret3{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                           coordinate:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           device_offset:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           device:
                               ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Caret3 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Caret3 {
                    format: ref __self_0_0,
                    coordinate: ref __self_0_1,
                    device_offset: ref __self_0_2,
                    device: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Caret3");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("coordinate", &&(*__self_0_1));
                        let _ =
                            builder.field("device_offset", &&(*__self_0_2));
                        let _ = builder.field("device", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Caret3 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Caret3 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coordinate,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device_offset,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Caret3,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Device> {
                                Ok({
                                       match tape.jump(position +
                                                           (this.device_offset
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A ligature."]
        pub struct Ligature {
            pub caret_count: u16,
            pub caret_offsets: Vec<u16>,
            pub carets: Vec<Caret>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligature {
            #[inline]
            fn clone(&self) -> Ligature {
                match *self {
                    Ligature {
                    caret_count: ref __self_0_0,
                    caret_offsets: ref __self_0_1,
                    carets: ref __self_0_2 } =>
                    Ligature{caret_count:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             caret_offsets:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             carets:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligature {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligature {
                    caret_count: ref __self_0_0,
                    caret_offsets: ref __self_0_1,
                    carets: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Ligature");
                        let _ = builder.field("caret_count", &&(*__self_0_0));
                        let _ =
                            builder.field("caret_offsets", &&(*__self_0_1));
                        let _ = builder.field("carets", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Ligature {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Ligature = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.caret_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligature,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.caret_count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.caret_offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligature,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Caret>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.caret_count
                                                                  as usize);
                                       for i in 0..(this.caret_count as usize)
                                           {
                                           match tape.jump(position +
                                                               (this.caret_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.carets,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of ligatures."]
        pub struct Ligatures {
            pub coverage_offset: u16,
            pub count: u16,
            pub offsets: Vec<u16>,
            pub coverage: Coverage,
            pub records: Vec<Ligature>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligatures {
            #[inline]
            fn clone(&self) -> Ligatures {
                match *self {
                    Ligatures {
                    coverage_offset: ref __self_0_0,
                    count: ref __self_0_1,
                    offsets: ref __self_0_2,
                    coverage: ref __self_0_3,
                    records: ref __self_0_4 } =>
                    Ligatures{coverage_offset:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              count:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              offsets:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              coverage:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),
                              records:
                                  ::std::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligatures {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligatures {
                    coverage_offset: ref __self_0_0,
                    count: ref __self_0_1,
                    offsets: ref __self_0_2,
                    coverage: ref __self_0_3,
                    records: ref __self_0_4 } => {
                        let mut builder = __arg_0.debug_struct("Ligatures");
                        let _ =
                            builder.field("coverage_offset", &&(*__self_0_0));
                        let _ = builder.field("count", &&(*__self_0_1));
                        let _ = builder.field("offsets", &&(*__self_0_2));
                        let _ = builder.field("coverage", &&(*__self_0_3));
                        let _ = builder.field("records", &&(*__self_0_4));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Ligatures {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Ligatures = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligatures,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligatures,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Coverage> {
                                Ok({
                                       match tape.jump(position +
                                                           (this.coverage_offset
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligatures,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Ligature>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of marks."]
        pub struct Marks {
            pub format: u16,
            pub count: u16,
            pub coverage_offsets: Vec<u32>,
            pub coverages: Vec<Coverage>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Marks {
            #[inline]
            fn clone(&self) -> Marks {
                match *self {
                    Marks {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    coverage_offsets: ref __self_0_2,
                    coverages: ref __self_0_3 } =>
                    Marks{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                          count: ::std::clone::Clone::clone(&(*__self_0_1)),
                          coverage_offsets:
                              ::std::clone::Clone::clone(&(*__self_0_2)),
                          coverages:
                              ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Marks {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Marks {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    coverage_offsets: ref __self_0_2,
                    coverages: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Marks");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("count", &&(*__self_0_1));
                        let _ =
                            builder.field("coverage_offsets",
                                          &&(*__self_0_2));
                        let _ = builder.field("coverages", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Marks {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Marks = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        {
                            let value =
                                match tape.take() {
                                    ::std::result::Result::Ok(val) => val,
                                    ::std::result::Result::Err(err) => {
                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                    }
                                };
                            if value != { 1 } {
                                return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                  "found a malformed or unsupported table"));
                            }
                            value
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Marks,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u32>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverage_offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Marks,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Coverage>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.coverage_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.coverages,
                                                           value));
                }
                Ok(table)
            }
        }
        impl Value for Caret {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                Ok(match match tape.peek::<u32>() {
                             ::std::result::Result::Ok(val) => val,
                             ::std::result::Result::Err(err) => {
                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                             }
                         } {
                       1 =>
                       Caret::Format1(match tape.take() {
                                          ::std::result::Result::Ok(val) =>
                                          val,
                                          ::std::result::Result::Err(err) => {
                                              return ::std::result::Result::Err(::std::convert::From::from(err))
                                          }
                                      }),
                       2 =>
                       Caret::Format2(match tape.take() {
                                          ::std::result::Result::Ok(val) =>
                                          val,
                                          ::std::result::Result::Err(err) => {
                                              return ::std::result::Result::Err(::std::convert::From::from(err))
                                          }
                                      }),
                       3 =>
                       Caret::Format3(match tape.take() {
                                          ::std::result::Result::Ok(val) =>
                                          val,
                                          ::std::result::Result::Err(err) => {
                                              return ::std::result::Result::Err(::std::convert::From::from(err))
                                          }
                                      }),
                       _ =>
                       return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                         "found an unknown format of the caret-value table")),
                   })
            }
        }
    }
    pub use self::element::*;
    #[doc = "A glyph-definition table."]
    pub struct GlyphDefinition {
        pub header: Header,
        pub glyph_class: Option<Class>,
        pub attachments: Option<Attachments>,
        pub ligatures: Option<Ligatures>,
        pub mark_class: Option<Class>,
        pub marks: Option<Marks>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for GlyphDefinition {
        #[inline]
        fn clone(&self) -> GlyphDefinition {
            match *self {
                GlyphDefinition {
                header: ref __self_0_0,
                glyph_class: ref __self_0_1,
                attachments: ref __self_0_2,
                ligatures: ref __self_0_3,
                mark_class: ref __self_0_4,
                marks: ref __self_0_5 } =>
                GlyphDefinition{header:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                glyph_class:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),
                                attachments:
                                    ::std::clone::Clone::clone(&(*__self_0_2)),
                                ligatures:
                                    ::std::clone::Clone::clone(&(*__self_0_3)),
                                mark_class:
                                    ::std::clone::Clone::clone(&(*__self_0_4)),
                                marks:
                                    ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for GlyphDefinition {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                GlyphDefinition {
                header: ref __self_0_0,
                glyph_class: ref __self_0_1,
                attachments: ref __self_0_2,
                ligatures: ref __self_0_3,
                mark_class: ref __self_0_4,
                marks: ref __self_0_5 } => {
                    let mut builder = __arg_0.debug_struct("GlyphDefinition");
                    let _ = builder.field("header", &&(*__self_0_0));
                    let _ = builder.field("glyph_class", &&(*__self_0_1));
                    let _ = builder.field("attachments", &&(*__self_0_2));
                    let _ = builder.field("ligatures", &&(*__self_0_3));
                    let _ = builder.field("mark_class", &&(*__self_0_4));
                    let _ = builder.field("marks", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for GlyphDefinition {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: GlyphDefinition = unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.header,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &GlyphDefinition,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Option<Class>> {
                            Ok(if match this.header {
                                      Header::Version1(ref header) =>
                                      header.glyph_class_offset,
                                      Header::Version12(ref header) =>
                                      header.glyph_class_offset,
                                  } > 0 {
                                   match tape.jump(position +
                                                       (match this.header {
                                                            Header::Version1(ref header)
                                                            =>
                                                            header.glyph_class_offset,
                                                            Header::Version12(ref header)
                                                            =>
                                                            header.glyph_class_offset,
                                                        } as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   Some(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        })
                               } else { None })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &GlyphDefinition,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Option<Attachments>> {
                            Ok(if match this.header {
                                      Header::Version1(ref header) =>
                                      header.attachments_offset,
                                      Header::Version12(ref header) =>
                                      header.attachments_offset,
                                  } > 0 {
                                   match tape.jump(position +
                                                       (match this.header {
                                                            Header::Version1(ref header)
                                                            =>
                                                            header.attachments_offset,
                                                            Header::Version12(ref header)
                                                            =>
                                                            header.attachments_offset,
                                                        } as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   Some(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        })
                               } else { None })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.attachments,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &GlyphDefinition,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Option<Ligatures>> {
                            Ok(if match this.header {
                                      Header::Version1(ref header) =>
                                      header.ligatures_offset,
                                      Header::Version12(ref header) =>
                                      header.ligatures_offset,
                                  } > 0 {
                                   match tape.jump(position +
                                                       (match this.header {
                                                            Header::Version1(ref header)
                                                            =>
                                                            header.ligatures_offset,
                                                            Header::Version12(ref header)
                                                            =>
                                                            header.ligatures_offset,
                                                        } as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   Some(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        })
                               } else { None })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligatures,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &GlyphDefinition,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Option<Class>> {
                            Ok(if match this.header {
                                      Header::Version1(ref header) =>
                                      header.mark_class_offset,
                                      Header::Version12(ref header) =>
                                      header.mark_class_offset,
                                  } > 0 {
                                   match tape.jump(position +
                                                       (match this.header {
                                                            Header::Version1(ref header)
                                                            =>
                                                            header.mark_class_offset,
                                                            Header::Version12(ref header)
                                                            =>
                                                            header.mark_class_offset,
                                                        } as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   Some(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        })
                               } else { None })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &GlyphDefinition,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Option<Marks>> {
                            Ok(if match this.header {
                                      Header::Version12(ref header) =>
                                      header.marks_offset,
                                      _ => 0,
                                  } > 0 {
                                   match tape.jump(position +
                                                       (match this.header {
                                                            Header::Version12(ref header)
                                                            =>
                                                            header.marks_offset,
                                                            _ => 0,
                                                        } as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   Some(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        })
                               } else { None })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks,
                                                       value));
            }
            Ok(table)
        }
    }
    /// The header of a glyph-definition table.
    pub enum Header {

        /// Version 1.0.
        Version1(Header1),

        /// Version 1.2.
        Version12(Header12),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Header {
        #[inline]
        fn clone(&self) -> Header {
            match (&*self,) {
                (&Header::Version1(ref __self_0),) =>
                Header::Version1(::std::clone::Clone::clone(&(*__self_0))),
                (&Header::Version12(ref __self_0),) =>
                Header::Version12(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Header {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Header::Version1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Version1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Header::Version12(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Version12");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "The header of a glyph-definition table of version 1.0."]
    pub struct Header1 {
        pub major_version: u16,
        pub minor_version: u16,
        pub glyph_class_offset: u16,
        pub attachments_offset: u16,
        pub ligatures_offset: u16,
        pub mark_class_offset: u16,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Header1 {
        #[inline]
        fn clone(&self) -> Header1 {
            match *self {
                Header1 {
                major_version: ref __self_0_0,
                minor_version: ref __self_0_1,
                glyph_class_offset: ref __self_0_2,
                attachments_offset: ref __self_0_3,
                ligatures_offset: ref __self_0_4,
                mark_class_offset: ref __self_0_5 } =>
                Header1{major_version:
                            ::std::clone::Clone::clone(&(*__self_0_0)),
                        minor_version:
                            ::std::clone::Clone::clone(&(*__self_0_1)),
                        glyph_class_offset:
                            ::std::clone::Clone::clone(&(*__self_0_2)),
                        attachments_offset:
                            ::std::clone::Clone::clone(&(*__self_0_3)),
                        ligatures_offset:
                            ::std::clone::Clone::clone(&(*__self_0_4)),
                        mark_class_offset:
                            ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Header1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                Header1 {
                major_version: ref __self_0_0,
                minor_version: ref __self_0_1,
                glyph_class_offset: ref __self_0_2,
                attachments_offset: ref __self_0_3,
                ligatures_offset: ref __self_0_4,
                mark_class_offset: ref __self_0_5 } => {
                    let mut builder = __arg_0.debug_struct("Header1");
                    let _ = builder.field("major_version", &&(*__self_0_0));
                    let _ = builder.field("minor_version", &&(*__self_0_1));
                    let _ =
                        builder.field("glyph_class_offset", &&(*__self_0_2));
                    let _ =
                        builder.field("attachments_offset", &&(*__self_0_3));
                    let _ =
                        builder.field("ligatures_offset", &&(*__self_0_4));
                    let _ =
                        builder.field("mark_class_offset", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Header1 { }
    impl ::truetype::Value for Header1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let mut table: Header1 = unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.major_version,
                                                       value));
            }
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 0 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.minor_version,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.attachments_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligatures_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_class_offset,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "The header of a glyph-definition table of version 1.2."]
    pub struct Header12 {
        pub major_version: u16,
        pub minor_version: u16,
        pub glyph_class_offset: u16,
        pub attachments_offset: u16,
        pub ligatures_offset: u16,
        pub mark_class_offset: u16,
        pub marks_offset: u16,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Header12 {
        #[inline]
        fn clone(&self) -> Header12 {
            match *self {
                Header12 {
                major_version: ref __self_0_0,
                minor_version: ref __self_0_1,
                glyph_class_offset: ref __self_0_2,
                attachments_offset: ref __self_0_3,
                ligatures_offset: ref __self_0_4,
                mark_class_offset: ref __self_0_5,
                marks_offset: ref __self_0_6 } =>
                Header12{major_version:
                             ::std::clone::Clone::clone(&(*__self_0_0)),
                         minor_version:
                             ::std::clone::Clone::clone(&(*__self_0_1)),
                         glyph_class_offset:
                             ::std::clone::Clone::clone(&(*__self_0_2)),
                         attachments_offset:
                             ::std::clone::Clone::clone(&(*__self_0_3)),
                         ligatures_offset:
                             ::std::clone::Clone::clone(&(*__self_0_4)),
                         mark_class_offset:
                             ::std::clone::Clone::clone(&(*__self_0_5)),
                         marks_offset:
                             ::std::clone::Clone::clone(&(*__self_0_6)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Header12 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                Header12 {
                major_version: ref __self_0_0,
                minor_version: ref __self_0_1,
                glyph_class_offset: ref __self_0_2,
                attachments_offset: ref __self_0_3,
                ligatures_offset: ref __self_0_4,
                mark_class_offset: ref __self_0_5,
                marks_offset: ref __self_0_6 } => {
                    let mut builder = __arg_0.debug_struct("Header12");
                    let _ = builder.field("major_version", &&(*__self_0_0));
                    let _ = builder.field("minor_version", &&(*__self_0_1));
                    let _ =
                        builder.field("glyph_class_offset", &&(*__self_0_2));
                    let _ =
                        builder.field("attachments_offset", &&(*__self_0_3));
                    let _ =
                        builder.field("ligatures_offset", &&(*__self_0_4));
                    let _ =
                        builder.field("mark_class_offset", &&(*__self_0_5));
                    let _ = builder.field("marks_offset", &&(*__self_0_6));
                    builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Header12 { }
    impl ::truetype::Value for Header12 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let mut table: Header12 = unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.major_version,
                                                       value));
            }
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 2 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.minor_version,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.attachments_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligatures_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks_offset,
                                                       value));
            }
            Ok(table)
        }
    }
    impl Value for Header {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u32>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   65536 =>
                   Header::Version1(match tape.take() {
                                        ::std::result::Result::Ok(val) => val,
                                        ::std::result::Result::Err(err) => {
                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                        }
                                    }),
                   65538 =>
                   Header::Version12(match tape.take() {
                                         ::std::result::Result::Ok(val) =>
                                         val,
                                         ::std::result::Result::Err(err) => {
                                             return ::std::result::Result::Err(::std::convert::From::from(err))
                                         }
                                     }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the glyph-definition table")),
               })
        }
    }
}
pub mod glyph_positioning {
    //! The [glyph-positioning table][1].
    //!
    //! [1]: https://www.microsoft.com/typography/otspec/gpos.htm
    use truetype::{Result, Tape, Value, Walue};
    use layout::{Class, Coverage, Directory};
    mod element {
        use truetype::{GlyphID, Result, Tape, Value, Walue};
        use layout::Device;
        /// An anchor.
        pub enum Anchor {

            /// Format 1.
            Format1(Anchor1),

            /// Format 2.
            Format2(Anchor2),

            /// Format 3.
            Format3(Anchor3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Anchor {
            #[inline]
            fn clone(&self) -> Anchor {
                match (&*self,) {
                    (&Anchor::Format1(ref __self_0),) =>
                    Anchor::Format1(::std::clone::Clone::clone(&(*__self_0))),
                    (&Anchor::Format2(ref __self_0),) =>
                    Anchor::Format2(::std::clone::Clone::clone(&(*__self_0))),
                    (&Anchor::Format3(ref __self_0),) =>
                    Anchor::Format3(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Anchor {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Anchor::Format1(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format1");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Anchor::Format2(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format2");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Anchor::Format3(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format3");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "An anchor in format 1."]
        pub struct Anchor1 {
            pub format: u16,
            pub x: i16,
            pub y: i16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Anchor1 {
            #[inline]
            fn clone(&self) -> Anchor1 {
                match *self {
                    Anchor1 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2 } =>
                    Anchor1{format:
                                ::std::clone::Clone::clone(&(*__self_0_0)),
                            x: ::std::clone::Clone::clone(&(*__self_0_1)),
                            y: ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Anchor1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Anchor1 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Anchor1");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("x", &&(*__self_0_1));
                        let _ = builder.field("y", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Anchor1 { }
        impl ::truetype::Value for Anchor1 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Anchor1 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.x,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.y,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "An anchor in format 2."]
        pub struct Anchor2 {
            pub format: u16,
            pub x: i16,
            pub y: i16,
            pub index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Anchor2 {
            #[inline]
            fn clone(&self) -> Anchor2 {
                match *self {
                    Anchor2 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2,
                    index: ref __self_0_3 } =>
                    Anchor2{format:
                                ::std::clone::Clone::clone(&(*__self_0_0)),
                            x: ::std::clone::Clone::clone(&(*__self_0_1)),
                            y: ::std::clone::Clone::clone(&(*__self_0_2)),
                            index:
                                ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Anchor2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Anchor2 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2,
                    index: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Anchor2");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("x", &&(*__self_0_1));
                        let _ = builder.field("y", &&(*__self_0_2));
                        let _ = builder.field("index", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Anchor2 { }
        impl ::truetype::Value for Anchor2 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Anchor2 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.x,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.y,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.index,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "An anchor in format 3."]
        pub struct Anchor3 {
            pub format: u16,
            pub x: i16,
            pub y: i16,
            pub device_x_offset: u16,
            pub device_y_offset: u16,
            pub device_x: Option<Device>,
            pub device_y: Option<Device>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Anchor3 {
            #[inline]
            fn clone(&self) -> Anchor3 {
                match *self {
                    Anchor3 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2,
                    device_x_offset: ref __self_0_3,
                    device_y_offset: ref __self_0_4,
                    device_x: ref __self_0_5,
                    device_y: ref __self_0_6 } =>
                    Anchor3{format:
                                ::std::clone::Clone::clone(&(*__self_0_0)),
                            x: ::std::clone::Clone::clone(&(*__self_0_1)),
                            y: ::std::clone::Clone::clone(&(*__self_0_2)),
                            device_x_offset:
                                ::std::clone::Clone::clone(&(*__self_0_3)),
                            device_y_offset:
                                ::std::clone::Clone::clone(&(*__self_0_4)),
                            device_x:
                                ::std::clone::Clone::clone(&(*__self_0_5)),
                            device_y:
                                ::std::clone::Clone::clone(&(*__self_0_6)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Anchor3 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Anchor3 {
                    format: ref __self_0_0,
                    x: ref __self_0_1,
                    y: ref __self_0_2,
                    device_x_offset: ref __self_0_3,
                    device_y_offset: ref __self_0_4,
                    device_x: ref __self_0_5,
                    device_y: ref __self_0_6 } => {
                        let mut builder = __arg_0.debug_struct("Anchor3");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("x", &&(*__self_0_1));
                        let _ = builder.field("y", &&(*__self_0_2));
                        let _ =
                            builder.field("device_x_offset", &&(*__self_0_3));
                        let _ =
                            builder.field("device_y_offset", &&(*__self_0_4));
                        let _ = builder.field("device_x", &&(*__self_0_5));
                        let _ = builder.field("device_y", &&(*__self_0_6));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Anchor3 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Anchor3 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.x,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.y,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device_x_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device_y_offset,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Anchor3,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Option<Device>> {
                                Ok(if this.device_x_offset > 0 {
                                       match tape.jump(position +
                                                           (this.device_x_offset
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       Some(match tape.take() {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            })
                                   } else { None })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device_x,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Anchor3,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Option<Device>> {
                                Ok(if this.device_y_offset > 0 {
                                       match tape.jump(position +
                                                           (this.device_y_offset
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       Some(match tape.take() {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            })
                                   } else { None })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.device_y,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A base attachment."]
        pub struct Base {
            pub anchor_offsets: Vec<u16>,
            pub anchors: Vec<Anchor>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Base {
            #[inline]
            fn clone(&self) -> Base {
                match *self {
                    Base {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    =>
                    Base{anchor_offsets:
                             ::std::clone::Clone::clone(&(*__self_0_0)),
                         anchors:
                             ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Base {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Base {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Base");
                        let _ =
                            builder.field("anchor_offsets", &&(*__self_0_0));
                        let _ = builder.field("anchors", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of base attachments."]
        pub struct Bases {
            pub count: u16,
            pub records: Vec<Base>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Bases {
            #[inline]
            fn clone(&self) -> Bases {
                match *self {
                    Bases { count: ref __self_0_0, records: ref __self_0_1 }
                    =>
                    Bases{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                          records:
                              ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Bases {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Bases { count: ref __self_0_0, records: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Bases");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("records", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A chaining class positioning rule."]
        pub struct ChainClassRule {
            pub backward_glyph_count: u16,
            pub backward_class_ids: Vec<u16>,
            pub input_glyph_count: u16,
            pub input_class_ids: Vec<u16>,
            pub forward_glyph_count: u16,
            pub forward_class_ids: Vec<u16>,
            pub operation_count: u16,
            pub operations: Vec<Positioning>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainClassRule {
            #[inline]
            fn clone(&self) -> ChainClassRule {
                match *self {
                    ChainClassRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_class_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_class_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_class_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } =>
                    ChainClassRule{backward_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_0)),
                                   backward_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_1)),
                                   input_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_2)),
                                   input_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_3)),
                                   forward_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_4)),
                                   forward_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_5)),
                                   operation_count:
                                       ::std::clone::Clone::clone(&(*__self_0_6)),
                                   operations:
                                       ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainClassRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainClassRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_class_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_class_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_class_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } => {
                        let mut builder =
                            __arg_0.debug_struct("ChainClassRule");
                        let _ =
                            builder.field("backward_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("backward_class_ids",
                                          &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_2));
                        let _ =
                            builder.field("input_class_ids", &&(*__self_0_3));
                        let _ =
                            builder.field("forward_glyph_count",
                                          &&(*__self_0_4));
                        let _ =
                            builder.field("forward_class_ids",
                                          &&(*__self_0_5));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_6));
                        let _ = builder.field("operations", &&(*__self_0_7));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainClassRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ChainClassRule =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.backward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed chaining class positioning rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.forward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Positioning>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of chaining class positioning rules."]
        pub struct ChainClassRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ChainClassRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainClassRules {
            #[inline]
            fn clone(&self) -> ChainClassRules {
                match *self {
                    ChainClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ChainClassRules{count:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    offsets:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    records:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainClassRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder =
                            __arg_0.debug_struct("ChainClassRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainClassRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ChainClassRules =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ChainClassRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A chaining positioning rule."]
        pub struct ChainRule {
            pub backward_glyph_count: u16,
            pub backward_glyph_ids: Vec<GlyphID>,
            pub input_glyph_count: u16,
            pub input_glyph_ids: Vec<GlyphID>,
            pub forward_glyph_count: u16,
            pub forward_glyph_ids: Vec<GlyphID>,
            pub operation_count: u16,
            pub operations: Vec<Positioning>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainRule {
            #[inline]
            fn clone(&self) -> ChainRule {
                match *self {
                    ChainRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_glyph_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_glyph_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_glyph_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } =>
                    ChainRule{backward_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              backward_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              input_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              input_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),
                              forward_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_4)),
                              forward_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_5)),
                              operation_count:
                                  ::std::clone::Clone::clone(&(*__self_0_6)),
                              operations:
                                  ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_glyph_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_glyph_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_glyph_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } => {
                        let mut builder = __arg_0.debug_struct("ChainRule");
                        let _ =
                            builder.field("backward_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("backward_glyph_ids",
                                          &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_2));
                        let _ =
                            builder.field("input_glyph_ids", &&(*__self_0_3));
                        let _ =
                            builder.field("forward_glyph_count",
                                          &&(*__self_0_4));
                        let _ =
                            builder.field("forward_glyph_ids",
                                          &&(*__self_0_5));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_6));
                        let _ = builder.field("operations", &&(*__self_0_7));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ChainRule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.backward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed chaining positioning rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.forward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Positioning>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of chaining positioning rules."]
        pub struct ChainRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ChainRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainRules {
            #[inline]
            fn clone(&self) -> ChainRules {
                match *self {
                    ChainRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ChainRules{count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               offsets:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),
                               records:
                                   ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("ChainRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ChainRules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ChainRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A class positioning rule."]
        pub struct ClassRule {
            pub input_glyph_count: u16,
            pub operation_count: u16,
            pub input_class_ids: Vec<u16>,
            pub operations: Vec<Positioning>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ClassRule {
            #[inline]
            fn clone(&self) -> ClassRule {
                match *self {
                    ClassRule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_class_ids: ref __self_0_2,
                    operations: ref __self_0_3 } =>
                    ClassRule{input_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              operation_count:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              input_class_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              operations:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ClassRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ClassRule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_class_ids: ref __self_0_2,
                    operations: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("ClassRule");
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_1));
                        let _ =
                            builder.field("input_class_ids", &&(*__self_0_2));
                        let _ = builder.field("operations", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ClassRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ClassRule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed class positioning rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_class_ids,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Positioning>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of class positioning rules."]
        pub struct ClassRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ClassRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ClassRules {
            #[inline]
            fn clone(&self) -> ClassRules {
                match *self {
                    ClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ClassRules{count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               offsets:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),
                               records:
                                   ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ClassRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("ClassRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ClassRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ClassRules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ClassRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A component attachment."]
        pub struct Component {
            pub anchor_offsets: Vec<u16>,
            pub anchors: Vec<Anchor>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Component {
            #[inline]
            fn clone(&self) -> Component {
                match *self {
                    Component {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    =>
                    Component{anchor_offsets:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              anchors:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Component {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Component {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Component");
                        let _ =
                            builder.field("anchor_offsets", &&(*__self_0_0));
                        let _ = builder.field("anchors", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A ligature attachment."]
        pub struct Ligature {
            pub component_count: u16,
            pub components: Vec<Component>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligature {
            #[inline]
            fn clone(&self) -> Ligature {
                match *self {
                    Ligature {
                    component_count: ref __self_0_0,
                    components: ref __self_0_1 } =>
                    Ligature{component_count:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             components:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligature {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligature {
                    component_count: ref __self_0_0,
                    components: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Ligature");
                        let _ =
                            builder.field("component_count", &&(*__self_0_0));
                        let _ = builder.field("components", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of ligature attachments."]
        pub struct Ligatures {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<Ligature>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligatures {
            #[inline]
            fn clone(&self) -> Ligatures {
                match *self {
                    Ligatures {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Ligatures{count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              offsets:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              records:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligatures {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligatures {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Ligatures");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A mark attachment in format 1."]
        pub struct Mark1 {
            pub class_id: u16,
            pub anchor_offset: u16,
            pub anchor: Anchor,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Mark1 {
            #[inline]
            fn clone(&self) -> Mark1 {
                match *self {
                    Mark1 {
                    class_id: ref __self_0_0,
                    anchor_offset: ref __self_0_1,
                    anchor: ref __self_0_2 } =>
                    Mark1{class_id:
                              ::std::clone::Clone::clone(&(*__self_0_0)),
                          anchor_offset:
                              ::std::clone::Clone::clone(&(*__self_0_1)),
                          anchor:
                              ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Mark1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Mark1 {
                    class_id: ref __self_0_0,
                    anchor_offset: ref __self_0_1,
                    anchor: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Mark1");
                        let _ = builder.field("class_id", &&(*__self_0_0));
                        let _ =
                            builder.field("anchor_offset", &&(*__self_0_1));
                        let _ = builder.field("anchor", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of mark attachments in format 1."]
        pub struct Mark1s {
            pub count: u16,
            pub records: Vec<Mark1>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Mark1s {
            #[inline]
            fn clone(&self) -> Mark1s {
                match *self {
                    Mark1s { count: ref __self_0_0, records: ref __self_0_1 }
                    =>
                    Mark1s{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                           records:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Mark1s {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Mark1s { count: ref __self_0_0, records: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Mark1s");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("records", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Mark1s {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Mark1s = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Mark1s,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Mark1>> {
                                let mut values =
                                    Vec::with_capacity(this.count as usize);
                                for _ in 0..(this.count as usize) {
                                    values.push(match tape.take_given(position)
                                                    {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                });
                                }
                                Ok(values)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A mark attachment in format 2."]
        pub struct Mark2 {
            pub anchor_offsets: Vec<u16>,
            pub anchors: Vec<Anchor>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Mark2 {
            #[inline]
            fn clone(&self) -> Mark2 {
                match *self {
                    Mark2 {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    =>
                    Mark2{anchor_offsets:
                              ::std::clone::Clone::clone(&(*__self_0_0)),
                          anchors:
                              ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Mark2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Mark2 {
                    anchor_offsets: ref __self_0_0, anchors: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Mark2");
                        let _ =
                            builder.field("anchor_offsets", &&(*__self_0_0));
                        let _ = builder.field("anchors", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of mark attachments in format 2."]
        pub struct Mark2s {
            pub count: u16,
            pub records: Vec<Mark2>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Mark2s {
            #[inline]
            fn clone(&self) -> Mark2s {
                match *self {
                    Mark2s { count: ref __self_0_0, records: ref __self_0_1 }
                    =>
                    Mark2s{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                           records:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Mark2s {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Mark2s { count: ref __self_0_0, records: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Mark2s");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("records", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A pair adjustment in format 1."]
        pub struct Pair1 {
            pub glyph2_id: GlyphID,
            pub value1: Single,
            pub value2: Single,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Pair1 {
            #[inline]
            fn clone(&self) -> Pair1 {
                match *self {
                    Pair1 {
                    glyph2_id: ref __self_0_0,
                    value1: ref __self_0_1,
                    value2: ref __self_0_2 } =>
                    Pair1{glyph2_id:
                              ::std::clone::Clone::clone(&(*__self_0_0)),
                          value1: ::std::clone::Clone::clone(&(*__self_0_1)),
                          value2:
                              ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Pair1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Pair1 {
                    glyph2_id: ref __self_0_0,
                    value1: ref __self_0_1,
                    value2: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Pair1");
                        let _ = builder.field("glyph2_id", &&(*__self_0_0));
                        let _ = builder.field("value1", &&(*__self_0_1));
                        let _ = builder.field("value2", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of pair adjustments in format 1."]
        pub struct Pair1s {
            pub count: u16,
            pub records: Vec<Pair1>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Pair1s {
            #[inline]
            fn clone(&self) -> Pair1s {
                match *self {
                    Pair1s { count: ref __self_0_0, records: ref __self_0_1 }
                    =>
                    Pair1s{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                           records:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Pair1s {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Pair1s { count: ref __self_0_0, records: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Pair1s");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("records", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A pair adjustment in format 2."]
        pub struct Pair2 {
            pub value1: Single,
            pub value2: Single,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Pair2 {
            #[inline]
            fn clone(&self) -> Pair2 {
                match *self {
                    Pair2 { value1: ref __self_0_0, value2: ref __self_0_1 }
                    =>
                    Pair2{value1: ::std::clone::Clone::clone(&(*__self_0_0)),
                          value2:
                              ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Pair2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Pair2 { value1: ref __self_0_0, value2: ref __self_0_1 }
                    => {
                        let mut builder = __arg_0.debug_struct("Pair2");
                        let _ = builder.field("value1", &&(*__self_0_0));
                        let _ = builder.field("value2", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A set of pair adjustments in format 2."]
        pub struct Pair2s {
            pub records: Vec<Pair2>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Pair2s {
            #[inline]
            fn clone(&self) -> Pair2s {
                match *self {
                    Pair2s { records: ref __self_0_0 } =>
                    Pair2s{records:
                               ::std::clone::Clone::clone(&(*__self_0_0)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Pair2s {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Pair2s { records: ref __self_0_0 } => {
                        let mut builder = __arg_0.debug_struct("Pair2s");
                        let _ = builder.field("records", &&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "An entry-exit record."]
        pub struct Passage {
            pub entry_offset: u16,
            pub exit_offset: u16,
            pub entry: Anchor,
            pub exit: Anchor,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Passage {
            #[inline]
            fn clone(&self) -> Passage {
                match *self {
                    Passage {
                    entry_offset: ref __self_0_0,
                    exit_offset: ref __self_0_1,
                    entry: ref __self_0_2,
                    exit: ref __self_0_3 } =>
                    Passage{entry_offset:
                                ::std::clone::Clone::clone(&(*__self_0_0)),
                            exit_offset:
                                ::std::clone::Clone::clone(&(*__self_0_1)),
                            entry: ::std::clone::Clone::clone(&(*__self_0_2)),
                            exit:
                                ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Passage {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Passage {
                    entry_offset: ref __self_0_0,
                    exit_offset: ref __self_0_1,
                    entry: ref __self_0_2,
                    exit: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Passage");
                        let _ =
                            builder.field("entry_offset", &&(*__self_0_0));
                        let _ = builder.field("exit_offset", &&(*__self_0_1));
                        let _ = builder.field("entry", &&(*__self_0_2));
                        let _ = builder.field("exit", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A positioning record."]
        pub struct Positioning {
            pub sequence_index: u16,
            pub lookup_index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Positioning {
            #[inline]
            fn clone(&self) -> Positioning {
                match *self {
                    Positioning {
                    sequence_index: ref __self_0_0,
                    lookup_index: ref __self_0_1 } =>
                    Positioning{sequence_index:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                lookup_index:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Positioning {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Positioning {
                    sequence_index: ref __self_0_0,
                    lookup_index: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Positioning");
                        let _ =
                            builder.field("sequence_index", &&(*__self_0_0));
                        let _ =
                            builder.field("lookup_index", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Positioning { }
        impl ::truetype::Value for Positioning {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Positioning = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.sequence_index,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_index,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A positioning rule."]
        pub struct Rule {
            pub input_glyph_count: u16,
            pub operation_count: u16,
            pub input_glyph_ids: Vec<GlyphID>,
            pub operations: Vec<Positioning>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Rule {
            #[inline]
            fn clone(&self) -> Rule {
                match *self {
                    Rule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_glyph_ids: ref __self_0_2,
                    operations: ref __self_0_3 } =>
                    Rule{input_glyph_count:
                             ::std::clone::Clone::clone(&(*__self_0_0)),
                         operation_count:
                             ::std::clone::Clone::clone(&(*__self_0_1)),
                         input_glyph_ids:
                             ::std::clone::Clone::clone(&(*__self_0_2)),
                         operations:
                             ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Rule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Rule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_glyph_ids: ref __self_0_2,
                    operations: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Rule");
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_ids", &&(*__self_0_2));
                        let _ = builder.field("operations", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Rule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Rule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed positioning rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Positioning>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of positioning rules."]
        pub struct Rules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<Rule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Rules {
            #[inline]
            fn clone(&self) -> Rules {
                match *self {
                    Rules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Rules{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                          offsets: ::std::clone::Clone::clone(&(*__self_0_1)),
                          records:
                              ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Rules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Rules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Rules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Rules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Rules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Rule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A single adjustment."]
        pub struct Single {
            pub x_placement: Option<i16>,
            pub y_placement: Option<i16>,
            pub x_advance: Option<i16>,
            pub y_advance: Option<i16>,
            pub device_x_placement_offset: Option<u16>,
            pub device_y_placement_offset: Option<u16>,
            pub device_x_advance_offset: Option<u16>,
            pub device_y_advance_offset: Option<u16>,
            pub device_x_placement: Option<Device>,
            pub device_y_placement: Option<Device>,
            pub device_x_advance: Option<Device>,
            pub device_y_advance: Option<Device>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Single {
            #[inline]
            fn clone(&self) -> Single {
                match *self {
                    Single {
                    x_placement: ref __self_0_0,
                    y_placement: ref __self_0_1,
                    x_advance: ref __self_0_2,
                    y_advance: ref __self_0_3,
                    device_x_placement_offset: ref __self_0_4,
                    device_y_placement_offset: ref __self_0_5,
                    device_x_advance_offset: ref __self_0_6,
                    device_y_advance_offset: ref __self_0_7,
                    device_x_placement: ref __self_0_8,
                    device_y_placement: ref __self_0_9,
                    device_x_advance: ref __self_0_10,
                    device_y_advance: ref __self_0_11 } =>
                    Single{x_placement:
                               ::std::clone::Clone::clone(&(*__self_0_0)),
                           y_placement:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           x_advance:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           y_advance:
                               ::std::clone::Clone::clone(&(*__self_0_3)),
                           device_x_placement_offset:
                               ::std::clone::Clone::clone(&(*__self_0_4)),
                           device_y_placement_offset:
                               ::std::clone::Clone::clone(&(*__self_0_5)),
                           device_x_advance_offset:
                               ::std::clone::Clone::clone(&(*__self_0_6)),
                           device_y_advance_offset:
                               ::std::clone::Clone::clone(&(*__self_0_7)),
                           device_x_placement:
                               ::std::clone::Clone::clone(&(*__self_0_8)),
                           device_y_placement:
                               ::std::clone::Clone::clone(&(*__self_0_9)),
                           device_x_advance:
                               ::std::clone::Clone::clone(&(*__self_0_10)),
                           device_y_advance:
                               ::std::clone::Clone::clone(&(*__self_0_11)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Single {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Single {
                    x_placement: ref __self_0_0,
                    y_placement: ref __self_0_1,
                    x_advance: ref __self_0_2,
                    y_advance: ref __self_0_3,
                    device_x_placement_offset: ref __self_0_4,
                    device_y_placement_offset: ref __self_0_5,
                    device_x_advance_offset: ref __self_0_6,
                    device_y_advance_offset: ref __self_0_7,
                    device_x_placement: ref __self_0_8,
                    device_y_placement: ref __self_0_9,
                    device_x_advance: ref __self_0_10,
                    device_y_advance: ref __self_0_11 } => {
                        let mut builder = __arg_0.debug_struct("Single");
                        let _ = builder.field("x_placement", &&(*__self_0_0));
                        let _ = builder.field("y_placement", &&(*__self_0_1));
                        let _ = builder.field("x_advance", &&(*__self_0_2));
                        let _ = builder.field("y_advance", &&(*__self_0_3));
                        let _ =
                            builder.field("device_x_placement_offset",
                                          &&(*__self_0_4));
                        let _ =
                            builder.field("device_y_placement_offset",
                                          &&(*__self_0_5));
                        let _ =
                            builder.field("device_x_advance_offset",
                                          &&(*__self_0_6));
                        let _ =
                            builder.field("device_y_advance_offset",
                                          &&(*__self_0_7));
                        let _ =
                            builder.field("device_x_placement",
                                          &&(*__self_0_8));
                        let _ =
                            builder.field("device_y_placement",
                                          &&(*__self_0_9));
                        let _ =
                            builder.field("device_x_advance",
                                          &&(*__self_0_10));
                        let _ =
                            builder.field("device_y_advance",
                                          &&(*__self_0_11));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "Single-adjustment flags."]
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub struct SingleFlags(pub u16);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for SingleFlags {
            #[inline]
            fn clone(&self) -> SingleFlags {
                { let _: ::std::clone::AssertParamIsClone<u16>; *self }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for SingleFlags { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for SingleFlags {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    SingleFlags(ref __self_0_0) => {
                        let mut builder = __arg_0.debug_tuple("SingleFlags");
                        let _ = builder.field(&&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for SingleFlags {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                { let _: ::std::cmp::AssertParamIsEq<u16>; }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for SingleFlags {
            #[inline]
            fn eq(&self, __arg_0: &SingleFlags) -> bool {
                match *__arg_0 {
                    SingleFlags(ref __self_1_0) =>
                    match *self {
                        SingleFlags(ref __self_0_0) =>
                        true && (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, __arg_0: &SingleFlags) -> bool {
                match *__arg_0 {
                    SingleFlags(ref __self_1_0) =>
                    match *self {
                        SingleFlags(ref __self_0_0) =>
                        false || (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl SingleFlags {
            #[inline(always)]
            pub fn has_x_placement(&self) -> bool { self.0 & 1 > 0 }
            #[inline(always)]
            pub fn has_y_placement(&self) -> bool { self.0 & 2 > 0 }
            #[inline(always)]
            pub fn has_x_advance(&self) -> bool { self.0 & 4 > 0 }
            #[inline(always)]
            pub fn has_y_advance(&self) -> bool { self.0 & 8 > 0 }
            #[inline(always)]
            pub fn has_device_x_placement(&self) -> bool { self.0 & 16 > 0 }
            #[inline(always)]
            pub fn has_device_y_placement(&self) -> bool { self.0 & 32 > 0 }
            #[inline(always)]
            pub fn has_device_x_advance(&self) -> bool { self.0 & 64 > 0 }
            #[inline(always)]
            pub fn has_device_y_advance(&self) -> bool { self.0 & 128 > 0 }
            #[inline(always)]
            pub fn is_invalid(&self) -> bool { self.0 & 65280 > 0 }
        }
        impl ::truetype::Value for SingleFlags {
            #[inline(always)]
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let value =
                    SingleFlags(match tape.take::<u16>() {
                                    ::std::result::Result::Ok(val) => val,
                                    ::std::result::Result::Err(err) => {
                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                    }
                                });
                if value.is_invalid() {
                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                      "found malformed flags"));
                }
                Ok(value)
            }
        }
        impl From<SingleFlags> for u16 {
            #[inline(always)]
            fn from(flags: SingleFlags) -> u16 { flags.0 }
        }
        impl Value for Anchor {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                Ok(match match tape.peek::<u16>() {
                             ::std::result::Result::Ok(val) => val,
                             ::std::result::Result::Err(err) => {
                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                             }
                         } {
                       1 =>
                       Anchor::Format1(match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }),
                       2 =>
                       Anchor::Format2(match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }),
                       3 =>
                       Anchor::Format3(match tape.take() {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       }),
                       _ =>
                       return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                         "found an unknown format of the anchor table")),
                   })
            }
        }
        impl Walue<'static> for Base {
            type
            Parameter
            =
            (u64, u16);
            fn read<T: Tape>(tape: &mut T,
                             (position, class_count): Self::Parameter)
             -> Result<Self> {
                let anchor_offsets: Vec<u16> =
                    match tape.take_given(class_count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let anchors =
                    {
                        let mut values =
                            Vec::with_capacity(class_count as usize);
                        for i in 0..(class_count as usize) {
                            match tape.jump(position +
                                                (anchor_offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Base{anchor_offsets: anchor_offsets, anchors: anchors,})
            }
        }
        impl Walue<'static> for Bases {
            type
            Parameter
            =
            u16;
            fn read<T: Tape>(tape: &mut T, class_count: u16) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let count =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut records = Vec::with_capacity(count as usize);
                for _ in 0..(count as usize) {
                    records.push(match tape.take_given((position,
                                                        class_count)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 });
                }
                Ok(Bases{count: count, records: records,})
            }
        }
        impl Walue<'static> for Component {
            type
            Parameter
            =
            (u64, u16);
            fn read<T: Tape>(tape: &mut T,
                             (position, class_count): Self::Parameter)
             -> Result<Self> {
                let anchor_offsets: Vec<u16> =
                    match tape.take_given(class_count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let anchors =
                    {
                        let mut values =
                            Vec::with_capacity(class_count as usize);
                        for i in 0..(class_count as usize) {
                            match tape.jump(position +
                                                (anchor_offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Component{anchor_offsets: anchor_offsets,
                             anchors: anchors,})
            }
        }
        impl Walue<'static> for Ligature {
            type
            Parameter
            =
            u16;
            fn read<T: Tape>(tape: &mut T, class_count: u16) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let component_count =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut components =
                    Vec::with_capacity(component_count as usize);
                for _ in 0..(component_count as usize) {
                    components.push(match tape.take_given((position,
                                                           class_count)) {
                                        ::std::result::Result::Ok(val) => val,
                                        ::std::result::Result::Err(err) => {
                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                        }
                                    });
                }
                Ok(Ligature{component_count: component_count,
                            components: components,})
            }
        }
        impl Walue<'static> for Ligatures {
            type
            Parameter
            =
            u16;
            fn read<T: Tape>(tape: &mut T, class_count: u16) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let count =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let offsets: Vec<u16> =
                    match tape.take_given(count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let records =
                    {
                        let mut values = Vec::with_capacity(count as usize);
                        for i in 0..(count as usize) {
                            match tape.jump(position + (offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take_given(class_count) {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Ligatures{count: count,
                             offsets: offsets,
                             records: records,})
            }
        }
        impl Walue<'static> for Mark1 {
            type
            Parameter
            =
            u64;
            fn read<T: Tape>(tape: &mut T, position: u64) -> Result<Self> {
                let class_id =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let anchor_offset =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let anchor =
                    {
                        match tape.jump(position + (anchor_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                Ok(Mark1{class_id: class_id,
                         anchor_offset: anchor_offset,
                         anchor: anchor,})
            }
        }
        impl Walue<'static> for Mark2 {
            type
            Parameter
            =
            (u64, u16);
            fn read<T: Tape>(tape: &mut T,
                             (position, class_count): Self::Parameter)
             -> Result<Self> {
                let anchor_offsets: Vec<u16> =
                    match tape.take_given(class_count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let anchors =
                    {
                        let mut values =
                            Vec::with_capacity(class_count as usize);
                        for i in 0..(class_count as usize) {
                            match tape.jump(position +
                                                (anchor_offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Mark2{anchor_offsets: anchor_offsets, anchors: anchors,})
            }
        }
        impl Walue<'static> for Mark2s {
            type
            Parameter
            =
            u16;
            fn read<T: Tape>(tape: &mut T, class_count: u16) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let count =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut records = Vec::with_capacity(count as usize);
                for _ in 0..(count as usize) {
                    records.push(match tape.take_given((position,
                                                        class_count)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 });
                }
                Ok(Mark2s{count: count, records: records,})
            }
        }
        impl Walue<'static> for Pair1 {
            type
            Parameter
            =
            (u64, SingleFlags, SingleFlags);
            fn read<T: Tape>(tape: &mut T,
                             (position, value1_flags, value2_flags):
                                 Self::Parameter) -> Result<Self> {
                Ok(Pair1{glyph2_id:
                             match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         value1:
                             match tape.take_given((position, value1_flags)) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         value2:
                             match tape.take_given((position, value2_flags)) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },})
            }
        }
        impl Walue<'static> for Pair1s {
            type
            Parameter
            =
            (u64, SingleFlags, SingleFlags);
            fn read<T: Tape>(tape: &mut T, parameter: Self::Parameter)
             -> Result<Self> {
                let count =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut records = Vec::with_capacity(count as usize);
                for _ in 0..(count as usize) {
                    records.push(match tape.take_given(parameter) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 });
                }
                Ok(Pair1s{count: count, records: records,})
            }
        }
        impl Walue<'static> for Pair2 {
            type
            Parameter
            =
            (u64, SingleFlags, SingleFlags);
            fn read<T: Tape>(tape: &mut T,
                             (position, value1_flags, value2_flags):
                                 Self::Parameter) -> Result<Self> {
                Ok(Pair2{value1:
                             match tape.take_given((position, value1_flags)) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },
                         value2:
                             match tape.take_given((position, value2_flags)) {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             },})
            }
        }
        impl Walue<'static> for Pair2s {
            type
            Parameter
            =
            (u64, u16, SingleFlags, SingleFlags);
            fn read<T: Tape>(tape: &mut T,
                             (position, class2_count, value1_flags,
                              value2_flags): Self::Parameter)
             -> Result<Self> {
                let mut records = Vec::with_capacity(class2_count as usize);
                for _ in 0..(class2_count as usize) {
                    records.push(match tape.take_given((position,
                                                        value1_flags,
                                                        value2_flags)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 });
                }
                Ok(Pair2s{records: records,})
            }
        }
        impl Walue<'static> for Passage {
            type
            Parameter
            =
            u64;
            fn read<T: Tape>(tape: &mut T, position: u64) -> Result<Self> {
                let entry_offset =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let exit_offset =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let entry =
                    {
                        match tape.jump(position + (entry_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                let exit =
                    {
                        match tape.jump(position + (exit_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                Ok(Passage{entry_offset: entry_offset,
                           exit_offset: exit_offset,
                           entry: entry,
                           exit: exit,})
            }
        }
        impl Walue<'static> for Single {
            type
            Parameter
            =
            (u64, SingleFlags);
            fn read<T: Tape>(tape: &mut T, (position, flags): Self::Parameter)
             -> Result<Self> {
                let x_placement =
                    if flags.has_x_placement() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let y_placement =
                    if flags.has_y_placement() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let x_advance =
                    if flags.has_x_advance() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let y_advance =
                    if flags.has_y_advance() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let device_x_placement_offset =
                    if flags.has_device_x_placement() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let device_y_placement_offset =
                    if flags.has_device_y_placement() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let device_x_advance_offset =
                    if flags.has_device_x_advance() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let device_y_advance_offset =
                    if flags.has_device_y_advance() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let device_x_placement =
                    match device_x_placement_offset {
                        Some(offset) =>
                        Some({
                                 match tape.jump(position + (offset as u64)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 };
                                 match tape.take() {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 }
                             }),
                        _ => None,
                    };
                let device_y_placement =
                    match device_y_placement_offset {
                        Some(offset) =>
                        Some({
                                 match tape.jump(position + (offset as u64)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 };
                                 match tape.take() {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 }
                             }),
                        _ => None,
                    };
                let device_x_advance =
                    match device_x_advance_offset {
                        Some(offset) =>
                        Some({
                                 match tape.jump(position + (offset as u64)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 };
                                 match tape.take() {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 }
                             }),
                        _ => None,
                    };
                let device_y_advance =
                    match device_y_advance_offset {
                        Some(offset) =>
                        Some({
                                 match tape.jump(position + (offset as u64)) {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 };
                                 match tape.take() {
                                     ::std::result::Result::Ok(val) => val,
                                     ::std::result::Result::Err(err) => {
                                         return ::std::result::Result::Err(::std::convert::From::from(err))
                                     }
                                 }
                             }),
                        _ => None,
                    };
                Ok(Single{x_placement: x_placement,
                          y_placement: y_placement,
                          x_advance: x_advance,
                          y_advance: y_advance,
                          device_x_placement_offset:
                              device_x_placement_offset,
                          device_y_placement_offset:
                              device_y_placement_offset,
                          device_x_advance_offset: device_x_advance_offset,
                          device_y_advance_offset: device_y_advance_offset,
                          device_x_placement: device_x_placement,
                          device_y_placement: device_y_placement,
                          device_x_advance: device_x_advance,
                          device_y_advance: device_y_advance,})
            }
        }
    }
    pub use self::element::*;
    /// A glyph-positioning table.
    pub type GlyphPositioning = Directory<Table>;
    /// An inner table of a glyph-positioning table.
    pub enum Table {
        SingleAdjustment(SingleAdjustment),
        PairAdjustment(PairAdjustment),
        CursiveAttachment(CursiveAttachment),
        MarkToBaseAttachment(MarkToBaseAttachment),
        MarkToLigatureAttachment(MarkToLigatureAttachment),
        MarkToMarkAttachment(MarkToMarkAttachment),
        ContextPositioning(ContextPositioning),
        ChainContextPositioning(ChainContextPositioning),
        ExtensionPositioning(ExtensionPositioning),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Table {
        #[inline]
        fn clone(&self) -> Table {
            match (&*self,) {
                (&Table::SingleAdjustment(ref __self_0),) =>
                Table::SingleAdjustment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::PairAdjustment(ref __self_0),) =>
                Table::PairAdjustment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::CursiveAttachment(ref __self_0),) =>
                Table::CursiveAttachment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::MarkToBaseAttachment(ref __self_0),) =>
                Table::MarkToBaseAttachment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::MarkToLigatureAttachment(ref __self_0),) =>
                Table::MarkToLigatureAttachment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::MarkToMarkAttachment(ref __self_0),) =>
                Table::MarkToMarkAttachment(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ContextPositioning(ref __self_0),) =>
                Table::ContextPositioning(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ChainContextPositioning(ref __self_0),) =>
                Table::ChainContextPositioning(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ExtensionPositioning(ref __self_0),) =>
                Table::ExtensionPositioning(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Table {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Table::SingleAdjustment(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("SingleAdjustment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::PairAdjustment(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("PairAdjustment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::CursiveAttachment(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("CursiveAttachment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::MarkToBaseAttachment(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("MarkToBaseAttachment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::MarkToLigatureAttachment(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("MarkToLigatureAttachment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::MarkToMarkAttachment(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("MarkToMarkAttachment");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ContextPositioning(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ContextPositioning");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ChainContextPositioning(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ChainContextPositioning");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ExtensionPositioning(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ExtensionPositioning");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    /// A table for adjusting single glyphs.
    pub enum SingleAdjustment {

        /// Format 1.
        Format1(SingleAdjustment1),

        /// Format 2.
        Format2(SingleAdjustment2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleAdjustment {
        #[inline]
        fn clone(&self) -> SingleAdjustment {
            match (&*self,) {
                (&SingleAdjustment::Format1(ref __self_0),) =>
                SingleAdjustment::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&SingleAdjustment::Format2(ref __self_0),) =>
                SingleAdjustment::Format2(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleAdjustment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&SingleAdjustment::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&SingleAdjustment::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "A table for adjusting single glyphs in format 1."]
    pub struct SingleAdjustment1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub value_flags: SingleFlags,
        pub value: Single,
        pub coverage: Coverage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleAdjustment1 {
        #[inline]
        fn clone(&self) -> SingleAdjustment1 {
            match *self {
                SingleAdjustment1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value_flags: ref __self_0_2,
                value: ref __self_0_3,
                coverage: ref __self_0_4 } =>
                SingleAdjustment1{format:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),
                                  coverage_offset:
                                      ::std::clone::Clone::clone(&(*__self_0_1)),
                                  value_flags:
                                      ::std::clone::Clone::clone(&(*__self_0_2)),
                                  value:
                                      ::std::clone::Clone::clone(&(*__self_0_3)),
                                  coverage:
                                      ::std::clone::Clone::clone(&(*__self_0_4)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleAdjustment1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                SingleAdjustment1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value_flags: ref __self_0_2,
                value: ref __self_0_3,
                coverage: ref __self_0_4 } => {
                    let mut builder =
                        __arg_0.debug_struct("SingleAdjustment1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("value_flags", &&(*__self_0_2));
                    let _ = builder.field("value", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for SingleAdjustment1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: SingleAdjustment1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value_flags,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &SingleAdjustment1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Single> {
                            tape.take_given((position, this.value_flags))
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &SingleAdjustment1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for adjusting single glyphs in format 2."]
    pub struct SingleAdjustment2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub value_flags: SingleFlags,
        pub value_count: u16,
        pub values: Vec<Single>,
        pub coverage: Coverage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleAdjustment2 {
        #[inline]
        fn clone(&self) -> SingleAdjustment2 {
            match *self {
                SingleAdjustment2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value_flags: ref __self_0_2,
                value_count: ref __self_0_3,
                values: ref __self_0_4,
                coverage: ref __self_0_5 } =>
                SingleAdjustment2{format:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),
                                  coverage_offset:
                                      ::std::clone::Clone::clone(&(*__self_0_1)),
                                  value_flags:
                                      ::std::clone::Clone::clone(&(*__self_0_2)),
                                  value_count:
                                      ::std::clone::Clone::clone(&(*__self_0_3)),
                                  values:
                                      ::std::clone::Clone::clone(&(*__self_0_4)),
                                  coverage:
                                      ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleAdjustment2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                SingleAdjustment2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value_flags: ref __self_0_2,
                value_count: ref __self_0_3,
                values: ref __self_0_4,
                coverage: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("SingleAdjustment2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("value_flags", &&(*__self_0_2));
                    let _ = builder.field("value_count", &&(*__self_0_3));
                    let _ = builder.field("values", &&(*__self_0_4));
                    let _ = builder.field("coverage", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for SingleAdjustment2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: SingleAdjustment2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value_flags,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &SingleAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Single>> {
                            let mut values =
                                Vec::with_capacity(this.value_count as usize);
                            for _ in 0..(this.value_count as usize) {
                                values.push(match tape.take_given((position,
                                                                   this.value_flags))
                                                {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            });
                            }
                            Ok(values)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.values,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &SingleAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            Ok(table)
        }
    }
    /// A table for adjusting pairs of glyphs.
    pub enum PairAdjustment {

        /// Format 1.
        Format1(PairAdjustment1),

        /// Format 2.
        Format2(PairAdjustment2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PairAdjustment {
        #[inline]
        fn clone(&self) -> PairAdjustment {
            match (&*self,) {
                (&PairAdjustment::Format1(ref __self_0),) =>
                PairAdjustment::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&PairAdjustment::Format2(ref __self_0),) =>
                PairAdjustment::Format2(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PairAdjustment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&PairAdjustment::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&PairAdjustment::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "A table for adjusting pairs of glyphs in format 1."]
    pub struct PairAdjustment1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub value1_flags: SingleFlags,
        pub value2_flags: SingleFlags,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Pair1s>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PairAdjustment1 {
        #[inline]
        fn clone(&self) -> PairAdjustment1 {
            match *self {
                PairAdjustment1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value1_flags: ref __self_0_2,
                value2_flags: ref __self_0_3,
                set_count: ref __self_0_4,
                set_offsets: ref __self_0_5,
                coverage: ref __self_0_6,
                sets: ref __self_0_7 } =>
                PairAdjustment1{format:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                coverage_offset:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),
                                value1_flags:
                                    ::std::clone::Clone::clone(&(*__self_0_2)),
                                value2_flags:
                                    ::std::clone::Clone::clone(&(*__self_0_3)),
                                set_count:
                                    ::std::clone::Clone::clone(&(*__self_0_4)),
                                set_offsets:
                                    ::std::clone::Clone::clone(&(*__self_0_5)),
                                coverage:
                                    ::std::clone::Clone::clone(&(*__self_0_6)),
                                sets:
                                    ::std::clone::Clone::clone(&(*__self_0_7)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PairAdjustment1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                PairAdjustment1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value1_flags: ref __self_0_2,
                value2_flags: ref __self_0_3,
                set_count: ref __self_0_4,
                set_offsets: ref __self_0_5,
                coverage: ref __self_0_6,
                sets: ref __self_0_7 } => {
                    let mut builder = __arg_0.debug_struct("PairAdjustment1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("value1_flags", &&(*__self_0_2));
                    let _ = builder.field("value2_flags", &&(*__self_0_3));
                    let _ = builder.field("set_count", &&(*__self_0_4));
                    let _ = builder.field("set_offsets", &&(*__self_0_5));
                    let _ = builder.field("coverage", &&(*__self_0_6));
                    let _ = builder.field("sets", &&(*__self_0_7));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for PairAdjustment1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: PairAdjustment1 = unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value1_flags,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value2_flags,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment1,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Pair1s>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take_given((position,
                                                                          this.value1_flags,
                                                                          this.value2_flags))
                                                       {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for adjusting pairs of glyphs in format 2."]
    pub struct PairAdjustment2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub value1_flags: SingleFlags,
        pub value2_flags: SingleFlags,
        pub class1_offset: u16,
        pub class2_offset: u16,
        pub class1_count: u16,
        pub class2_count: u16,
        pub sets: Vec<Pair2s>,
        pub coverage: Coverage,
        pub class1: Class,
        pub class2: Class,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PairAdjustment2 {
        #[inline]
        fn clone(&self) -> PairAdjustment2 {
            match *self {
                PairAdjustment2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value1_flags: ref __self_0_2,
                value2_flags: ref __self_0_3,
                class1_offset: ref __self_0_4,
                class2_offset: ref __self_0_5,
                class1_count: ref __self_0_6,
                class2_count: ref __self_0_7,
                sets: ref __self_0_8,
                coverage: ref __self_0_9,
                class1: ref __self_0_10,
                class2: ref __self_0_11 } =>
                PairAdjustment2{format:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                coverage_offset:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),
                                value1_flags:
                                    ::std::clone::Clone::clone(&(*__self_0_2)),
                                value2_flags:
                                    ::std::clone::Clone::clone(&(*__self_0_3)),
                                class1_offset:
                                    ::std::clone::Clone::clone(&(*__self_0_4)),
                                class2_offset:
                                    ::std::clone::Clone::clone(&(*__self_0_5)),
                                class1_count:
                                    ::std::clone::Clone::clone(&(*__self_0_6)),
                                class2_count:
                                    ::std::clone::Clone::clone(&(*__self_0_7)),
                                sets:
                                    ::std::clone::Clone::clone(&(*__self_0_8)),
                                coverage:
                                    ::std::clone::Clone::clone(&(*__self_0_9)),
                                class1:
                                    ::std::clone::Clone::clone(&(*__self_0_10)),
                                class2:
                                    ::std::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PairAdjustment2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                PairAdjustment2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                value1_flags: ref __self_0_2,
                value2_flags: ref __self_0_3,
                class1_offset: ref __self_0_4,
                class2_offset: ref __self_0_5,
                class1_count: ref __self_0_6,
                class2_count: ref __self_0_7,
                sets: ref __self_0_8,
                coverage: ref __self_0_9,
                class1: ref __self_0_10,
                class2: ref __self_0_11 } => {
                    let mut builder = __arg_0.debug_struct("PairAdjustment2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("value1_flags", &&(*__self_0_2));
                    let _ = builder.field("value2_flags", &&(*__self_0_3));
                    let _ = builder.field("class1_offset", &&(*__self_0_4));
                    let _ = builder.field("class2_offset", &&(*__self_0_5));
                    let _ = builder.field("class1_count", &&(*__self_0_6));
                    let _ = builder.field("class2_count", &&(*__self_0_7));
                    let _ = builder.field("sets", &&(*__self_0_8));
                    let _ = builder.field("coverage", &&(*__self_0_9));
                    let _ = builder.field("class1", &&(*__self_0_10));
                    let _ = builder.field("class2", &&(*__self_0_11));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for PairAdjustment2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: PairAdjustment2 = unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value1_flags,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.value2_flags,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class1_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class2_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class1_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class2_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Pair2s>> {
                            let mut values =
                                Vec::with_capacity(this.class1_count as
                                                       usize);
                            for _ in 0..(this.class1_count as usize) {
                                values.push(match tape.take_given((position,
                                                                   this.class2_count,
                                                                   this.value1_flags,
                                                                   this.value2_flags))
                                                {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            });
                            }
                            Ok(values)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.class1_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class1,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &PairAdjustment2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.class2_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class2,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for attaching cursive glyphs."]
    pub struct CursiveAttachment {
        pub format: u16,
        pub coverage_offset: u16,
        pub passage_count: u16,
        pub passages: Vec<Passage>,
        pub coverage: Coverage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for CursiveAttachment {
        #[inline]
        fn clone(&self) -> CursiveAttachment {
            match *self {
                CursiveAttachment {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                passage_count: ref __self_0_2,
                passages: ref __self_0_3,
                coverage: ref __self_0_4 } =>
                CursiveAttachment{format:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),
                                  coverage_offset:
                                      ::std::clone::Clone::clone(&(*__self_0_1)),
                                  passage_count:
                                      ::std::clone::Clone::clone(&(*__self_0_2)),
                                  passages:
                                      ::std::clone::Clone::clone(&(*__self_0_3)),
                                  coverage:
                                      ::std::clone::Clone::clone(&(*__self_0_4)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for CursiveAttachment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                CursiveAttachment {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                passage_count: ref __self_0_2,
                passages: ref __self_0_3,
                coverage: ref __self_0_4 } => {
                    let mut builder =
                        __arg_0.debug_struct("CursiveAttachment");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("passage_count", &&(*__self_0_2));
                    let _ = builder.field("passages", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for CursiveAttachment {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: CursiveAttachment =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.passage_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &CursiveAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Passage>> {
                            let mut values =
                                Vec::with_capacity(this.passage_count as
                                                       usize);
                            for _ in 0..(this.passage_count as usize) {
                                values.push(match tape.take_given(position) {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            });
                            }
                            Ok(values)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.passages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this: &CursiveAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for attaching combining marks to base glyphs."]
    pub struct MarkToBaseAttachment {
        pub format: u16,
        pub mark_coverage_offset: u16,
        pub base_coverage_offset: u16,
        pub class_count: u16,
        pub marks_offset: u16,
        pub bases_offset: u16,
        pub mark_coverage: Coverage,
        pub base_coverage: Coverage,
        pub marks: Mark1s,
        pub bases: Bases,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkToBaseAttachment {
        #[inline]
        fn clone(&self) -> MarkToBaseAttachment {
            match *self {
                MarkToBaseAttachment {
                format: ref __self_0_0,
                mark_coverage_offset: ref __self_0_1,
                base_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                marks_offset: ref __self_0_4,
                bases_offset: ref __self_0_5,
                mark_coverage: ref __self_0_6,
                base_coverage: ref __self_0_7,
                marks: ref __self_0_8,
                bases: ref __self_0_9 } =>
                MarkToBaseAttachment{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     mark_coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     base_coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     class_count:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     marks_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     bases_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),
                                     mark_coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_6)),
                                     base_coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_7)),
                                     marks:
                                         ::std::clone::Clone::clone(&(*__self_0_8)),
                                     bases:
                                         ::std::clone::Clone::clone(&(*__self_0_9)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkToBaseAttachment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                MarkToBaseAttachment {
                format: ref __self_0_0,
                mark_coverage_offset: ref __self_0_1,
                base_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                marks_offset: ref __self_0_4,
                bases_offset: ref __self_0_5,
                mark_coverage: ref __self_0_6,
                base_coverage: ref __self_0_7,
                marks: ref __self_0_8,
                bases: ref __self_0_9 } => {
                    let mut builder =
                        __arg_0.debug_struct("MarkToBaseAttachment");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ =
                        builder.field("mark_coverage_offset",
                                      &&(*__self_0_1));
                    let _ =
                        builder.field("base_coverage_offset",
                                      &&(*__self_0_2));
                    let _ = builder.field("class_count", &&(*__self_0_3));
                    let _ = builder.field("marks_offset", &&(*__self_0_4));
                    let _ = builder.field("bases_offset", &&(*__self_0_5));
                    let _ = builder.field("mark_coverage", &&(*__self_0_6));
                    let _ = builder.field("base_coverage", &&(*__self_0_7));
                    let _ = builder.field("marks", &&(*__self_0_8));
                    let _ = builder.field("bases", &&(*__self_0_9));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for MarkToBaseAttachment {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: MarkToBaseAttachment =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.base_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.bases_offset,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToBaseAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToBaseAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.base_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.base_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToBaseAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Mark1s> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.marks_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToBaseAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Bases> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.bases_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take_given(this.class_count) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.bases,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for attaching combining marks to ligatures."]
    pub struct MarkToLigatureAttachment {
        pub format: u16,
        pub mark_coverage_offset: u16,
        pub ligature_coverage_offset: u16,
        pub class_count: u16,
        pub marks_offset: u16,
        pub ligatures_offset: u16,
        pub mark_coverage: Coverage,
        pub ligature_coverage: Coverage,
        pub marks: Mark1s,
        pub ligatures: Ligatures,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkToLigatureAttachment {
        #[inline]
        fn clone(&self) -> MarkToLigatureAttachment {
            match *self {
                MarkToLigatureAttachment {
                format: ref __self_0_0,
                mark_coverage_offset: ref __self_0_1,
                ligature_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                marks_offset: ref __self_0_4,
                ligatures_offset: ref __self_0_5,
                mark_coverage: ref __self_0_6,
                ligature_coverage: ref __self_0_7,
                marks: ref __self_0_8,
                ligatures: ref __self_0_9 } =>
                MarkToLigatureAttachment{format:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         mark_coverage_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),
                                         ligature_coverage_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_2)),
                                         class_count:
                                             ::std::clone::Clone::clone(&(*__self_0_3)),
                                         marks_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_4)),
                                         ligatures_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_5)),
                                         mark_coverage:
                                             ::std::clone::Clone::clone(&(*__self_0_6)),
                                         ligature_coverage:
                                             ::std::clone::Clone::clone(&(*__self_0_7)),
                                         marks:
                                             ::std::clone::Clone::clone(&(*__self_0_8)),
                                         ligatures:
                                             ::std::clone::Clone::clone(&(*__self_0_9)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkToLigatureAttachment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                MarkToLigatureAttachment {
                format: ref __self_0_0,
                mark_coverage_offset: ref __self_0_1,
                ligature_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                marks_offset: ref __self_0_4,
                ligatures_offset: ref __self_0_5,
                mark_coverage: ref __self_0_6,
                ligature_coverage: ref __self_0_7,
                marks: ref __self_0_8,
                ligatures: ref __self_0_9 } => {
                    let mut builder =
                        __arg_0.debug_struct("MarkToLigatureAttachment");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ =
                        builder.field("mark_coverage_offset",
                                      &&(*__self_0_1));
                    let _ =
                        builder.field("ligature_coverage_offset",
                                      &&(*__self_0_2));
                    let _ = builder.field("class_count", &&(*__self_0_3));
                    let _ = builder.field("marks_offset", &&(*__self_0_4));
                    let _ =
                        builder.field("ligatures_offset", &&(*__self_0_5));
                    let _ = builder.field("mark_coverage", &&(*__self_0_6));
                    let _ =
                        builder.field("ligature_coverage", &&(*__self_0_7));
                    let _ = builder.field("marks", &&(*__self_0_8));
                    let _ = builder.field("ligatures", &&(*__self_0_9));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for MarkToLigatureAttachment {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: MarkToLigatureAttachment =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligature_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligatures_offset,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToLigatureAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToLigatureAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.ligature_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligature_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToLigatureAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Mark1s> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.marks_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.marks,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToLigatureAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Ligatures> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.ligatures_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take_given(this.class_count) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.ligatures,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for attaching combining marks to other marks."]
    pub struct MarkToMarkAttachment {
        pub format: u16,
        pub mark1_coverage_offset: u16,
        pub mark2_coverage_offset: u16,
        pub class_count: u16,
        pub mark1s_offset: u16,
        pub mark2s_offset: u16,
        pub mark1_coverage: Coverage,
        pub mark2_coverage: Coverage,
        pub mark1s: Mark1s,
        pub mark2s: Mark2s,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkToMarkAttachment {
        #[inline]
        fn clone(&self) -> MarkToMarkAttachment {
            match *self {
                MarkToMarkAttachment {
                format: ref __self_0_0,
                mark1_coverage_offset: ref __self_0_1,
                mark2_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                mark1s_offset: ref __self_0_4,
                mark2s_offset: ref __self_0_5,
                mark1_coverage: ref __self_0_6,
                mark2_coverage: ref __self_0_7,
                mark1s: ref __self_0_8,
                mark2s: ref __self_0_9 } =>
                MarkToMarkAttachment{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     mark1_coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     mark2_coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     class_count:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     mark1s_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     mark2s_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),
                                     mark1_coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_6)),
                                     mark2_coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_7)),
                                     mark1s:
                                         ::std::clone::Clone::clone(&(*__self_0_8)),
                                     mark2s:
                                         ::std::clone::Clone::clone(&(*__self_0_9)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkToMarkAttachment {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                MarkToMarkAttachment {
                format: ref __self_0_0,
                mark1_coverage_offset: ref __self_0_1,
                mark2_coverage_offset: ref __self_0_2,
                class_count: ref __self_0_3,
                mark1s_offset: ref __self_0_4,
                mark2s_offset: ref __self_0_5,
                mark1_coverage: ref __self_0_6,
                mark2_coverage: ref __self_0_7,
                mark1s: ref __self_0_8,
                mark2s: ref __self_0_9 } => {
                    let mut builder =
                        __arg_0.debug_struct("MarkToMarkAttachment");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ =
                        builder.field("mark1_coverage_offset",
                                      &&(*__self_0_1));
                    let _ =
                        builder.field("mark2_coverage_offset",
                                      &&(*__self_0_2));
                    let _ = builder.field("class_count", &&(*__self_0_3));
                    let _ = builder.field("mark1s_offset", &&(*__self_0_4));
                    let _ = builder.field("mark2s_offset", &&(*__self_0_5));
                    let _ = builder.field("mark1_coverage", &&(*__self_0_6));
                    let _ = builder.field("mark2_coverage", &&(*__self_0_7));
                    let _ = builder.field("mark1s", &&(*__self_0_8));
                    let _ = builder.field("mark2s", &&(*__self_0_9));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for MarkToMarkAttachment {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: MarkToMarkAttachment =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark1_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark2_coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark1s_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark2s_offset,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToMarkAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark1_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark1_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToMarkAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark2_coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark2_coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToMarkAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Mark1s> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark1s_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark1s,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MarkToMarkAttachment,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Mark2s> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.mark2s_offset as
                                                            u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take_given(this.class_count) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.mark2s,
                                                       value));
            }
            Ok(table)
        }
    }
    /// A table for positioning glyphs in a context.
    pub enum ContextPositioning {

        /// Format 1.
        Format1(ContextPositioning1),

        /// Format 2.
        Format2(ContextPositioning2),

        /// Format 3.
        Format3(ContextPositioning3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextPositioning {
        #[inline]
        fn clone(&self) -> ContextPositioning {
            match (&*self,) {
                (&ContextPositioning::Format1(ref __self_0),) =>
                ContextPositioning::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&ContextPositioning::Format2(ref __self_0),) =>
                ContextPositioning::Format2(::std::clone::Clone::clone(&(*__self_0))),
                (&ContextPositioning::Format3(ref __self_0),) =>
                ContextPositioning::Format3(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextPositioning {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ContextPositioning::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ContextPositioning::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ContextPositioning::Format3(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format3");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "A table for positioning glyphs in a context in format 1."]
    pub struct ContextPositioning1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Rules>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextPositioning1 {
        #[inline]
        fn clone(&self) -> ContextPositioning1 {
            match *self {
                ContextPositioning1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                ContextPositioning1{format:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    coverage_offset:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    set_count:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    set_offsets:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    coverage:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),
                                    sets:
                                        ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextPositioning1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextPositioning1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextPositioning1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextPositioning1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextPositioning1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning1,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Rules>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for positioning glyphs in a context in format 2."]
    pub struct ContextPositioning2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub class_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Option<ClassRules>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextPositioning2 {
        #[inline]
        fn clone(&self) -> ContextPositioning2 {
            match *self {
                ContextPositioning2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                class_offset: ref __self_0_2,
                set_count: ref __self_0_3,
                set_offsets: ref __self_0_4,
                coverage: ref __self_0_5,
                sets: ref __self_0_6 } =>
                ContextPositioning2{format:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    coverage_offset:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    class_offset:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    set_count:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    set_offsets:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),
                                    coverage:
                                        ::std::clone::Clone::clone(&(*__self_0_5)),
                                    sets:
                                        ::std::clone::Clone::clone(&(*__self_0_6)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextPositioning2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextPositioning2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                class_offset: ref __self_0_2,
                set_count: ref __self_0_3,
                set_offsets: ref __self_0_4,
                coverage: ref __self_0_5,
                sets: ref __self_0_6 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextPositioning2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("class_offset", &&(*__self_0_2));
                    let _ = builder.field("set_count", &&(*__self_0_3));
                    let _ = builder.field("set_offsets", &&(*__self_0_4));
                    let _ = builder.field("coverage", &&(*__self_0_5));
                    let _ = builder.field("sets", &&(*__self_0_6));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextPositioning2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextPositioning2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning2,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Option<ClassRules>>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       if this.set_offsets[i] > 0 {
                                           match tape.jump(position +
                                                               (this.set_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(Some(match tape.take()
                                                                {
                                                                ::std::result::Result::Ok(val)
                                                                => val,
                                                                ::std::result::Result::Err(err)
                                                                => {
                                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                                }
                                                            }));
                                       } else { values.push(None); }
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for positioning glyphs in a context in format 3."]
    pub struct ContextPositioning3 {
        pub format: u16,
        pub glyph_count: u16,
        pub operation_count: u16,
        pub coverage_offsets: Vec<u16>,
        pub operations: Vec<Positioning>,
        pub coverages: Vec<Coverage>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextPositioning3 {
        #[inline]
        fn clone(&self) -> ContextPositioning3 {
            match *self {
                ContextPositioning3 {
                format: ref __self_0_0,
                glyph_count: ref __self_0_1,
                operation_count: ref __self_0_2,
                coverage_offsets: ref __self_0_3,
                operations: ref __self_0_4,
                coverages: ref __self_0_5 } =>
                ContextPositioning3{format:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    glyph_count:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    operation_count:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    coverage_offsets:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    operations:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),
                                    coverages:
                                        ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextPositioning3 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextPositioning3 {
                format: ref __self_0_0,
                glyph_count: ref __self_0_1,
                operation_count: ref __self_0_2,
                coverage_offsets: ref __self_0_3,
                operations: ref __self_0_4,
                coverages: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextPositioning3");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("glyph_count", &&(*__self_0_1));
                    let _ = builder.field("operation_count", &&(*__self_0_2));
                    let _ =
                        builder.field("coverage_offsets", &&(*__self_0_3));
                    let _ = builder.field("operations", &&(*__self_0_4));
                    let _ = builder.field("coverages", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextPositioning3 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextPositioning3 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<Positioning>> {
                            tape.take_given(this.operation_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextPositioning3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.glyph_count as
                                                              usize);
                                   for i in 0..(this.glyph_count as usize) {
                                       match tape.jump(position +
                                                           (this.coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverages,
                                                       value));
            }
            Ok(table)
        }
    }
    /// A table for positioning glyphs in a chaining context.
    pub enum ChainContextPositioning {

        /// Format 1.
        Format1(ChainContextPositioning1),

        /// Format 2.
        Format2(ChainContextPositioning2),

        /// Format 3.
        Format3(ChainContextPositioning3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextPositioning {
        #[inline]
        fn clone(&self) -> ChainContextPositioning {
            match (&*self,) {
                (&ChainContextPositioning::Format1(ref __self_0),) =>
                ChainContextPositioning::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&ChainContextPositioning::Format2(ref __self_0),) =>
                ChainContextPositioning::Format2(::std::clone::Clone::clone(&(*__self_0))),
                (&ChainContextPositioning::Format3(ref __self_0),) =>
                ChainContextPositioning::Format3(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextPositioning {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ChainContextPositioning::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ChainContextPositioning::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ChainContextPositioning::Format3(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format3");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc =
          "A table for positioning glyphs in a chaining context in format 1."]
    pub struct ChainContextPositioning1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<ChainRules>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextPositioning1 {
        #[inline]
        fn clone(&self) -> ChainContextPositioning1 {
            match *self {
                ChainContextPositioning1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                ChainContextPositioning1{format:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         coverage_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),
                                         set_count:
                                             ::std::clone::Clone::clone(&(*__self_0_2)),
                                         set_offsets:
                                             ::std::clone::Clone::clone(&(*__self_0_3)),
                                         coverage:
                                             ::std::clone::Clone::clone(&(*__self_0_4)),
                                         sets:
                                             ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextPositioning1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextPositioning1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextPositioning1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextPositioning1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextPositioning1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning1,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<ChainRules>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc =
          "A table for positioning glyphs in a chaining context in format 2."]
    pub struct ChainContextPositioning2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub backward_class_offset: u16,
        pub input_class_offset: u16,
        pub forward_class_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub backward_class: Class,
        pub input_class: Class,
        pub forward_class: Class,
        pub sets: Vec<Option<ChainClassRules>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextPositioning2 {
        #[inline]
        fn clone(&self) -> ChainContextPositioning2 {
            match *self {
                ChainContextPositioning2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_class_offset: ref __self_0_2,
                input_class_offset: ref __self_0_3,
                forward_class_offset: ref __self_0_4,
                set_count: ref __self_0_5,
                set_offsets: ref __self_0_6,
                coverage: ref __self_0_7,
                backward_class: ref __self_0_8,
                input_class: ref __self_0_9,
                forward_class: ref __self_0_10,
                sets: ref __self_0_11 } =>
                ChainContextPositioning2{format:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         coverage_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),
                                         backward_class_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_2)),
                                         input_class_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_3)),
                                         forward_class_offset:
                                             ::std::clone::Clone::clone(&(*__self_0_4)),
                                         set_count:
                                             ::std::clone::Clone::clone(&(*__self_0_5)),
                                         set_offsets:
                                             ::std::clone::Clone::clone(&(*__self_0_6)),
                                         coverage:
                                             ::std::clone::Clone::clone(&(*__self_0_7)),
                                         backward_class:
                                             ::std::clone::Clone::clone(&(*__self_0_8)),
                                         input_class:
                                             ::std::clone::Clone::clone(&(*__self_0_9)),
                                         forward_class:
                                             ::std::clone::Clone::clone(&(*__self_0_10)),
                                         sets:
                                             ::std::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextPositioning2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextPositioning2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_class_offset: ref __self_0_2,
                input_class_offset: ref __self_0_3,
                forward_class_offset: ref __self_0_4,
                set_count: ref __self_0_5,
                set_offsets: ref __self_0_6,
                coverage: ref __self_0_7,
                backward_class: ref __self_0_8,
                input_class: ref __self_0_9,
                forward_class: ref __self_0_10,
                sets: ref __self_0_11 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextPositioning2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ =
                        builder.field("backward_class_offset",
                                      &&(*__self_0_2));
                    let _ =
                        builder.field("input_class_offset", &&(*__self_0_3));
                    let _ =
                        builder.field("forward_class_offset",
                                      &&(*__self_0_4));
                    let _ = builder.field("set_count", &&(*__self_0_5));
                    let _ = builder.field("set_offsets", &&(*__self_0_6));
                    let _ = builder.field("coverage", &&(*__self_0_7));
                    let _ = builder.field("backward_class", &&(*__self_0_8));
                    let _ = builder.field("input_class", &&(*__self_0_9));
                    let _ = builder.field("forward_class", &&(*__self_0_10));
                    let _ = builder.field("sets", &&(*__self_0_11));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextPositioning2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextPositioning2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.backward_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.input_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.forward_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Option<ChainClassRules>>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       if this.set_offsets[i] > 0 {
                                           match tape.jump(position +
                                                               (this.set_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(Some(match tape.take()
                                                                {
                                                                ::std::result::Result::Ok(val)
                                                                => val,
                                                                ::std::result::Result::Err(err)
                                                                => {
                                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                                }
                                                            }));
                                       } else { values.push(None); }
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc =
          "A table for positioning glyphs in a chaining context in format 3."]
    pub struct ChainContextPositioning3 {
        pub format: u16,
        pub backward_glyph_count: u16,
        pub backward_coverage_offsets: Vec<u16>,
        pub input_glyph_count: u16,
        pub input_coverage_offsets: Vec<u16>,
        pub forward_glyph_count: u16,
        pub forward_coverage_offsets: Vec<u16>,
        pub operation_count: u16,
        pub operations: Vec<Positioning>,
        pub backward_coverages: Vec<Coverage>,
        pub input_coverages: Vec<Coverage>,
        pub forward_coverages: Vec<Coverage>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextPositioning3 {
        #[inline]
        fn clone(&self) -> ChainContextPositioning3 {
            match *self {
                ChainContextPositioning3 {
                format: ref __self_0_0,
                backward_glyph_count: ref __self_0_1,
                backward_coverage_offsets: ref __self_0_2,
                input_glyph_count: ref __self_0_3,
                input_coverage_offsets: ref __self_0_4,
                forward_glyph_count: ref __self_0_5,
                forward_coverage_offsets: ref __self_0_6,
                operation_count: ref __self_0_7,
                operations: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                input_coverages: ref __self_0_10,
                forward_coverages: ref __self_0_11 } =>
                ChainContextPositioning3{format:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         backward_glyph_count:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),
                                         backward_coverage_offsets:
                                             ::std::clone::Clone::clone(&(*__self_0_2)),
                                         input_glyph_count:
                                             ::std::clone::Clone::clone(&(*__self_0_3)),
                                         input_coverage_offsets:
                                             ::std::clone::Clone::clone(&(*__self_0_4)),
                                         forward_glyph_count:
                                             ::std::clone::Clone::clone(&(*__self_0_5)),
                                         forward_coverage_offsets:
                                             ::std::clone::Clone::clone(&(*__self_0_6)),
                                         operation_count:
                                             ::std::clone::Clone::clone(&(*__self_0_7)),
                                         operations:
                                             ::std::clone::Clone::clone(&(*__self_0_8)),
                                         backward_coverages:
                                             ::std::clone::Clone::clone(&(*__self_0_9)),
                                         input_coverages:
                                             ::std::clone::Clone::clone(&(*__self_0_10)),
                                         forward_coverages:
                                             ::std::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextPositioning3 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextPositioning3 {
                format: ref __self_0_0,
                backward_glyph_count: ref __self_0_1,
                backward_coverage_offsets: ref __self_0_2,
                input_glyph_count: ref __self_0_3,
                input_coverage_offsets: ref __self_0_4,
                forward_glyph_count: ref __self_0_5,
                forward_coverage_offsets: ref __self_0_6,
                operation_count: ref __self_0_7,
                operations: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                input_coverages: ref __self_0_10,
                forward_coverages: ref __self_0_11 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextPositioning3");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ =
                        builder.field("backward_glyph_count",
                                      &&(*__self_0_1));
                    let _ =
                        builder.field("backward_coverage_offsets",
                                      &&(*__self_0_2));
                    let _ =
                        builder.field("input_glyph_count", &&(*__self_0_3));
                    let _ =
                        builder.field("input_coverage_offsets",
                                      &&(*__self_0_4));
                    let _ =
                        builder.field("forward_glyph_count", &&(*__self_0_5));
                    let _ =
                        builder.field("forward_coverage_offsets",
                                      &&(*__self_0_6));
                    let _ = builder.field("operation_count", &&(*__self_0_7));
                    let _ = builder.field("operations", &&(*__self_0_8));
                    let _ =
                        builder.field("backward_coverages", &&(*__self_0_9));
                    let _ =
                        builder.field("input_coverages", &&(*__self_0_10));
                    let _ =
                        builder.field("forward_coverages", &&(*__self_0_11));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextPositioning3 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextPositioning3 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.backward_glyph_count as
                                                usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.input_glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.forward_glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<Positioning>> {
                            tape.take_given(this.operation_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.backward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.backward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.backward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.input_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.input_glyph_count as usize) {
                                       match tape.jump(position +
                                                           (this.input_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_coverages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextPositioning3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.forward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.forward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.forward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverages,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for other types of positioning."]
    pub struct ExtensionPositioning {
        pub format: u16,
        pub kind: u16,
        pub offset: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ExtensionPositioning {
        #[inline]
        fn clone(&self) -> ExtensionPositioning {
            match *self {
                ExtensionPositioning {
                format: ref __self_0_0,
                kind: ref __self_0_1,
                offset: ref __self_0_2 } =>
                ExtensionPositioning{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     kind:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     offset:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ExtensionPositioning {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ExtensionPositioning {
                format: ref __self_0_0,
                kind: ref __self_0_1,
                offset: ref __self_0_2 } => {
                    let mut builder =
                        __arg_0.debug_struct("ExtensionPositioning");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("kind", &&(*__self_0_1));
                    let _ = builder.field("offset", &&(*__self_0_2));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ExtensionPositioning {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let mut table: ExtensionPositioning =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.kind,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.offset,
                                                       value));
            }
            Ok(table)
        }
    }
    impl Walue<'static> for Table {
        type
        Parameter
        =
        u16;
        fn read<T: Tape>(tape: &mut T, kind: u16) -> Result<Self> {
            Ok(match kind {
                   1 =>
                   Table::SingleAdjustment(match tape.take() {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           }),
                   2 =>
                   Table::PairAdjustment(match tape.take() {
                                             ::std::result::Result::Ok(val) =>
                                             val,
                                             ::std::result::Result::Err(err)
                                             => {
                                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                                             }
                                         }),
                   3 =>
                   Table::CursiveAttachment(match tape.take() {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            }),
                   4 =>
                   Table::MarkToBaseAttachment(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   5 =>
                   Table::MarkToLigatureAttachment(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   }),
                   6 =>
                   Table::MarkToMarkAttachment(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   7 =>
                   Table::ContextPositioning(match tape.take() {
                                                 ::std::result::Result::Ok(val)
                                                 => val,
                                                 ::std::result::Result::Err(err)
                                                 => {
                                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                                 }
                                             }),
                   8 =>
                   Table::ChainContextPositioning(match tape.take() {
                                                      ::std::result::Result::Ok(val)
                                                      => val,
                                                      ::std::result::Result::Err(err)
                                                      => {
                                                          return ::std::result::Result::Err(::std::convert::From::from(err))
                                                      }
                                                  }),
                   9 =>
                   Table::ExtensionPositioning(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown glyph-positioning type")),
               })
        }
    }
    impl Value for SingleAdjustment {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   SingleAdjustment::Format1(match tape.take() {
                                                 ::std::result::Result::Ok(val)
                                                 => val,
                                                 ::std::result::Result::Err(err)
                                                 => {
                                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                                 }
                                             }),
                   2 =>
                   SingleAdjustment::Format2(match tape.take() {
                                                 ::std::result::Result::Ok(val)
                                                 => val,
                                                 ::std::result::Result::Err(err)
                                                 => {
                                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                                 }
                                             }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the single-adjustment table")),
               })
        }
    }
    impl Value for PairAdjustment {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   PairAdjustment::Format1(match tape.take() {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           }),
                   2 =>
                   PairAdjustment::Format2(match tape.take() {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the pair-adjustment table")),
               })
        }
    }
    impl Value for ContextPositioning {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   ContextPositioning::Format1(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   2 =>
                   ContextPositioning::Format2(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   3 =>
                   ContextPositioning::Format3(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the context-positioning table")),
               })
        }
    }
    impl Value for ChainContextPositioning {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   ChainContextPositioning::Format1(match tape.take() {
                                                        ::std::result::Result::Ok(val)
                                                        => val,
                                                        ::std::result::Result::Err(err)
                                                        => {
                                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                                        }
                                                    }),
                   2 =>
                   ChainContextPositioning::Format2(match tape.take() {
                                                        ::std::result::Result::Ok(val)
                                                        => val,
                                                        ::std::result::Result::Err(err)
                                                        => {
                                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                                        }
                                                    }),
                   3 =>
                   ChainContextPositioning::Format3(match tape.take() {
                                                        ::std::result::Result::Ok(val)
                                                        => val,
                                                        ::std::result::Result::Err(err)
                                                        => {
                                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                                        }
                                                    }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the chaining-context-positioning table")),
               })
        }
    }
}
pub mod glyph_substitution {
    //! The [glyph-substitution table][1].
    //!
    //! [1]: https://www.microsoft.com/typography/otspec/GSUB.htm
    use truetype::{GlyphID, Result, Tape, Value, Walue};
    use layout::{Class, Coverage, Directory};
    mod element {
        use truetype::GlyphID;
        #[doc = "A set of alternate substitutions."]
        pub struct Alternates {
            pub count: u16,
            pub glyph_ids: Vec<GlyphID>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Alternates {
            #[inline]
            fn clone(&self) -> Alternates {
                match *self {
                    Alternates {
                    count: ref __self_0_0, glyph_ids: ref __self_0_1 } =>
                    Alternates{count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               glyph_ids:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Alternates {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Alternates {
                    count: ref __self_0_0, glyph_ids: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Alternates");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("glyph_ids", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Alternates {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Alternates = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Alternates,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.glyph_ids,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A chaining class substitution rule."]
        pub struct ChainClassRule {
            pub backward_glyph_count: u16,
            pub backward_class_ids: Vec<u16>,
            pub input_glyph_count: u16,
            pub input_class_ids: Vec<u16>,
            pub forward_glyph_count: u16,
            pub forward_class_ids: Vec<u16>,
            pub operation_count: u16,
            pub operations: Vec<Substitution>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainClassRule {
            #[inline]
            fn clone(&self) -> ChainClassRule {
                match *self {
                    ChainClassRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_class_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_class_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_class_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } =>
                    ChainClassRule{backward_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_0)),
                                   backward_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_1)),
                                   input_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_2)),
                                   input_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_3)),
                                   forward_glyph_count:
                                       ::std::clone::Clone::clone(&(*__self_0_4)),
                                   forward_class_ids:
                                       ::std::clone::Clone::clone(&(*__self_0_5)),
                                   operation_count:
                                       ::std::clone::Clone::clone(&(*__self_0_6)),
                                   operations:
                                       ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainClassRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainClassRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_class_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_class_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_class_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } => {
                        let mut builder =
                            __arg_0.debug_struct("ChainClassRule");
                        let _ =
                            builder.field("backward_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("backward_class_ids",
                                          &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_2));
                        let _ =
                            builder.field("input_class_ids", &&(*__self_0_3));
                        let _ =
                            builder.field("forward_glyph_count",
                                          &&(*__self_0_4));
                        let _ =
                            builder.field("forward_class_ids",
                                          &&(*__self_0_5));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_6));
                        let _ = builder.field("operations", &&(*__self_0_7));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainClassRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ChainClassRule =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.backward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed chaining class substitution rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.forward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_class_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Substitution>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of chaining class substitution rules."]
        pub struct ChainClassRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ChainClassRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainClassRules {
            #[inline]
            fn clone(&self) -> ChainClassRules {
                match *self {
                    ChainClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ChainClassRules{count:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    offsets:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    records:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainClassRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder =
                            __arg_0.debug_struct("ChainClassRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainClassRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ChainClassRules =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &ChainClassRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ChainClassRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A chaining substitution rule."]
        pub struct ChainRule {
            pub backward_glyph_count: u16,
            pub backward_glyph_ids: Vec<GlyphID>,
            pub input_glyph_count: u16,
            pub input_glyph_ids: Vec<GlyphID>,
            pub forward_glyph_count: u16,
            pub forward_glyph_ids: Vec<GlyphID>,
            pub operation_count: u16,
            pub operations: Vec<Substitution>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainRule {
            #[inline]
            fn clone(&self) -> ChainRule {
                match *self {
                    ChainRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_glyph_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_glyph_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_glyph_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } =>
                    ChainRule{backward_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              backward_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              input_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              input_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),
                              forward_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_4)),
                              forward_glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_5)),
                              operation_count:
                                  ::std::clone::Clone::clone(&(*__self_0_6)),
                              operations:
                                  ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainRule {
                    backward_glyph_count: ref __self_0_0,
                    backward_glyph_ids: ref __self_0_1,
                    input_glyph_count: ref __self_0_2,
                    input_glyph_ids: ref __self_0_3,
                    forward_glyph_count: ref __self_0_4,
                    forward_glyph_ids: ref __self_0_5,
                    operation_count: ref __self_0_6,
                    operations: ref __self_0_7 } => {
                        let mut builder = __arg_0.debug_struct("ChainRule");
                        let _ =
                            builder.field("backward_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("backward_glyph_ids",
                                          &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_2));
                        let _ =
                            builder.field("input_glyph_ids", &&(*__self_0_3));
                        let _ =
                            builder.field("forward_glyph_count",
                                          &&(*__self_0_4));
                        let _ =
                            builder.field("forward_glyph_ids",
                                          &&(*__self_0_5));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_6));
                        let _ = builder.field("operations", &&(*__self_0_7));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ChainRule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.backward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed chaining substitution rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.forward_glyph_count as
                                                    usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Substitution>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of chaining substitution rules."]
        pub struct ChainRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ChainRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ChainRules {
            #[inline]
            fn clone(&self) -> ChainRules {
                match *self {
                    ChainRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ChainRules{count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               offsets:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),
                               records:
                                   ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ChainRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ChainRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("ChainRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ChainRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ChainRules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ChainRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ChainRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A class substitution rule."]
        pub struct ClassRule {
            pub input_glyph_count: u16,
            pub operation_count: u16,
            pub input_class_ids: Vec<u16>,
            pub operations: Vec<Substitution>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ClassRule {
            #[inline]
            fn clone(&self) -> ClassRule {
                match *self {
                    ClassRule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_class_ids: ref __self_0_2,
                    operations: ref __self_0_3 } =>
                    ClassRule{input_glyph_count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              operation_count:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              input_class_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              operations:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ClassRule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ClassRule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_class_ids: ref __self_0_2,
                    operations: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("ClassRule");
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_1));
                        let _ =
                            builder.field("input_class_ids", &&(*__self_0_2));
                        let _ = builder.field("operations", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ClassRule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ClassRule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed class substitution rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_class_ids,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Substitution>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of class substitution rules."]
        pub struct ClassRules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<ClassRule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ClassRules {
            #[inline]
            fn clone(&self) -> ClassRules {
                match *self {
                    ClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    ClassRules{count:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               offsets:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),
                               records:
                                   ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ClassRules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ClassRules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("ClassRules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for ClassRules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: ClassRules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &ClassRules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<ClassRule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A ligature substitution."]
        pub struct Ligature {
            pub glyph_id: GlyphID,
            pub component_count: u16,
            pub component_ids: Vec<GlyphID>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligature {
            #[inline]
            fn clone(&self) -> Ligature {
                match *self {
                    Ligature {
                    glyph_id: ref __self_0_0,
                    component_count: ref __self_0_1,
                    component_ids: ref __self_0_2 } =>
                    Ligature{glyph_id:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             component_count:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             component_ids:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligature {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligature {
                    glyph_id: ref __self_0_0,
                    component_count: ref __self_0_1,
                    component_ids: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Ligature");
                        let _ = builder.field("glyph_id", &&(*__self_0_0));
                        let _ =
                            builder.field("component_count", &&(*__self_0_1));
                        let _ =
                            builder.field("component_ids", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Ligature {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Ligature = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.glyph_id,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.component_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligature,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                if this.component_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed ligature substitution"));
                                }
                                tape.take_given((this.component_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.component_ids,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of ligature substitutions."]
        pub struct Ligatures {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<Ligature>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Ligatures {
            #[inline]
            fn clone(&self) -> Ligatures {
                match *self {
                    Ligatures {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Ligatures{count:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              offsets:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              records:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Ligatures {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Ligatures {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Ligatures");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Ligatures {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Ligatures = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligatures,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Ligatures,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Ligature>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A substitution rule."]
        pub struct Rule {
            pub input_glyph_count: u16,
            pub operation_count: u16,
            pub input_glyph_ids: Vec<GlyphID>,
            pub operations: Vec<Substitution>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Rule {
            #[inline]
            fn clone(&self) -> Rule {
                match *self {
                    Rule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_glyph_ids: ref __self_0_2,
                    operations: ref __self_0_3 } =>
                    Rule{input_glyph_count:
                             ::std::clone::Clone::clone(&(*__self_0_0)),
                         operation_count:
                             ::std::clone::Clone::clone(&(*__self_0_1)),
                         input_glyph_ids:
                             ::std::clone::Clone::clone(&(*__self_0_2)),
                         operations:
                             ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Rule {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Rule {
                    input_glyph_count: ref __self_0_0,
                    operation_count: ref __self_0_1,
                    input_glyph_ids: ref __self_0_2,
                    operations: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Rule");
                        let _ =
                            builder.field("input_glyph_count",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("operation_count", &&(*__self_0_1));
                        let _ =
                            builder.field("input_glyph_ids", &&(*__self_0_2));
                        let _ = builder.field("operations", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Rule {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Rule = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                if this.input_glyph_count == 0 {
                                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                      "found a malformed substitution rule"));
                                }
                                tape.take_given((this.input_glyph_count as
                                                     usize) - 1)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_ids,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rule,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<Substitution>> {
                                tape.take_given(this.operation_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A set of substitution rules."]
        pub struct Rules {
            pub count: u16,
            pub offsets: Vec<u16>,
            pub records: Vec<Rule>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Rules {
            #[inline]
            fn clone(&self) -> Rules {
                match *self {
                    Rules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Rules{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                          offsets: ::std::clone::Clone::clone(&(*__self_0_1)),
                          records:
                              ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Rules {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Rules {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Rules");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Rules {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Rules = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rules,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offsets,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Rules,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Rule>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A substitution sequence of glyphs."]
        pub struct Sequence {
            pub count: u16,
            pub glyph_ids: Vec<GlyphID>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Sequence {
            #[inline]
            fn clone(&self) -> Sequence {
                match *self {
                    Sequence {
                    count: ref __self_0_0, glyph_ids: ref __self_0_1 } =>
                    Sequence{count:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             glyph_ids:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Sequence {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Sequence {
                    count: ref __self_0_0, glyph_ids: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("Sequence");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("glyph_ids", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Sequence {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Sequence = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Sequence,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.glyph_ids,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A substitution operation."]
        pub struct Substitution {
            pub sequence_index: u16,
            pub lookup_index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Substitution {
            #[inline]
            fn clone(&self) -> Substitution {
                match *self {
                    Substitution {
                    sequence_index: ref __self_0_0,
                    lookup_index: ref __self_0_1 } =>
                    Substitution{sequence_index:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),
                                 lookup_index:
                                     ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Substitution {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Substitution {
                    sequence_index: ref __self_0_0,
                    lookup_index: ref __self_0_1 } => {
                        let mut builder =
                            __arg_0.debug_struct("Substitution");
                        let _ =
                            builder.field("sequence_index", &&(*__self_0_0));
                        let _ =
                            builder.field("lookup_index", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Substitution { }
        impl ::truetype::Value for Substitution {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Substitution = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.sequence_index,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_index,
                                                           value));
                }
                Ok(table)
            }
        }
    }
    pub use self::element::*;
    /// A glyph-substitution table.
    pub type GlyphSubstitution = Directory<Table>;
    /// An inner table of a glyph-substitution table.
    pub enum Table {
        SingleSubstitution(SingleSubstitution),
        MultipleSubstitution(MultipleSubstitution),
        AlternateSubstitution(AlternateSubstitution),
        LigatureSubstitution(LigatureSubstitution),
        ContextSubstitution(ContextSubstitution),
        ChainContextSubstitution(ChainContextSubstitution),
        ExtensionSubstitution(ExtensionSubstitution),
        ReverseChainContextSubstitution(ReverseChainContextSubstitution),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Table {
        #[inline]
        fn clone(&self) -> Table {
            match (&*self,) {
                (&Table::SingleSubstitution(ref __self_0),) =>
                Table::SingleSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::MultipleSubstitution(ref __self_0),) =>
                Table::MultipleSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::AlternateSubstitution(ref __self_0),) =>
                Table::AlternateSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::LigatureSubstitution(ref __self_0),) =>
                Table::LigatureSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ContextSubstitution(ref __self_0),) =>
                Table::ContextSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ChainContextSubstitution(ref __self_0),) =>
                Table::ChainContextSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ExtensionSubstitution(ref __self_0),) =>
                Table::ExtensionSubstitution(::std::clone::Clone::clone(&(*__self_0))),
                (&Table::ReverseChainContextSubstitution(ref __self_0),) =>
                Table::ReverseChainContextSubstitution(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Table {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Table::SingleSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("SingleSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::MultipleSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("MultipleSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::AlternateSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("AlternateSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::LigatureSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("LigatureSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ContextSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ContextSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ChainContextSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ChainContextSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ExtensionSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ExtensionSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Table::ReverseChainContextSubstitution(ref __self_0),) => {
                    let mut builder =
                        __arg_0.debug_tuple("ReverseChainContextSubstitution");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    /// A table for substituting one glyph with one glyph.
    pub enum SingleSubstitution {

        /// Format 1.
        Format1(SingleSubstitution1),

        /// Format 2.
        Format2(SingleSubstitution2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleSubstitution {
        #[inline]
        fn clone(&self) -> SingleSubstitution {
            match (&*self,) {
                (&SingleSubstitution::Format1(ref __self_0),) =>
                SingleSubstitution::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&SingleSubstitution::Format2(ref __self_0),) =>
                SingleSubstitution::Format2(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&SingleSubstitution::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&SingleSubstitution::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "A table for substituting one glyph with one glyph in format 1."]
    pub struct SingleSubstitution1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub delta_glyph_id: i16,
        pub coverage: Coverage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleSubstitution1 {
        #[inline]
        fn clone(&self) -> SingleSubstitution1 {
            match *self {
                SingleSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                delta_glyph_id: ref __self_0_2,
                coverage: ref __self_0_3 } =>
                SingleSubstitution1{format:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    coverage_offset:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    delta_glyph_id:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    coverage:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleSubstitution1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                SingleSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                delta_glyph_id: ref __self_0_2,
                coverage: ref __self_0_3 } => {
                    let mut builder =
                        __arg_0.debug_struct("SingleSubstitution1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("delta_glyph_id", &&(*__self_0_2));
                    let _ = builder.field("coverage", &&(*__self_0_3));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for SingleSubstitution1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: SingleSubstitution1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.delta_glyph_id,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &SingleSubstitution1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting one glyph with one glyph in format 2."]
    pub struct SingleSubstitution2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub glyph_count: u16,
        pub glyph_ids: Vec<GlyphID>,
        pub coverage: Coverage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SingleSubstitution2 {
        #[inline]
        fn clone(&self) -> SingleSubstitution2 {
            match *self {
                SingleSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                glyph_count: ref __self_0_2,
                glyph_ids: ref __self_0_3,
                coverage: ref __self_0_4 } =>
                SingleSubstitution2{format:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    coverage_offset:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    glyph_count:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    glyph_ids:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    coverage:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SingleSubstitution2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                SingleSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                glyph_count: ref __self_0_2,
                glyph_ids: ref __self_0_3,
                coverage: ref __self_0_4 } => {
                    let mut builder =
                        __arg_0.debug_struct("SingleSubstitution2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("glyph_count", &&(*__self_0_2));
                    let _ = builder.field("glyph_ids", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for SingleSubstitution2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: SingleSubstitution2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &SingleSubstitution2,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<GlyphID>> {
                            tape.take_given(this.glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_ids,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &SingleSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting one glyph with more than one glyph."]
    pub struct MultipleSubstitution {
        pub format: u16,
        pub coverage_offset: u16,
        pub sequence_count: u16,
        pub sequence_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sequences: Vec<Sequence>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MultipleSubstitution {
        #[inline]
        fn clone(&self) -> MultipleSubstitution {
            match *self {
                MultipleSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                sequence_count: ref __self_0_2,
                sequence_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sequences: ref __self_0_5 } =>
                MultipleSubstitution{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     sequence_count:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     sequence_offsets:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     sequences:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MultipleSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                MultipleSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                sequence_count: ref __self_0_2,
                sequence_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sequences: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("MultipleSubstitution");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("sequence_count", &&(*__self_0_2));
                    let _ =
                        builder.field("sequence_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sequences", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for MultipleSubstitution {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: MultipleSubstitution =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sequence_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MultipleSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.sequence_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sequence_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MultipleSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &MultipleSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Sequence>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.sequence_count
                                                              as usize);
                                   for i in 0..(this.sequence_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.sequence_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sequences,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting one glyph with one of many glyphs."]
    pub struct AlternateSubstitution {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Alternates>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for AlternateSubstitution {
        #[inline]
        fn clone(&self) -> AlternateSubstitution {
            match *self {
                AlternateSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                AlternateSubstitution{format:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      coverage_offset:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      set_count:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),
                                      set_offsets:
                                          ::std::clone::Clone::clone(&(*__self_0_3)),
                                      coverage:
                                          ::std::clone::Clone::clone(&(*__self_0_4)),
                                      sets:
                                          ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for AlternateSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                AlternateSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("AlternateSubstitution");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for AlternateSubstitution {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: AlternateSubstitution =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &AlternateSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &AlternateSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &AlternateSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Alternates>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting multiple glyphs with one glyph."]
    pub struct LigatureSubstitution {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Ligatures>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LigatureSubstitution {
        #[inline]
        fn clone(&self) -> LigatureSubstitution {
            match *self {
                LigatureSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                LigatureSubstitution{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     set_count:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     set_offsets:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     sets:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LigatureSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                LigatureSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("LigatureSubstitution");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for LigatureSubstitution {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: LigatureSubstitution =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &LigatureSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &LigatureSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &LigatureSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Ligatures>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    /// A table for substituting glyphs in a context.
    pub enum ContextSubstitution {

        /// Format 1.
        Format1(ContextSubstitution1),

        /// Format 2.
        Format2(ContextSubstitution2),

        /// Format 3.
        Format3(ContextSubstitution3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextSubstitution {
        #[inline]
        fn clone(&self) -> ContextSubstitution {
            match (&*self,) {
                (&ContextSubstitution::Format1(ref __self_0),) =>
                ContextSubstitution::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&ContextSubstitution::Format2(ref __self_0),) =>
                ContextSubstitution::Format2(::std::clone::Clone::clone(&(*__self_0))),
                (&ContextSubstitution::Format3(ref __self_0),) =>
                ContextSubstitution::Format3(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ContextSubstitution::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ContextSubstitution::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ContextSubstitution::Format3(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format3");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc = "A table for substituting glyphs in a context in format 1."]
    pub struct ContextSubstitution1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Rules>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextSubstitution1 {
        #[inline]
        fn clone(&self) -> ContextSubstitution1 {
            match *self {
                ContextSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                ContextSubstitution1{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     set_count:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     set_offsets:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     sets:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextSubstitution1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextSubstitution1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextSubstitution1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextSubstitution1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution1,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Rules>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting glyphs in a context in format 2."]
    pub struct ContextSubstitution2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub class_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<Option<ClassRules>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextSubstitution2 {
        #[inline]
        fn clone(&self) -> ContextSubstitution2 {
            match *self {
                ContextSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                class_offset: ref __self_0_2,
                set_count: ref __self_0_3,
                set_offsets: ref __self_0_4,
                coverage: ref __self_0_5,
                sets: ref __self_0_6 } =>
                ContextSubstitution2{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     coverage_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     class_offset:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     set_count:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     set_offsets:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     coverage:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),
                                     sets:
                                         ::std::clone::Clone::clone(&(*__self_0_6)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextSubstitution2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                class_offset: ref __self_0_2,
                set_count: ref __self_0_3,
                set_offsets: ref __self_0_4,
                coverage: ref __self_0_5,
                sets: ref __self_0_6 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextSubstitution2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("class_offset", &&(*__self_0_2));
                    let _ = builder.field("set_count", &&(*__self_0_3));
                    let _ = builder.field("set_offsets", &&(*__self_0_4));
                    let _ = builder.field("coverage", &&(*__self_0_5));
                    let _ = builder.field("sets", &&(*__self_0_6));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextSubstitution2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextSubstitution2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution2,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Option<ClassRules>>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       if this.set_offsets[i] > 0 {
                                           match tape.jump(position +
                                                               (this.set_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(Some(match tape.take()
                                                                {
                                                                ::std::result::Result::Ok(val)
                                                                => val,
                                                                ::std::result::Result::Err(err)
                                                                => {
                                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                                }
                                                            }));
                                       } else { values.push(None); }
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for substituting glyphs in a context in format 3."]
    pub struct ContextSubstitution3 {
        pub format: u16,
        pub glyph_count: u16,
        pub operation_count: u16,
        pub coverage_offsets: Vec<u16>,
        pub operations: Vec<Substitution>,
        pub coverages: Vec<Coverage>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ContextSubstitution3 {
        #[inline]
        fn clone(&self) -> ContextSubstitution3 {
            match *self {
                ContextSubstitution3 {
                format: ref __self_0_0,
                glyph_count: ref __self_0_1,
                operation_count: ref __self_0_2,
                coverage_offsets: ref __self_0_3,
                operations: ref __self_0_4,
                coverages: ref __self_0_5 } =>
                ContextSubstitution3{format:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     glyph_count:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     operation_count:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),
                                     coverage_offsets:
                                         ::std::clone::Clone::clone(&(*__self_0_3)),
                                     operations:
                                         ::std::clone::Clone::clone(&(*__self_0_4)),
                                     coverages:
                                         ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ContextSubstitution3 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ContextSubstitution3 {
                format: ref __self_0_0,
                glyph_count: ref __self_0_1,
                operation_count: ref __self_0_2,
                coverage_offsets: ref __self_0_3,
                operations: ref __self_0_4,
                coverages: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ContextSubstitution3");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("glyph_count", &&(*__self_0_1));
                    let _ = builder.field("operation_count", &&(*__self_0_2));
                    let _ =
                        builder.field("coverage_offsets", &&(*__self_0_3));
                    let _ = builder.field("operations", &&(*__self_0_4));
                    let _ = builder.field("coverages", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ContextSubstitution3 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ContextSubstitution3 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_count,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<Substitution>> {
                            tape.take_given(this.operation_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ContextSubstitution3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.glyph_count as
                                                              usize);
                                   for i in 0..(this.glyph_count as usize) {
                                       match tape.jump(position +
                                                           (this.coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverages,
                                                       value));
            }
            Ok(table)
        }
    }
    /// A table for substituting glyphs in a chaining context.
    pub enum ChainContextSubstitution {

        /// Format 1.
        Format1(ChainContextSubstitution1),

        /// Format 2.
        Format2(ChainContextSubstitution2),

        /// Format 3.
        Format3(ChainContextSubstitution3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextSubstitution {
        #[inline]
        fn clone(&self) -> ChainContextSubstitution {
            match (&*self,) {
                (&ChainContextSubstitution::Format1(ref __self_0),) =>
                ChainContextSubstitution::Format1(::std::clone::Clone::clone(&(*__self_0))),
                (&ChainContextSubstitution::Format2(ref __self_0),) =>
                ChainContextSubstitution::Format2(::std::clone::Clone::clone(&(*__self_0))),
                (&ChainContextSubstitution::Format3(ref __self_0),) =>
                ChainContextSubstitution::Format3(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ChainContextSubstitution::Format1(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format1");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ChainContextSubstitution::Format2(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format2");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ChainContextSubstitution::Format3(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Format3");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    #[doc =
          "A table for substituting glyphs in a chaining context in format 1."]
    pub struct ChainContextSubstitution1 {
        pub format: u16,
        pub coverage_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub sets: Vec<ChainRules>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextSubstitution1 {
        #[inline]
        fn clone(&self) -> ChainContextSubstitution1 {
            match *self {
                ChainContextSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } =>
                ChainContextSubstitution1{format:
                                              ::std::clone::Clone::clone(&(*__self_0_0)),
                                          coverage_offset:
                                              ::std::clone::Clone::clone(&(*__self_0_1)),
                                          set_count:
                                              ::std::clone::Clone::clone(&(*__self_0_2)),
                                          set_offsets:
                                              ::std::clone::Clone::clone(&(*__self_0_3)),
                                          coverage:
                                              ::std::clone::Clone::clone(&(*__self_0_4)),
                                          sets:
                                              ::std::clone::Clone::clone(&(*__self_0_5)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextSubstitution1 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextSubstitution1 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                set_count: ref __self_0_2,
                set_offsets: ref __self_0_3,
                coverage: ref __self_0_4,
                sets: ref __self_0_5 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextSubstitution1");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ = builder.field("set_count", &&(*__self_0_2));
                    let _ = builder.field("set_offsets", &&(*__self_0_3));
                    let _ = builder.field("coverage", &&(*__self_0_4));
                    let _ = builder.field("sets", &&(*__self_0_5));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextSubstitution1 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextSubstitution1 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution1,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution1,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<ChainRules>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       match tape.jump(position +
                                                           (this.set_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc =
          "A table for substituting glyphs in a chaining context in format 2."]
    pub struct ChainContextSubstitution2 {
        pub format: u16,
        pub coverage_offset: u16,
        pub backward_class_offset: u16,
        pub input_class_offset: u16,
        pub forward_class_offset: u16,
        pub set_count: u16,
        pub set_offsets: Vec<u16>,
        pub coverage: Coverage,
        pub backward_class: Class,
        pub input_class: Class,
        pub forward_class: Class,
        pub sets: Vec<Option<ChainClassRules>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextSubstitution2 {
        #[inline]
        fn clone(&self) -> ChainContextSubstitution2 {
            match *self {
                ChainContextSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_class_offset: ref __self_0_2,
                input_class_offset: ref __self_0_3,
                forward_class_offset: ref __self_0_4,
                set_count: ref __self_0_5,
                set_offsets: ref __self_0_6,
                coverage: ref __self_0_7,
                backward_class: ref __self_0_8,
                input_class: ref __self_0_9,
                forward_class: ref __self_0_10,
                sets: ref __self_0_11 } =>
                ChainContextSubstitution2{format:
                                              ::std::clone::Clone::clone(&(*__self_0_0)),
                                          coverage_offset:
                                              ::std::clone::Clone::clone(&(*__self_0_1)),
                                          backward_class_offset:
                                              ::std::clone::Clone::clone(&(*__self_0_2)),
                                          input_class_offset:
                                              ::std::clone::Clone::clone(&(*__self_0_3)),
                                          forward_class_offset:
                                              ::std::clone::Clone::clone(&(*__self_0_4)),
                                          set_count:
                                              ::std::clone::Clone::clone(&(*__self_0_5)),
                                          set_offsets:
                                              ::std::clone::Clone::clone(&(*__self_0_6)),
                                          coverage:
                                              ::std::clone::Clone::clone(&(*__self_0_7)),
                                          backward_class:
                                              ::std::clone::Clone::clone(&(*__self_0_8)),
                                          input_class:
                                              ::std::clone::Clone::clone(&(*__self_0_9)),
                                          forward_class:
                                              ::std::clone::Clone::clone(&(*__self_0_10)),
                                          sets:
                                              ::std::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextSubstitution2 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextSubstitution2 {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_class_offset: ref __self_0_2,
                input_class_offset: ref __self_0_3,
                forward_class_offset: ref __self_0_4,
                set_count: ref __self_0_5,
                set_offsets: ref __self_0_6,
                coverage: ref __self_0_7,
                backward_class: ref __self_0_8,
                input_class: ref __self_0_9,
                forward_class: ref __self_0_10,
                sets: ref __self_0_11 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextSubstitution2");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ =
                        builder.field("backward_class_offset",
                                      &&(*__self_0_2));
                    let _ =
                        builder.field("input_class_offset", &&(*__self_0_3));
                    let _ =
                        builder.field("forward_class_offset",
                                      &&(*__self_0_4));
                    let _ = builder.field("set_count", &&(*__self_0_5));
                    let _ = builder.field("set_offsets", &&(*__self_0_6));
                    let _ = builder.field("coverage", &&(*__self_0_7));
                    let _ = builder.field("backward_class", &&(*__self_0_8));
                    let _ = builder.field("input_class", &&(*__self_0_9));
                    let _ = builder.field("forward_class", &&(*__self_0_10));
                    let _ = builder.field("sets", &&(*__self_0_11));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextSubstitution2 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextSubstitution2 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_class_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.set_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.set_offsets,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.backward_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.input_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Class> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.forward_class_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_class,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution2,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Option<ChainClassRules>>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.set_count as
                                                              usize);
                                   for i in 0..(this.set_count as usize) {
                                       if this.set_offsets[i] > 0 {
                                           match tape.jump(position +
                                                               (this.set_offsets[i]
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(Some(match tape.take()
                                                                {
                                                                ::std::result::Result::Ok(val)
                                                                => val,
                                                                ::std::result::Result::Err(err)
                                                                => {
                                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                                }
                                                            }));
                                       } else { values.push(None); }
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.sets,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc =
          "A table for substituting glyphs in a chaining context in format 3."]
    pub struct ChainContextSubstitution3 {
        pub format: u16,
        pub backward_glyph_count: u16,
        pub backward_coverage_offsets: Vec<u16>,
        pub input_glyph_count: u16,
        pub input_coverage_offsets: Vec<u16>,
        pub forward_glyph_count: u16,
        pub forward_coverage_offsets: Vec<u16>,
        pub operation_count: u16,
        pub operations: Vec<Substitution>,
        pub backward_coverages: Vec<Coverage>,
        pub input_coverages: Vec<Coverage>,
        pub forward_coverages: Vec<Coverage>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ChainContextSubstitution3 {
        #[inline]
        fn clone(&self) -> ChainContextSubstitution3 {
            match *self {
                ChainContextSubstitution3 {
                format: ref __self_0_0,
                backward_glyph_count: ref __self_0_1,
                backward_coverage_offsets: ref __self_0_2,
                input_glyph_count: ref __self_0_3,
                input_coverage_offsets: ref __self_0_4,
                forward_glyph_count: ref __self_0_5,
                forward_coverage_offsets: ref __self_0_6,
                operation_count: ref __self_0_7,
                operations: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                input_coverages: ref __self_0_10,
                forward_coverages: ref __self_0_11 } =>
                ChainContextSubstitution3{format:
                                              ::std::clone::Clone::clone(&(*__self_0_0)),
                                          backward_glyph_count:
                                              ::std::clone::Clone::clone(&(*__self_0_1)),
                                          backward_coverage_offsets:
                                              ::std::clone::Clone::clone(&(*__self_0_2)),
                                          input_glyph_count:
                                              ::std::clone::Clone::clone(&(*__self_0_3)),
                                          input_coverage_offsets:
                                              ::std::clone::Clone::clone(&(*__self_0_4)),
                                          forward_glyph_count:
                                              ::std::clone::Clone::clone(&(*__self_0_5)),
                                          forward_coverage_offsets:
                                              ::std::clone::Clone::clone(&(*__self_0_6)),
                                          operation_count:
                                              ::std::clone::Clone::clone(&(*__self_0_7)),
                                          operations:
                                              ::std::clone::Clone::clone(&(*__self_0_8)),
                                          backward_coverages:
                                              ::std::clone::Clone::clone(&(*__self_0_9)),
                                          input_coverages:
                                              ::std::clone::Clone::clone(&(*__self_0_10)),
                                          forward_coverages:
                                              ::std::clone::Clone::clone(&(*__self_0_11)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ChainContextSubstitution3 {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ChainContextSubstitution3 {
                format: ref __self_0_0,
                backward_glyph_count: ref __self_0_1,
                backward_coverage_offsets: ref __self_0_2,
                input_glyph_count: ref __self_0_3,
                input_coverage_offsets: ref __self_0_4,
                forward_glyph_count: ref __self_0_5,
                forward_coverage_offsets: ref __self_0_6,
                operation_count: ref __self_0_7,
                operations: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                input_coverages: ref __self_0_10,
                forward_coverages: ref __self_0_11 } => {
                    let mut builder =
                        __arg_0.debug_struct("ChainContextSubstitution3");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ =
                        builder.field("backward_glyph_count",
                                      &&(*__self_0_1));
                    let _ =
                        builder.field("backward_coverage_offsets",
                                      &&(*__self_0_2));
                    let _ =
                        builder.field("input_glyph_count", &&(*__self_0_3));
                    let _ =
                        builder.field("input_coverage_offsets",
                                      &&(*__self_0_4));
                    let _ =
                        builder.field("forward_glyph_count", &&(*__self_0_5));
                    let _ =
                        builder.field("forward_coverage_offsets",
                                      &&(*__self_0_6));
                    let _ = builder.field("operation_count", &&(*__self_0_7));
                    let _ = builder.field("operations", &&(*__self_0_8));
                    let _ =
                        builder.field("backward_coverages", &&(*__self_0_9));
                    let _ =
                        builder.field("input_coverages", &&(*__self_0_10));
                    let _ =
                        builder.field("forward_coverages", &&(*__self_0_11));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ChainContextSubstitution3 {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ChainContextSubstitution3 =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.backward_glyph_count as
                                                usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.input_glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.forward_glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operation_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<Substitution>> {
                            tape.take_given(this.operation_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.operations,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.backward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.backward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.backward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.input_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.input_glyph_count as usize) {
                                       match tape.jump(position +
                                                           (this.input_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.input_coverages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ChainContextSubstitution3,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.forward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.forward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.forward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverages,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc = "A table for other types of substitution."]
    pub struct ExtensionSubstitution {
        pub format: u16,
        pub kind: u16,
        pub offset: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ExtensionSubstitution {
        #[inline]
        fn clone(&self) -> ExtensionSubstitution {
            match *self {
                ExtensionSubstitution {
                format: ref __self_0_0,
                kind: ref __self_0_1,
                offset: ref __self_0_2 } =>
                ExtensionSubstitution{format:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      kind:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      offset:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ExtensionSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ExtensionSubstitution {
                format: ref __self_0_0,
                kind: ref __self_0_1,
                offset: ref __self_0_2 } => {
                    let mut builder =
                        __arg_0.debug_struct("ExtensionSubstitution");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("kind", &&(*__self_0_1));
                    let _ = builder.field("offset", &&(*__self_0_2));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ExtensionSubstitution {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let mut table: ExtensionSubstitution =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    {
                        let value =
                            match tape.take() {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                        if value != { 1 } {
                            return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                              "found a malformed or unsupported table"));
                        }
                        value
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.kind,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.offset,
                                                       value));
            }
            Ok(table)
        }
    }
    #[doc =
          "A table for substituting glyphs in reverse order in a chaining context."]
    pub struct ReverseChainContextSubstitution {
        pub format: u16,
        pub coverage_offset: u16,
        pub backward_glyph_count: u16,
        pub backward_coverage_offsets: Vec<u16>,
        pub forward_glyph_count: u16,
        pub forward_coverage_offsets: Vec<u16>,
        pub glyph_count: u16,
        pub glyph_ids: Vec<GlyphID>,
        pub coverage: Coverage,
        pub backward_coverages: Vec<Coverage>,
        pub forward_coverages: Vec<Coverage>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ReverseChainContextSubstitution {
        #[inline]
        fn clone(&self) -> ReverseChainContextSubstitution {
            match *self {
                ReverseChainContextSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_glyph_count: ref __self_0_2,
                backward_coverage_offsets: ref __self_0_3,
                forward_glyph_count: ref __self_0_4,
                forward_coverage_offsets: ref __self_0_5,
                glyph_count: ref __self_0_6,
                glyph_ids: ref __self_0_7,
                coverage: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                forward_coverages: ref __self_0_10 } =>
                ReverseChainContextSubstitution{format:
                                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                                coverage_offset:
                                                    ::std::clone::Clone::clone(&(*__self_0_1)),
                                                backward_glyph_count:
                                                    ::std::clone::Clone::clone(&(*__self_0_2)),
                                                backward_coverage_offsets:
                                                    ::std::clone::Clone::clone(&(*__self_0_3)),
                                                forward_glyph_count:
                                                    ::std::clone::Clone::clone(&(*__self_0_4)),
                                                forward_coverage_offsets:
                                                    ::std::clone::Clone::clone(&(*__self_0_5)),
                                                glyph_count:
                                                    ::std::clone::Clone::clone(&(*__self_0_6)),
                                                glyph_ids:
                                                    ::std::clone::Clone::clone(&(*__self_0_7)),
                                                coverage:
                                                    ::std::clone::Clone::clone(&(*__self_0_8)),
                                                backward_coverages:
                                                    ::std::clone::Clone::clone(&(*__self_0_9)),
                                                forward_coverages:
                                                    ::std::clone::Clone::clone(&(*__self_0_10)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ReverseChainContextSubstitution {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                ReverseChainContextSubstitution {
                format: ref __self_0_0,
                coverage_offset: ref __self_0_1,
                backward_glyph_count: ref __self_0_2,
                backward_coverage_offsets: ref __self_0_3,
                forward_glyph_count: ref __self_0_4,
                forward_coverage_offsets: ref __self_0_5,
                glyph_count: ref __self_0_6,
                glyph_ids: ref __self_0_7,
                coverage: ref __self_0_8,
                backward_coverages: ref __self_0_9,
                forward_coverages: ref __self_0_10 } => {
                    let mut builder =
                        __arg_0.debug_struct("ReverseChainContextSubstitution");
                    let _ = builder.field("format", &&(*__self_0_0));
                    let _ = builder.field("coverage_offset", &&(*__self_0_1));
                    let _ =
                        builder.field("backward_glyph_count",
                                      &&(*__self_0_2));
                    let _ =
                        builder.field("backward_coverage_offsets",
                                      &&(*__self_0_3));
                    let _ =
                        builder.field("forward_glyph_count", &&(*__self_0_4));
                    let _ =
                        builder.field("forward_coverage_offsets",
                                      &&(*__self_0_5));
                    let _ = builder.field("glyph_count", &&(*__self_0_6));
                    let _ = builder.field("glyph_ids", &&(*__self_0_7));
                    let _ = builder.field("coverage", &&(*__self_0_8));
                    let _ =
                        builder.field("backward_coverages", &&(*__self_0_9));
                    let _ =
                        builder.field("forward_coverages", &&(*__self_0_10));
                    builder.finish()
                }
            }
        }
    }
    impl ::truetype::Value for ReverseChainContextSubstitution {
        fn read<T: ::truetype::Tape>(tape: &mut T)
         -> ::truetype::Result<Self> {
            let position =
                match tape.position() {
                    ::std::result::Result::Ok(val) => val,
                    ::std::result::Result::Err(err) => {
                        return ::std::result::Result::Err(::std::convert::From::from(err))
                    }
                };
            let mut table: ReverseChainContextSubstitution =
                unsafe { ::std::mem::zeroed() };
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage_offset,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.backward_glyph_count as
                                                usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<u16>> {
                            tape.take_given(this.forward_glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverage_offsets,
                                                       value));
            }
            {
                let value =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_count,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T, _: u64)
                         -> ::truetype::Result<Vec<GlyphID>> {
                            tape.take_given(this.glyph_count as usize)
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.glyph_ids,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Coverage> {
                            Ok({
                                   match tape.jump(position +
                                                       (this.coverage_offset
                                                            as u64)) {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   };
                                   match tape.take() {
                                       ::std::result::Result::Ok(val) => val,
                                       ::std::result::Result::Err(err) => {
                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                       }
                                   }
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.coverage,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.backward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.backward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.backward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.backward_coverages,
                                                       value));
            }
            {
                let value =
                    {
                        #[inline(always)]
                        fn read<T: ::truetype::Tape>(this:
                                                         &ReverseChainContextSubstitution,
                                                     tape: &mut T,
                                                     position: u64)
                         -> ::truetype::Result<Vec<Coverage>> {
                            Ok({
                                   let mut values =
                                       Vec::with_capacity(this.forward_glyph_count
                                                              as usize);
                                   for i in
                                       0..(this.forward_glyph_count as usize)
                                       {
                                       match tape.jump(position +
                                                           (this.forward_coverage_offsets[i]
                                                                as u64)) {
                                           ::std::result::Result::Ok(val) =>
                                           val,
                                           ::std::result::Result::Err(err) =>
                                           {
                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                           }
                                       };
                                       values.push(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   });
                                   }
                                   values
                               })
                        }
                        match read(&table, tape, position) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                ::std::mem::forget(::std::mem::replace(&mut table.forward_coverages,
                                                       value));
            }
            Ok(table)
        }
    }
    impl Walue<'static> for Table {
        type
        Parameter
        =
        u16;
        fn read<T: Tape>(tape: &mut T, kind: u16) -> Result<Self> {
            Ok(match kind {
                   1 =>
                   Table::SingleSubstitution(match tape.take() {
                                                 ::std::result::Result::Ok(val)
                                                 => val,
                                                 ::std::result::Result::Err(err)
                                                 => {
                                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                                 }
                                             }),
                   2 =>
                   Table::MultipleSubstitution(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   3 =>
                   Table::AlternateSubstitution(match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }),
                   4 =>
                   Table::LigatureSubstitution(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   5 =>
                   Table::ContextSubstitution(match tape.take() {
                                                  ::std::result::Result::Ok(val)
                                                  => val,
                                                  ::std::result::Result::Err(err)
                                                  => {
                                                      return ::std::result::Result::Err(::std::convert::From::from(err))
                                                  }
                                              }),
                   6 =>
                   Table::ChainContextSubstitution(match tape.take() {
                                                       ::std::result::Result::Ok(val)
                                                       => val,
                                                       ::std::result::Result::Err(err)
                                                       => {
                                                           return ::std::result::Result::Err(::std::convert::From::from(err))
                                                       }
                                                   }),
                   7 =>
                   Table::ExtensionSubstitution(match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }),
                   8 =>
                   Table::ReverseChainContextSubstitution(match tape.take() {
                                                              ::std::result::Result::Ok(val)
                                                              => val,
                                                              ::std::result::Result::Err(err)
                                                              => {
                                                                  return ::std::result::Result::Err(::std::convert::From::from(err))
                                                              }
                                                          }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown glyph-substitution type")),
               })
        }
    }
    impl Value for SingleSubstitution {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   SingleSubstitution::Format1(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   2 =>
                   SingleSubstitution::Format2(match tape.take() {
                                                   ::std::result::Result::Ok(val)
                                                   => val,
                                                   ::std::result::Result::Err(err)
                                                   => {
                                                       return ::std::result::Result::Err(::std::convert::From::from(err))
                                                   }
                                               }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the single-substitution table")),
               })
        }
    }
    impl Value for ContextSubstitution {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   ContextSubstitution::Format1(match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }),
                   2 =>
                   ContextSubstitution::Format2(match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }),
                   3 =>
                   ContextSubstitution::Format3(match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the context-substitution table")),
               })
        }
    }
    impl Value for ChainContextSubstitution {
        fn read<T: Tape>(tape: &mut T) -> Result<Self> {
            Ok(match match tape.peek::<u16>() {
                         ::std::result::Result::Ok(val) => val,
                         ::std::result::Result::Err(err) => {
                             return ::std::result::Result::Err(::std::convert::From::from(err))
                         }
                     } {
                   1 =>
                   ChainContextSubstitution::Format1(match tape.take() {
                                                         ::std::result::Result::Ok(val)
                                                         => val,
                                                         ::std::result::Result::Err(err)
                                                         => {
                                                             return ::std::result::Result::Err(::std::convert::From::from(err))
                                                         }
                                                     }),
                   2 =>
                   ChainContextSubstitution::Format2(match tape.take() {
                                                         ::std::result::Result::Ok(val)
                                                         => val,
                                                         ::std::result::Result::Err(err)
                                                         => {
                                                             return ::std::result::Result::Err(::std::convert::From::from(err))
                                                         }
                                                     }),
                   3 =>
                   ChainContextSubstitution::Format3(match tape.take() {
                                                         ::std::result::Result::Ok(val)
                                                         => val,
                                                         ::std::result::Result::Err(err)
                                                         => {
                                                             return ::std::result::Result::Err(::std::convert::From::from(err))
                                                         }
                                                     }),
                   _ =>
                   return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                     "found an unknown format of the chaining-context-substitution table")),
               })
        }
    }
}
pub mod layout {
    //! The [common layout tables][1].
    //!
    //! [1]: https://www.microsoft.com/typography/otspec/chapter2.htm
    mod class {
        use truetype::{GlyphID, Result, Tape, Value};
        /// A class definition.
        pub enum Class {

            /// Format 1.
            Format1(Class1),

            /// Format 2.
            Format2(Class2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Class {
            #[inline]
            fn clone(&self) -> Class {
                match (&*self,) {
                    (&Class::Format1(ref __self_0),) =>
                    Class::Format1(::std::clone::Clone::clone(&(*__self_0))),
                    (&Class::Format2(ref __self_0),) =>
                    Class::Format2(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Class {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Class::Format1(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format1");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Class::Format2(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format2");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A class definition in format 1."]
        pub struct Class1 {
            pub format: u16,
            pub start: GlyphID,
            pub value_count: u16,
            pub values: Vec<u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Class1 {
            #[inline]
            fn clone(&self) -> Class1 {
                match *self {
                    Class1 {
                    format: ref __self_0_0,
                    start: ref __self_0_1,
                    value_count: ref __self_0_2,
                    values: ref __self_0_3 } =>
                    Class1{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                           start: ::std::clone::Clone::clone(&(*__self_0_1)),
                           value_count:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           values:
                               ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Class1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Class1 {
                    format: ref __self_0_0,
                    start: ref __self_0_1,
                    value_count: ref __self_0_2,
                    values: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Class1");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("start", &&(*__self_0_1));
                        let _ = builder.field("value_count", &&(*__self_0_2));
                        let _ = builder.field("values", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Class1 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Class1 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.start,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.value_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Class1,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.value_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.values,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A class definition in format 2."]
        pub struct Class2 {
            pub format: u16,
            pub range_count: u16,
            pub ranges: Vec<ClassRange>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Class2 {
            #[inline]
            fn clone(&self) -> Class2 {
                match *self {
                    Class2 {
                    format: ref __self_0_0,
                    range_count: ref __self_0_1,
                    ranges: ref __self_0_2 } =>
                    Class2{format: ::std::clone::Clone::clone(&(*__self_0_0)),
                           range_count:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           ranges:
                               ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Class2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Class2 {
                    format: ref __self_0_0,
                    range_count: ref __self_0_1,
                    ranges: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Class2");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("range_count", &&(*__self_0_1));
                        let _ = builder.field("ranges", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Class2 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Class2 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.range_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Class2,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<ClassRange>> {
                                tape.take_given(this.range_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.ranges,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A class range."]
        pub struct ClassRange {
            pub start: GlyphID,
            pub end: GlyphID,
            pub index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ClassRange {
            #[inline]
            fn clone(&self) -> ClassRange {
                match *self {
                    ClassRange {
                    start: ref __self_0_0,
                    end: ref __self_0_1,
                    index: ref __self_0_2 } =>
                    ClassRange{start:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               end:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),
                               index:
                                   ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ClassRange {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ClassRange {
                    start: ref __self_0_0,
                    end: ref __self_0_1,
                    index: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("ClassRange");
                        let _ = builder.field("start", &&(*__self_0_0));
                        let _ = builder.field("end", &&(*__self_0_1));
                        let _ = builder.field("index", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for ClassRange { }
        impl ::truetype::Value for ClassRange {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: ClassRange = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.start,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.end,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.index,
                                                           value));
                }
                Ok(table)
            }
        }
        impl Value for Class {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                Ok(match match tape.peek::<u16>() {
                             ::std::result::Result::Ok(val) => val,
                             ::std::result::Result::Err(err) => {
                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                             }
                         } {
                       1 =>
                       Class::Format1(match tape.take() {
                                          ::std::result::Result::Ok(val) =>
                                          val,
                                          ::std::result::Result::Err(err) => {
                                              return ::std::result::Result::Err(::std::convert::From::from(err))
                                          }
                                      }),
                       2 =>
                       Class::Format2(match tape.take() {
                                          ::std::result::Result::Ok(val) =>
                                          val,
                                          ::std::result::Result::Err(err) => {
                                              return ::std::result::Result::Err(::std::convert::From::from(err))
                                          }
                                      }),
                       _ =>
                       return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                         "found an unknown format of the class definition")),
                   })
            }
        }
    }
    mod coverage {
        use truetype::{GlyphID, Result, Tape, Value};
        /// A coverage table.
        pub enum Coverage {

            /// Format 1.
            Format1(Coverage1),

            /// Format 2.
            Format2(Coverage2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Coverage {
            #[inline]
            fn clone(&self) -> Coverage {
                match (&*self,) {
                    (&Coverage::Format1(ref __self_0),) =>
                    Coverage::Format1(::std::clone::Clone::clone(&(*__self_0))),
                    (&Coverage::Format2(ref __self_0),) =>
                    Coverage::Format2(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Coverage {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Coverage::Format1(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format1");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                    (&Coverage::Format2(ref __self_0),) => {
                        let mut builder = __arg_0.debug_tuple("Format2");
                        let _ = builder.field(&&(*__self_0));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "A coverage table in format 1."]
        pub struct Coverage1 {
            pub format: u16,
            pub count: u16,
            pub glyph_ids: Vec<GlyphID>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Coverage1 {
            #[inline]
            fn clone(&self) -> Coverage1 {
                match *self {
                    Coverage1 {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    glyph_ids: ref __self_0_2 } =>
                    Coverage1{format:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              count:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              glyph_ids:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Coverage1 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Coverage1 {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    glyph_ids: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Coverage1");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("count", &&(*__self_0_1));
                        let _ = builder.field("glyph_ids", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Coverage1 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Coverage1 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Coverage1,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<GlyphID>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.glyph_ids,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A coverage table in format 2."]
        pub struct Coverage2 {
            pub format: u16,
            pub count: u16,
            pub ranges: Vec<CoverageRange>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Coverage2 {
            #[inline]
            fn clone(&self) -> Coverage2 {
                match *self {
                    Coverage2 {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    ranges: ref __self_0_2 } =>
                    Coverage2{format:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              count:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              ranges:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Coverage2 {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Coverage2 {
                    format: ref __self_0_0,
                    count: ref __self_0_1,
                    ranges: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Coverage2");
                        let _ = builder.field("format", &&(*__self_0_0));
                        let _ = builder.field("count", &&(*__self_0_1));
                        let _ = builder.field("ranges", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Coverage2 {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Coverage2 = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.format,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Coverage2,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<CoverageRange>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.ranges,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A coverage range."]
        pub struct CoverageRange {
            pub start: GlyphID,
            pub end: GlyphID,
            pub index: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for CoverageRange {
            #[inline]
            fn clone(&self) -> CoverageRange {
                match *self {
                    CoverageRange {
                    start: ref __self_0_0,
                    end: ref __self_0_1,
                    index: ref __self_0_2 } =>
                    CoverageRange{start:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),
                                  end:
                                      ::std::clone::Clone::clone(&(*__self_0_1)),
                                  index:
                                      ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for CoverageRange {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    CoverageRange {
                    start: ref __self_0_0,
                    end: ref __self_0_1,
                    index: ref __self_0_2 } => {
                        let mut builder =
                            __arg_0.debug_struct("CoverageRange");
                        let _ = builder.field("start", &&(*__self_0_0));
                        let _ = builder.field("end", &&(*__self_0_1));
                        let _ = builder.field("index", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for CoverageRange { }
        impl ::truetype::Value for CoverageRange {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: CoverageRange =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.start,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.end,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.index,
                                                           value));
                }
                Ok(table)
            }
        }
        impl Value for Coverage {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                Ok(match match tape.peek::<u16>() {
                             ::std::result::Result::Ok(val) => val,
                             ::std::result::Result::Err(err) => {
                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                             }
                         } {
                       1 =>
                       Coverage::Format1(match tape.take() {
                                             ::std::result::Result::Ok(val) =>
                                             val,
                                             ::std::result::Result::Err(err)
                                             => {
                                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                                             }
                                         }),
                       2 =>
                       Coverage::Format2(match tape.take() {
                                             ::std::result::Result::Ok(val) =>
                                             val,
                                             ::std::result::Result::Err(err)
                                             => {
                                                 return ::std::result::Result::Err(::std::convert::From::from(err))
                                             }
                                         }),
                       _ =>
                       return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                         "found an unknown format of the coverage table")),
                   })
            }
        }
    }
    mod device {
        use truetype::{Result, Tape, Value};
        #[doc = "A device adjustment."]
        pub struct Device {
            pub start_size: u16,
            pub end_size: u16,
            pub delta_format: u16,
            pub delta_data: Vec<u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Device {
            #[inline]
            fn clone(&self) -> Device {
                match *self {
                    Device {
                    start_size: ref __self_0_0,
                    end_size: ref __self_0_1,
                    delta_format: ref __self_0_2,
                    delta_data: ref __self_0_3 } =>
                    Device{start_size:
                               ::std::clone::Clone::clone(&(*__self_0_0)),
                           end_size:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           delta_format:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           delta_data:
                               ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Device {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Device {
                    start_size: ref __self_0_0,
                    end_size: ref __self_0_1,
                    delta_format: ref __self_0_2,
                    delta_data: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Device");
                        let _ = builder.field("start_size", &&(*__self_0_0));
                        let _ = builder.field("end_size", &&(*__self_0_1));
                        let _ =
                            builder.field("delta_format", &&(*__self_0_2));
                        let _ = builder.field("delta_data", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl Value for Device {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                let start_size =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let end_size =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                if start_size > end_size {
                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                      "found a malformed device table"));
                }
                let delta_format =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                if delta_format == 0 || delta_format > 3 {
                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                      "found an unknown format of the device table"));
                }
                let count = ((end_size - start_size) as usize) + 1;
                let bit_count = (1 << (delta_format as usize)) * count;
                let short_count = (bit_count + 16 - bit_count % 16) >> 4;
                let delta_data =
                    match tape.take_given(short_count) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                Ok(Device{start_size: start_size,
                          end_size: end_size,
                          delta_format: delta_format,
                          delta_data: delta_data,})
            }
        }
    }
    mod directory {
        use truetype::{Result, Tape, Value, Walue, q32};
        use super::{Features, Lookups, Scripts};
        /// A directory of scripts, features, and lookups.
        pub struct Directory<T> {
            pub header: Header,
            pub scripts: Scripts,
            pub features: Features,
            pub lookups: Lookups<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::clone::Clone> ::std::clone::Clone for Directory<T> {
            #[inline]
            fn clone(&self) -> Directory<T> {
                match *self {
                    Directory {
                    header: ref __self_0_0,
                    scripts: ref __self_0_1,
                    features: ref __self_0_2,
                    lookups: ref __self_0_3 } =>
                    Directory{header:
                                  ::std::clone::Clone::clone(&(*__self_0_0)),
                              scripts:
                                  ::std::clone::Clone::clone(&(*__self_0_1)),
                              features:
                                  ::std::clone::Clone::clone(&(*__self_0_2)),
                              lookups:
                                  ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::fmt::Debug> ::std::fmt::Debug for Directory<T> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Directory {
                    header: ref __self_0_0,
                    scripts: ref __self_0_1,
                    features: ref __self_0_2,
                    lookups: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Directory");
                        let _ = builder.field("header", &&(*__self_0_0));
                        let _ = builder.field("scripts", &&(*__self_0_1));
                        let _ = builder.field("features", &&(*__self_0_2));
                        let _ = builder.field("lookups", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "The header of a directory table."]
        pub struct Header {
            pub version: q32,
            pub script_offset: u16,
            pub feature_offset: u16,
            pub lookup_offset: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Header {
            #[inline]
            fn clone(&self) -> Header {
                match *self {
                    Header {
                    version: ref __self_0_0,
                    script_offset: ref __self_0_1,
                    feature_offset: ref __self_0_2,
                    lookup_offset: ref __self_0_3 } =>
                    Header{version:
                               ::std::clone::Clone::clone(&(*__self_0_0)),
                           script_offset:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           feature_offset:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           lookup_offset:
                               ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Header {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Header {
                    version: ref __self_0_0,
                    script_offset: ref __self_0_1,
                    feature_offset: ref __self_0_2,
                    lookup_offset: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Header");
                        let _ = builder.field("version", &&(*__self_0_0));
                        let _ =
                            builder.field("script_offset", &&(*__self_0_1));
                        let _ =
                            builder.field("feature_offset", &&(*__self_0_2));
                        let _ =
                            builder.field("lookup_offset", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Header { }
        impl ::truetype::Value for Header {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Header = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        {
                            let value =
                                match tape.take() {
                                    ::std::result::Result::Ok(val) => val,
                                    ::std::result::Result::Err(err) => {
                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                    }
                                };
                            if value != { q32(65536) } {
                                return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                  "found a malformed or unsupported table"));
                            }
                            value
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.version,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.script_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.feature_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_offset,
                                                           value));
                }
                Ok(table)
            }
        }
        impl <U> Value for Directory<U> where U: Walue<'static, Parameter =
         u16> {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let header =
                    match tape.take::<Header>() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let scripts =
                    {
                        match tape.jump(position +
                                            (header.script_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                let features =
                    {
                        match tape.jump(position +
                                            (header.feature_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                let lookups =
                    {
                        match tape.jump(position +
                                            (header.lookup_offset as u64)) {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        }
                    };
                Ok(Directory{header: header,
                             scripts: scripts,
                             features: features,
                             lookups: lookups,})
            }
        }
    }
    pub mod feature {
        //! The feature list.
        use truetype::Tag;
        #[doc = "A feature list."]
        pub struct Features {
            pub count: u16,
            pub headers: Vec<Header>,
            pub records: Vec<Record>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Features {
            #[inline]
            fn clone(&self) -> Features {
                match *self {
                    Features {
                    count: ref __self_0_0,
                    headers: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Features{count:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             headers:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             records:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Features {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Features {
                    count: ref __self_0_0,
                    headers: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Features");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("headers", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Features {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Features = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Features,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<Header>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.headers,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Features,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Record>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.headers[i].offset
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A feature header."]
        pub struct Header {
            pub tag: Tag,
            pub offset: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Header {
            #[inline]
            fn clone(&self) -> Header {
                match *self {
                    Header { tag: ref __self_0_0, offset: ref __self_0_1 } =>
                    Header{tag: ::std::clone::Clone::clone(&(*__self_0_0)),
                           offset:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Header {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Header { tag: ref __self_0_0, offset: ref __self_0_1 } =>
                    {
                        let mut builder = __arg_0.debug_struct("Header");
                        let _ = builder.field("tag", &&(*__self_0_0));
                        let _ = builder.field("offset", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Header { }
        impl ::truetype::Value for Header {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Header = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.tag,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offset,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A feature record."]
        pub struct Record {
            pub parameter_offset: u16,
            pub lookup_count: u16,
            pub lookup_indices: Vec<u16>,
            pub parameters: Option<Vec<u8>>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Record {
            #[inline]
            fn clone(&self) -> Record {
                match *self {
                    Record {
                    parameter_offset: ref __self_0_0,
                    lookup_count: ref __self_0_1,
                    lookup_indices: ref __self_0_2,
                    parameters: ref __self_0_3 } =>
                    Record{parameter_offset:
                               ::std::clone::Clone::clone(&(*__self_0_0)),
                           lookup_count:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           lookup_indices:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           parameters:
                               ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Record {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Record {
                    parameter_offset: ref __self_0_0,
                    lookup_count: ref __self_0_1,
                    lookup_indices: ref __self_0_2,
                    parameters: ref __self_0_3 } => {
                        let mut builder = __arg_0.debug_struct("Record");
                        let _ =
                            builder.field("parameter_offset",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("lookup_count", &&(*__self_0_1));
                        let _ =
                            builder.field("lookup_indices", &&(*__self_0_2));
                        let _ = builder.field("parameters", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Record {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Record = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.parameter_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Record,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.lookup_count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_indices,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Record,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Option<Vec<u8>>> {
                                if this.parameter_offset != 0 {
                                    match tape.jump(position +
                                                        (this.parameter_offset
                                                             as u64)) {
                                        ::std::result::Result::Ok(val) => val,
                                        ::std::result::Result::Err(err) => {
                                            return ::std::result::Result::Err(::std::convert::From::from(err))
                                        }
                                    };
                                    Ok(Some(match tape.take_bytes(0) {
                                                ::std::result::Result::Ok(val)
                                                => val,
                                                ::std::result::Result::Err(err)
                                                => {
                                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                                }
                                            }))
                                } else { Ok(None) }
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.parameters,
                                                           value));
                }
                Ok(table)
            }
        }
    }
    pub mod lookup {
        //! The lookup list.
        use truetype::{Result, Tape, Value, Walue};
        /// A lookup list.
        pub struct Lookups<T> {
            pub count: (u16),
            pub offsets: (Vec<u16>),
            pub records: (Vec<Record<T>>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::clone::Clone> ::std::clone::Clone for Lookups<T> {
            #[inline]
            fn clone(&self) -> Lookups<T> {
                match *self {
                    Lookups {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Lookups{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                            offsets:
                                ::std::clone::Clone::clone(&(*__self_0_1)),
                            records:
                                ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::fmt::Debug> ::std::fmt::Debug for Lookups<T> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Lookups {
                    count: ref __self_0_0,
                    offsets: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Lookups");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("offsets", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        /// A lookup record.
        pub struct Record<T> {
            pub kind: (u16),
            pub flags: (Flags),
            pub table_count: (u16),
            pub table_offsets: (Vec<u16>),
            pub mark_filtering_set: (Option<u16>),
            pub tables: (Vec<T>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::clone::Clone> ::std::clone::Clone for Record<T> {
            #[inline]
            fn clone(&self) -> Record<T> {
                match *self {
                    Record {
                    kind: ref __self_0_0,
                    flags: ref __self_0_1,
                    table_count: ref __self_0_2,
                    table_offsets: ref __self_0_3,
                    mark_filtering_set: ref __self_0_4,
                    tables: ref __self_0_5 } =>
                    Record{kind: ::std::clone::Clone::clone(&(*__self_0_0)),
                           flags: ::std::clone::Clone::clone(&(*__self_0_1)),
                           table_count:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           table_offsets:
                               ::std::clone::Clone::clone(&(*__self_0_3)),
                           mark_filtering_set:
                               ::std::clone::Clone::clone(&(*__self_0_4)),
                           tables:
                               ::std::clone::Clone::clone(&(*__self_0_5)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <T: ::std::fmt::Debug> ::std::fmt::Debug for Record<T> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Record {
                    kind: ref __self_0_0,
                    flags: ref __self_0_1,
                    table_count: ref __self_0_2,
                    table_offsets: ref __self_0_3,
                    mark_filtering_set: ref __self_0_4,
                    tables: ref __self_0_5 } => {
                        let mut builder = __arg_0.debug_struct("Record");
                        let _ = builder.field("kind", &&(*__self_0_0));
                        let _ = builder.field("flags", &&(*__self_0_1));
                        let _ = builder.field("table_count", &&(*__self_0_2));
                        let _ =
                            builder.field("table_offsets", &&(*__self_0_3));
                        let _ =
                            builder.field("mark_filtering_set",
                                          &&(*__self_0_4));
                        let _ = builder.field("tables", &&(*__self_0_5));
                        builder.finish()
                    }
                }
            }
        }
        #[doc = "Lookup flags."]
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub struct Flags(pub u16);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Flags {
            #[inline]
            fn clone(&self) -> Flags {
                { let _: ::std::clone::AssertParamIsClone<u16>; *self }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Flags { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Flags {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Flags(ref __self_0_0) => {
                        let mut builder = __arg_0.debug_tuple("Flags");
                        let _ = builder.field(&&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Flags {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                { let _: ::std::cmp::AssertParamIsEq<u16>; }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Flags {
            #[inline]
            fn eq(&self, __arg_0: &Flags) -> bool {
                match *__arg_0 {
                    Flags(ref __self_1_0) =>
                    match *self {
                        Flags(ref __self_0_0) =>
                        true && (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, __arg_0: &Flags) -> bool {
                match *__arg_0 {
                    Flags(ref __self_1_0) =>
                    match *self {
                        Flags(ref __self_0_0) =>
                        false || (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl Flags {
            #[inline(always)]
            pub fn is_right_to_left(&self) -> bool { self.0 & 1 > 0 }
            #[inline(always)]
            pub fn should_ignore_base_glyphs(&self) -> bool { self.0 & 2 > 0 }
            #[inline(always)]
            pub fn should_ignore_ligature(&self) -> bool { self.0 & 4 > 0 }
            #[inline(always)]
            pub fn should_ignore_marks(&self) -> bool { self.0 & 8 > 0 }
            #[inline(always)]
            pub fn has_mark_filtering(&self) -> bool { self.0 & 16 > 0 }
            #[inline(always)]
            pub fn is_invalid(&self) -> bool { self.0 & 224 > 0 }
        }
        impl ::truetype::Value for Flags {
            #[inline(always)]
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let value =
                    Flags(match tape.take::<u16>() {
                              ::std::result::Result::Ok(val) => val,
                              ::std::result::Result::Err(err) => {
                                  return ::std::result::Result::Err(::std::convert::From::from(err))
                              }
                          });
                if value.is_invalid() {
                    return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                      "found malformed flags"));
                }
                Ok(value)
            }
        }
        impl From<Flags> for u16 {
            #[inline(always)]
            fn from(flags: Flags) -> u16 { flags.0 }
        }
        impl <U> Value for Lookups<U> where U: Walue<'static, Parameter = u16>
         {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let count =
                    match tape.take::<u16>() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let offsets: Vec<u16> =
                    match tape.take_given(count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let records =
                    {
                        let mut values = Vec::with_capacity(count as usize);
                        for i in 0..(count as usize) {
                            match tape.jump(position + (offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take() {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Lookups{count: count, offsets: offsets, records: records,})
            }
        }
        impl <U> Value for Record<U> where U: Walue<'static, Parameter = u16>
         {
            fn read<T: Tape>(tape: &mut T) -> Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let kind =
                    match tape.take() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let flags =
                    match tape.take::<Flags>() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let table_count =
                    match tape.take::<u16>() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let table_offsets: Vec<u16> =
                    match tape.take_given(table_count as usize) {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mark_filtering_set =
                    if flags.has_mark_filtering() {
                        Some(match tape.take() {
                                 ::std::result::Result::Ok(val) => val,
                                 ::std::result::Result::Err(err) => {
                                     return ::std::result::Result::Err(::std::convert::From::from(err))
                                 }
                             })
                    } else { None };
                let tables =
                    {
                        let mut values =
                            Vec::with_capacity(table_count as usize);
                        for i in 0..(table_count as usize) {
                            match tape.jump(position +
                                                (table_offsets[i] as u64)) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            };
                            values.push(match tape.take_given(kind) {
                                            ::std::result::Result::Ok(val) =>
                                            val,
                                            ::std::result::Result::Err(err) =>
                                            {
                                                return ::std::result::Result::Err(::std::convert::From::from(err))
                                            }
                                        });
                        }
                        values
                    };
                Ok(Record{kind: kind,
                          flags: flags,
                          table_count: table_count,
                          table_offsets: table_offsets,
                          mark_filtering_set: mark_filtering_set,
                          tables: tables,})
            }
        }
    }
    pub mod script {
        //! The script list.
        use truetype::Tag;
        #[doc = "A script list."]
        pub struct Scripts {
            pub count: u16,
            pub headers: Vec<Header>,
            pub records: Vec<Record>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Scripts {
            #[inline]
            fn clone(&self) -> Scripts {
                match *self {
                    Scripts {
                    count: ref __self_0_0,
                    headers: ref __self_0_1,
                    records: ref __self_0_2 } =>
                    Scripts{count: ::std::clone::Clone::clone(&(*__self_0_0)),
                            headers:
                                ::std::clone::Clone::clone(&(*__self_0_1)),
                            records:
                                ::std::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Scripts {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Scripts {
                    count: ref __self_0_0,
                    headers: ref __self_0_1,
                    records: ref __self_0_2 } => {
                        let mut builder = __arg_0.debug_struct("Scripts");
                        let _ = builder.field("count", &&(*__self_0_0));
                        let _ = builder.field("headers", &&(*__self_0_1));
                        let _ = builder.field("records", &&(*__self_0_2));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Scripts {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Scripts = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Scripts,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<Header>> {
                                tape.take_given(this.count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.headers,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Scripts,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<Record>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.count as
                                                                  usize);
                                       for i in 0..(this.count as usize) {
                                           match tape.jump(position +
                                                               (this.headers[i].offset
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A script header."]
        pub struct Header {
            pub tag: Tag,
            pub offset: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Header {
            #[inline]
            fn clone(&self) -> Header {
                match *self {
                    Header { tag: ref __self_0_0, offset: ref __self_0_1 } =>
                    Header{tag: ::std::clone::Clone::clone(&(*__self_0_0)),
                           offset:
                               ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Header {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Header { tag: ref __self_0_0, offset: ref __self_0_1 } =>
                    {
                        let mut builder = __arg_0.debug_struct("Header");
                        let _ = builder.field("tag", &&(*__self_0_0));
                        let _ = builder.field("offset", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Header { }
        impl ::truetype::Value for Header {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: Header = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.tag,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offset,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A script record."]
        pub struct Record {
            pub default_language_offset: u16,
            pub language_count: u16,
            pub language_headers: Vec<LanguageHeader>,
            pub default_language: Option<LanguageRecord>,
            pub language_records: Vec<LanguageRecord>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Record {
            #[inline]
            fn clone(&self) -> Record {
                match *self {
                    Record {
                    default_language_offset: ref __self_0_0,
                    language_count: ref __self_0_1,
                    language_headers: ref __self_0_2,
                    default_language: ref __self_0_3,
                    language_records: ref __self_0_4 } =>
                    Record{default_language_offset:
                               ::std::clone::Clone::clone(&(*__self_0_0)),
                           language_count:
                               ::std::clone::Clone::clone(&(*__self_0_1)),
                           language_headers:
                               ::std::clone::Clone::clone(&(*__self_0_2)),
                           default_language:
                               ::std::clone::Clone::clone(&(*__self_0_3)),
                           language_records:
                               ::std::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Record {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Record {
                    default_language_offset: ref __self_0_0,
                    language_count: ref __self_0_1,
                    language_headers: ref __self_0_2,
                    default_language: ref __self_0_3,
                    language_records: ref __self_0_4 } => {
                        let mut builder = __arg_0.debug_struct("Record");
                        let _ =
                            builder.field("default_language_offset",
                                          &&(*__self_0_0));
                        let _ =
                            builder.field("language_count", &&(*__self_0_1));
                        let _ =
                            builder.field("language_headers",
                                          &&(*__self_0_2));
                        let _ =
                            builder.field("default_language",
                                          &&(*__self_0_3));
                        let _ =
                            builder.field("language_records",
                                          &&(*__self_0_4));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for Record {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let position =
                    match tape.position() {
                        ::std::result::Result::Ok(val) => val,
                        ::std::result::Result::Err(err) => {
                            return ::std::result::Result::Err(::std::convert::From::from(err))
                        }
                    };
                let mut table: Record = unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.default_language_offset,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.language_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Record,
                                                         tape: &mut T, _: u64)
                             -> ::truetype::Result<Vec<LanguageHeader>> {
                                tape.take_given(this.language_count as usize)
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.language_headers,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Record,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Option<LanguageRecord>> {
                                if this.default_language_offset != 0 {
                                    Ok(Some({
                                                match tape.jump(position +
                                                                    (this.default_language_offset
                                                                         as
                                                                         u64))
                                                    {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                };
                                                match tape.take() {
                                                    ::std::result::Result::Ok(val)
                                                    => val,
                                                    ::std::result::Result::Err(err)
                                                    => {
                                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                                    }
                                                }
                                            }))
                                } else { Ok(None) }
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.default_language,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this: &Record,
                                                         tape: &mut T,
                                                         position: u64)
                             -> ::truetype::Result<Vec<LanguageRecord>> {
                                Ok({
                                       let mut values =
                                           Vec::with_capacity(this.language_count
                                                                  as usize);
                                       for i in
                                           0..(this.language_count as usize) {
                                           match tape.jump(position +
                                                               (this.language_headers[i].offset
                                                                    as u64)) {
                                               ::std::result::Result::Ok(val)
                                               => val,
                                               ::std::result::Result::Err(err)
                                               => {
                                                   return ::std::result::Result::Err(::std::convert::From::from(err))
                                               }
                                           };
                                           values.push(match tape.take() {
                                                           ::std::result::Result::Ok(val)
                                                           => val,
                                                           ::std::result::Result::Err(err)
                                                           => {
                                                               return ::std::result::Result::Err(::std::convert::From::from(err))
                                                           }
                                                       });
                                       }
                                       values
                                   })
                            }
                            match read(&table, tape, position) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.language_records,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A language-system header."]
        pub struct LanguageHeader {
            pub tag: Tag,
            pub offset: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for LanguageHeader {
            #[inline]
            fn clone(&self) -> LanguageHeader {
                match *self {
                    LanguageHeader {
                    tag: ref __self_0_0, offset: ref __self_0_1 } =>
                    LanguageHeader{tag:
                                       ::std::clone::Clone::clone(&(*__self_0_0)),
                                   offset:
                                       ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for LanguageHeader {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    LanguageHeader {
                    tag: ref __self_0_0, offset: ref __self_0_1 } => {
                        let mut builder =
                            __arg_0.debug_struct("LanguageHeader");
                        let _ = builder.field("tag", &&(*__self_0_0));
                        let _ = builder.field("offset", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for LanguageHeader {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: LanguageHeader =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.tag,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.offset,
                                                           value));
                }
                Ok(table)
            }
        }
        #[doc = "A language-system record."]
        pub struct LanguageRecord {
            pub lookup_order: u16,
            pub required_feature_index: u16,
            pub feature_count: u16,
            pub feature_indices: Vec<u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for LanguageRecord {
            #[inline]
            fn clone(&self) -> LanguageRecord {
                match *self {
                    LanguageRecord {
                    lookup_order: ref __self_0_0,
                    required_feature_index: ref __self_0_1,
                    feature_count: ref __self_0_2,
                    feature_indices: ref __self_0_3 } =>
                    LanguageRecord{lookup_order:
                                       ::std::clone::Clone::clone(&(*__self_0_0)),
                                   required_feature_index:
                                       ::std::clone::Clone::clone(&(*__self_0_1)),
                                   feature_count:
                                       ::std::clone::Clone::clone(&(*__self_0_2)),
                                   feature_indices:
                                       ::std::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for LanguageRecord {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    LanguageRecord {
                    lookup_order: ref __self_0_0,
                    required_feature_index: ref __self_0_1,
                    feature_count: ref __self_0_2,
                    feature_indices: ref __self_0_3 } => {
                        let mut builder =
                            __arg_0.debug_struct("LanguageRecord");
                        let _ =
                            builder.field("lookup_order", &&(*__self_0_0));
                        let _ =
                            builder.field("required_feature_index",
                                          &&(*__self_0_1));
                        let _ =
                            builder.field("feature_count", &&(*__self_0_2));
                        let _ =
                            builder.field("feature_indices", &&(*__self_0_3));
                        builder.finish()
                    }
                }
            }
        }
        impl ::truetype::Value for LanguageRecord {
            fn read<T: ::truetype::Tape>(tape: &mut T)
             -> ::truetype::Result<Self> {
                let mut table: LanguageRecord =
                    unsafe { ::std::mem::zeroed() };
                {
                    let value =
                        {
                            let value =
                                match tape.take() {
                                    ::std::result::Result::Ok(val) => val,
                                    ::std::result::Result::Err(err) => {
                                        return ::std::result::Result::Err(::std::convert::From::from(err))
                                    }
                                };
                            if value != { 0 } {
                                return Err(::truetype::Error::new(::std::io::ErrorKind::Other,
                                                                  "found a malformed or unsupported table"));
                            }
                            value
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.lookup_order,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.required_feature_index,
                                                           value));
                }
                {
                    let value =
                        match tape.take() {
                            ::std::result::Result::Ok(val) => val,
                            ::std::result::Result::Err(err) => {
                                return ::std::result::Result::Err(::std::convert::From::from(err))
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.feature_count,
                                                           value));
                }
                {
                    let value =
                        {
                            #[inline(always)]
                            fn read<T: ::truetype::Tape>(this:
                                                             &LanguageRecord,
                                                         tape: &mut T)
                             -> ::truetype::Result<Vec<u16>> {
                                tape.take_given(this.feature_count as usize)
                            }
                            match read(&table, tape) {
                                ::std::result::Result::Ok(val) => val,
                                ::std::result::Result::Err(err) => {
                                    return ::std::result::Result::Err(::std::convert::From::from(err))
                                }
                            }
                        };
                    ::std::mem::forget(::std::mem::replace(&mut table.feature_indices,
                                                           value));
                }
                Ok(table)
            }
        }
        /// A script.
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub enum Script {

            #[doc = "Adlam"]
            Adlam,

            #[doc = "Ahom"]
            Ahom,

            #[doc = "Anatolian Hieroglyphs"]
            AnatolianHieroglyphs,

            #[doc = "Arabic"]
            Arabic,

            #[doc = "Armenian"]
            Armenian,

            #[doc = "Avestan"]
            Avestan,

            #[doc = "Balinese"]
            Balinese,

            #[doc = "Bamum"]
            Bamum,

            #[doc = "Bassa Vah"]
            BassaVah,

            #[doc = "Batak"]
            Batak,

            #[doc = "Bengali"]
            Bengali,

            #[doc = "Bengali v2"]
            BengaliV2,

            #[doc = "Bhaiksuki"]
            Bhaiksuki,

            #[doc = "Bopomofo"]
            Bopomofo,

            #[doc = "Brahmi"]
            Brahmi,

            #[doc = "Braille"]
            Braille,

            #[doc = "Buginese"]
            Buginese,

            #[doc = "Buhid"]
            Buhid,

            #[doc = "Byzantine Music"]
            ByzantineMusic,

            #[doc = "Canadian Syllabics"]
            CanadianSyllabics,

            #[doc = "Carian"]
            Carian,

            #[doc = "Caucasian Albanian"]
            CaucasianAlbanian,

            #[doc = "Chakma"]
            Chakma,

            #[doc = "Cham"]
            Cham,

            #[doc = "Cherokee"]
            Cherokee,

            #[doc = "CJK Ideographic"]
            CJKIdeographic,

            #[doc = "Coptic"]
            Coptic,

            #[doc = "Cypriot Syllabary"]
            CypriotSyllabary,

            #[doc = "Cyrillic"]
            Cyrillic,

            #[doc = "Default"]
            Default,

            #[doc = "Deseret"]
            Deseret,

            #[doc = "Devanagari"]
            Devanagari,

            #[doc = "Devanagari v2"]
            DevanagariV2,

            #[doc = "Duployan"]
            Duployan,

            #[doc = "Egyptian Hieroglyphs"]
            EgyptianHieroglyphs,

            #[doc = "Elbasan"]
            Elbasan,

            #[doc = "Ethiopic"]
            Ethiopic,

            #[doc = "Georgian"]
            Georgian,

            #[doc = "Glagolitic"]
            Glagolitic,

            #[doc = "Gothic"]
            Gothic,

            #[doc = "Grantha"]
            Grantha,

            #[doc = "Greek"]
            Greek,

            #[doc = "Gujarati"]
            Gujarati,

            #[doc = "Gujarati v2"]
            GujaratiV2,

            #[doc = "Gurmukhi"]
            Gurmukhi,

            #[doc = "Gurmukhi v2"]
            GurmukhiV2,

            #[doc = "Hangul"]
            Hangul,

            #[doc = "Hangul Jamo"]
            HangulJamo,

            #[doc = "Hanunoo"]
            Hanunoo,

            #[doc = "Hatran"]
            Hatran,

            #[doc = "Hebrew"]
            Hebrew,

            #[doc = "Hiragana"]
            Hiragana,

            #[doc = "Imperial Aramaic"]
            ImperialAramaic,

            #[doc = "Inscriptional Pahlavi"]
            InscriptionalPahlavi,

            #[doc = "Inscriptional Parthian"]
            InscriptionalParthian,

            #[doc = "Javanese"]
            Javanese,

            #[doc = "Kaithi"]
            Kaithi,

            #[doc = "Kannada"]
            Kannada,

            #[doc = "Kannada v2"]
            KannadaV2,

            #[doc = "Katakana"]
            Katakana,

            #[doc = "Kayah Li"]
            KayahLi,

            #[doc = "Kharosthi"]
            Kharosthi,

            #[doc = "Khmer"]
            Khmer,

            #[doc = "Khojki"]
            Khojki,

            #[doc = "Khudawadi"]
            Khudawadi,

            #[doc = "Lao"]
            Lao,

            #[doc = "Latin"]
            Latin,

            #[doc = "Lepcha"]
            Lepcha,

            #[doc = "Limbu"]
            Limbu,

            #[doc = "Linear A"]
            LinearA,

            #[doc = "Linear B"]
            LinearB,

            #[doc = "Lisu (Fraser)"]
            Lisu,

            #[doc = "Lycian"]
            Lycian,

            #[doc = "Lydian"]
            Lydian,

            #[doc = "Mahajani"]
            Mahajani,

            #[doc = "Malayalam"]
            Malayalam,

            #[doc = "Malayalam v2"]
            MalayalamV2,

            #[doc = "Mandaic, Mandaean"]
            Mandaic,

            #[doc = "Manichaean"]
            Manichaean,

            #[doc = "Marchen"]
            Marchen,

            #[doc = "Mathematical Alphanumeric Symbols"]
            MathematicalAlphanumericSymbols,

            #[doc = "Meitei Mayek (Meithei, Meetei)"]
            MeiteiMayek,

            #[doc = "Mende Kikakui"]
            MendeKikakui,

            #[doc = "Meroitic Cursive"]
            MeroiticCursive,

            #[doc = "Meroitic Hieroglyphs"]
            MeroiticHieroglyphs,

            #[doc = "Miao"]
            Miao,

            #[doc = "Modi"]
            Modi,

            #[doc = "Mongolian"]
            Mongolian,

            #[doc = "Mro"]
            Mro,

            #[doc = "Multani"]
            Multani,

            #[doc = "Musical Symbols"]
            MusicalSymbols,

            #[doc = "Myanmar"]
            Myanmar,

            #[doc = "Myanmar v2"]
            MyanmarV2,

            #[doc = "Nabataean"]
            Nabataean,

            #[doc = "Newa"]
            Newa,

            #[doc = "New Tai Lue"]
            NewTaiLue,

            #[doc = "N\u{2019}Ko"]
            NKo,

            #[doc = "Odia (formerly Oriya)"]
            Odia,

            #[doc = "Odia v2 (formerly Oriya v2)"]
            OdiaV2,

            #[doc = "Ogham"]
            Ogham,

            #[doc = "Ol Chiki"]
            OlChiki,

            #[doc = "Old Italic"]
            OldItalic,

            #[doc = "Old Hungarian"]
            OldHungarian,

            #[doc = "Old North Arabian"]
            OldNorthArabian,

            #[doc = "Old Permic"]
            OldPermic,

            #[doc = "Old Persian Cuneiform"]
            OldPersianCuneiform,

            #[doc = "Old South Arabian"]
            OldSouthArabian,

            #[doc = "Old Turkic, Orkhon Runic"]
            OldTurkic,

            #[doc = "Osage"]
            Osage,

            #[doc = "Osmanya"]
            Osmanya,

            #[doc = "Pahawh Hmong"]
            PahawhHmong,

            #[doc = "Palmyrene"]
            Palmyrene,

            #[doc = "Pau Cin Hau"]
            PauCinHau,

            #[doc = "Phags-pa"]
            Phagspa,

            #[doc = "Phoenician"]
            Phoenician,

            #[doc = "Psalter Pahlavi"]
            PsalterPahlavi,

            #[doc = "Rejang"]
            Rejang,

            #[doc = "Runic"]
            Runic,

            #[doc = "Samaritan"]
            Samaritan,

            #[doc = "Saurashtra"]
            Saurashtra,

            #[doc = "Sharada"]
            Sharada,

            #[doc = "Shavian"]
            Shavian,

            #[doc = "Siddham"]
            Siddham,

            #[doc = "Sign Writing"]
            SignWriting,

            #[doc = "Sinhala"]
            Sinhala,

            #[doc = "Sora Sompeng"]
            SoraSompeng,

            #[doc = "Sumero-Akkadian Cuneiform"]
            SumeroAkkadianCuneiform,

            #[doc = "Sundanese"]
            Sundanese,

            #[doc = "Syloti Nagri"]
            SylotiNagri,

            #[doc = "Syriac"]
            Syriac,

            #[doc = "Tagalog"]
            Tagalog,

            #[doc = "Tagbanwa"]
            Tagbanwa,

            #[doc = "Tai Le"]
            TaiLe,

            #[doc = "Tai Tham (Lanna)"]
            TaiTham,

            #[doc = "Tai Viet"]
            TaiViet,

            #[doc = "Takri"]
            Takri,

            #[doc = "Tamil"]
            Tamil,

            #[doc = "Tamil v2"]
            TamilV2,

            #[doc = "Tangut"]
            Tangut,

            #[doc = "Telugu"]
            Telugu,

            #[doc = "Telugu v2"]
            TeluguV2,

            #[doc = "Thaana"]
            Thaana,

            #[doc = "Thai"]
            Thai,

            #[doc = "Tibetan"]
            Tibetan,

            #[doc = "Tifinagh"]
            Tifinagh,

            #[doc = "Tirhuta"]
            Tirhuta,

            #[doc = "Ugaritic Cuneiform"]
            UgariticCuneiform,

            #[doc = "Vai"]
            Vai,

            #[doc = "Warang Citi"]
            WarangCiti,

            #[doc = "Yi"]
            Yi,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Script {
            #[inline]
            fn clone(&self) -> Script { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Script { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Script {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Script::Adlam,) => {
                        let mut builder = __arg_0.debug_tuple("Adlam");
                        builder.finish()
                    }
                    (&Script::Ahom,) => {
                        let mut builder = __arg_0.debug_tuple("Ahom");
                        builder.finish()
                    }
                    (&Script::AnatolianHieroglyphs,) => {
                        let mut builder =
                            __arg_0.debug_tuple("AnatolianHieroglyphs");
                        builder.finish()
                    }
                    (&Script::Arabic,) => {
                        let mut builder = __arg_0.debug_tuple("Arabic");
                        builder.finish()
                    }
                    (&Script::Armenian,) => {
                        let mut builder = __arg_0.debug_tuple("Armenian");
                        builder.finish()
                    }
                    (&Script::Avestan,) => {
                        let mut builder = __arg_0.debug_tuple("Avestan");
                        builder.finish()
                    }
                    (&Script::Balinese,) => {
                        let mut builder = __arg_0.debug_tuple("Balinese");
                        builder.finish()
                    }
                    (&Script::Bamum,) => {
                        let mut builder = __arg_0.debug_tuple("Bamum");
                        builder.finish()
                    }
                    (&Script::BassaVah,) => {
                        let mut builder = __arg_0.debug_tuple("BassaVah");
                        builder.finish()
                    }
                    (&Script::Batak,) => {
                        let mut builder = __arg_0.debug_tuple("Batak");
                        builder.finish()
                    }
                    (&Script::Bengali,) => {
                        let mut builder = __arg_0.debug_tuple("Bengali");
                        builder.finish()
                    }
                    (&Script::BengaliV2,) => {
                        let mut builder = __arg_0.debug_tuple("BengaliV2");
                        builder.finish()
                    }
                    (&Script::Bhaiksuki,) => {
                        let mut builder = __arg_0.debug_tuple("Bhaiksuki");
                        builder.finish()
                    }
                    (&Script::Bopomofo,) => {
                        let mut builder = __arg_0.debug_tuple("Bopomofo");
                        builder.finish()
                    }
                    (&Script::Brahmi,) => {
                        let mut builder = __arg_0.debug_tuple("Brahmi");
                        builder.finish()
                    }
                    (&Script::Braille,) => {
                        let mut builder = __arg_0.debug_tuple("Braille");
                        builder.finish()
                    }
                    (&Script::Buginese,) => {
                        let mut builder = __arg_0.debug_tuple("Buginese");
                        builder.finish()
                    }
                    (&Script::Buhid,) => {
                        let mut builder = __arg_0.debug_tuple("Buhid");
                        builder.finish()
                    }
                    (&Script::ByzantineMusic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ByzantineMusic");
                        builder.finish()
                    }
                    (&Script::CanadianSyllabics,) => {
                        let mut builder =
                            __arg_0.debug_tuple("CanadianSyllabics");
                        builder.finish()
                    }
                    (&Script::Carian,) => {
                        let mut builder = __arg_0.debug_tuple("Carian");
                        builder.finish()
                    }
                    (&Script::CaucasianAlbanian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("CaucasianAlbanian");
                        builder.finish()
                    }
                    (&Script::Chakma,) => {
                        let mut builder = __arg_0.debug_tuple("Chakma");
                        builder.finish()
                    }
                    (&Script::Cham,) => {
                        let mut builder = __arg_0.debug_tuple("Cham");
                        builder.finish()
                    }
                    (&Script::Cherokee,) => {
                        let mut builder = __arg_0.debug_tuple("Cherokee");
                        builder.finish()
                    }
                    (&Script::CJKIdeographic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("CJKIdeographic");
                        builder.finish()
                    }
                    (&Script::Coptic,) => {
                        let mut builder = __arg_0.debug_tuple("Coptic");
                        builder.finish()
                    }
                    (&Script::CypriotSyllabary,) => {
                        let mut builder =
                            __arg_0.debug_tuple("CypriotSyllabary");
                        builder.finish()
                    }
                    (&Script::Cyrillic,) => {
                        let mut builder = __arg_0.debug_tuple("Cyrillic");
                        builder.finish()
                    }
                    (&Script::Default,) => {
                        let mut builder = __arg_0.debug_tuple("Default");
                        builder.finish()
                    }
                    (&Script::Deseret,) => {
                        let mut builder = __arg_0.debug_tuple("Deseret");
                        builder.finish()
                    }
                    (&Script::Devanagari,) => {
                        let mut builder = __arg_0.debug_tuple("Devanagari");
                        builder.finish()
                    }
                    (&Script::DevanagariV2,) => {
                        let mut builder = __arg_0.debug_tuple("DevanagariV2");
                        builder.finish()
                    }
                    (&Script::Duployan,) => {
                        let mut builder = __arg_0.debug_tuple("Duployan");
                        builder.finish()
                    }
                    (&Script::EgyptianHieroglyphs,) => {
                        let mut builder =
                            __arg_0.debug_tuple("EgyptianHieroglyphs");
                        builder.finish()
                    }
                    (&Script::Elbasan,) => {
                        let mut builder = __arg_0.debug_tuple("Elbasan");
                        builder.finish()
                    }
                    (&Script::Ethiopic,) => {
                        let mut builder = __arg_0.debug_tuple("Ethiopic");
                        builder.finish()
                    }
                    (&Script::Georgian,) => {
                        let mut builder = __arg_0.debug_tuple("Georgian");
                        builder.finish()
                    }
                    (&Script::Glagolitic,) => {
                        let mut builder = __arg_0.debug_tuple("Glagolitic");
                        builder.finish()
                    }
                    (&Script::Gothic,) => {
                        let mut builder = __arg_0.debug_tuple("Gothic");
                        builder.finish()
                    }
                    (&Script::Grantha,) => {
                        let mut builder = __arg_0.debug_tuple("Grantha");
                        builder.finish()
                    }
                    (&Script::Greek,) => {
                        let mut builder = __arg_0.debug_tuple("Greek");
                        builder.finish()
                    }
                    (&Script::Gujarati,) => {
                        let mut builder = __arg_0.debug_tuple("Gujarati");
                        builder.finish()
                    }
                    (&Script::GujaratiV2,) => {
                        let mut builder = __arg_0.debug_tuple("GujaratiV2");
                        builder.finish()
                    }
                    (&Script::Gurmukhi,) => {
                        let mut builder = __arg_0.debug_tuple("Gurmukhi");
                        builder.finish()
                    }
                    (&Script::GurmukhiV2,) => {
                        let mut builder = __arg_0.debug_tuple("GurmukhiV2");
                        builder.finish()
                    }
                    (&Script::Hangul,) => {
                        let mut builder = __arg_0.debug_tuple("Hangul");
                        builder.finish()
                    }
                    (&Script::HangulJamo,) => {
                        let mut builder = __arg_0.debug_tuple("HangulJamo");
                        builder.finish()
                    }
                    (&Script::Hanunoo,) => {
                        let mut builder = __arg_0.debug_tuple("Hanunoo");
                        builder.finish()
                    }
                    (&Script::Hatran,) => {
                        let mut builder = __arg_0.debug_tuple("Hatran");
                        builder.finish()
                    }
                    (&Script::Hebrew,) => {
                        let mut builder = __arg_0.debug_tuple("Hebrew");
                        builder.finish()
                    }
                    (&Script::Hiragana,) => {
                        let mut builder = __arg_0.debug_tuple("Hiragana");
                        builder.finish()
                    }
                    (&Script::ImperialAramaic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ImperialAramaic");
                        builder.finish()
                    }
                    (&Script::InscriptionalPahlavi,) => {
                        let mut builder =
                            __arg_0.debug_tuple("InscriptionalPahlavi");
                        builder.finish()
                    }
                    (&Script::InscriptionalParthian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("InscriptionalParthian");
                        builder.finish()
                    }
                    (&Script::Javanese,) => {
                        let mut builder = __arg_0.debug_tuple("Javanese");
                        builder.finish()
                    }
                    (&Script::Kaithi,) => {
                        let mut builder = __arg_0.debug_tuple("Kaithi");
                        builder.finish()
                    }
                    (&Script::Kannada,) => {
                        let mut builder = __arg_0.debug_tuple("Kannada");
                        builder.finish()
                    }
                    (&Script::KannadaV2,) => {
                        let mut builder = __arg_0.debug_tuple("KannadaV2");
                        builder.finish()
                    }
                    (&Script::Katakana,) => {
                        let mut builder = __arg_0.debug_tuple("Katakana");
                        builder.finish()
                    }
                    (&Script::KayahLi,) => {
                        let mut builder = __arg_0.debug_tuple("KayahLi");
                        builder.finish()
                    }
                    (&Script::Kharosthi,) => {
                        let mut builder = __arg_0.debug_tuple("Kharosthi");
                        builder.finish()
                    }
                    (&Script::Khmer,) => {
                        let mut builder = __arg_0.debug_tuple("Khmer");
                        builder.finish()
                    }
                    (&Script::Khojki,) => {
                        let mut builder = __arg_0.debug_tuple("Khojki");
                        builder.finish()
                    }
                    (&Script::Khudawadi,) => {
                        let mut builder = __arg_0.debug_tuple("Khudawadi");
                        builder.finish()
                    }
                    (&Script::Lao,) => {
                        let mut builder = __arg_0.debug_tuple("Lao");
                        builder.finish()
                    }
                    (&Script::Latin,) => {
                        let mut builder = __arg_0.debug_tuple("Latin");
                        builder.finish()
                    }
                    (&Script::Lepcha,) => {
                        let mut builder = __arg_0.debug_tuple("Lepcha");
                        builder.finish()
                    }
                    (&Script::Limbu,) => {
                        let mut builder = __arg_0.debug_tuple("Limbu");
                        builder.finish()
                    }
                    (&Script::LinearA,) => {
                        let mut builder = __arg_0.debug_tuple("LinearA");
                        builder.finish()
                    }
                    (&Script::LinearB,) => {
                        let mut builder = __arg_0.debug_tuple("LinearB");
                        builder.finish()
                    }
                    (&Script::Lisu,) => {
                        let mut builder = __arg_0.debug_tuple("Lisu");
                        builder.finish()
                    }
                    (&Script::Lycian,) => {
                        let mut builder = __arg_0.debug_tuple("Lycian");
                        builder.finish()
                    }
                    (&Script::Lydian,) => {
                        let mut builder = __arg_0.debug_tuple("Lydian");
                        builder.finish()
                    }
                    (&Script::Mahajani,) => {
                        let mut builder = __arg_0.debug_tuple("Mahajani");
                        builder.finish()
                    }
                    (&Script::Malayalam,) => {
                        let mut builder = __arg_0.debug_tuple("Malayalam");
                        builder.finish()
                    }
                    (&Script::MalayalamV2,) => {
                        let mut builder = __arg_0.debug_tuple("MalayalamV2");
                        builder.finish()
                    }
                    (&Script::Mandaic,) => {
                        let mut builder = __arg_0.debug_tuple("Mandaic");
                        builder.finish()
                    }
                    (&Script::Manichaean,) => {
                        let mut builder = __arg_0.debug_tuple("Manichaean");
                        builder.finish()
                    }
                    (&Script::Marchen,) => {
                        let mut builder = __arg_0.debug_tuple("Marchen");
                        builder.finish()
                    }
                    (&Script::MathematicalAlphanumericSymbols,) => {
                        let mut builder =
                            __arg_0.debug_tuple("MathematicalAlphanumericSymbols");
                        builder.finish()
                    }
                    (&Script::MeiteiMayek,) => {
                        let mut builder = __arg_0.debug_tuple("MeiteiMayek");
                        builder.finish()
                    }
                    (&Script::MendeKikakui,) => {
                        let mut builder = __arg_0.debug_tuple("MendeKikakui");
                        builder.finish()
                    }
                    (&Script::MeroiticCursive,) => {
                        let mut builder =
                            __arg_0.debug_tuple("MeroiticCursive");
                        builder.finish()
                    }
                    (&Script::MeroiticHieroglyphs,) => {
                        let mut builder =
                            __arg_0.debug_tuple("MeroiticHieroglyphs");
                        builder.finish()
                    }
                    (&Script::Miao,) => {
                        let mut builder = __arg_0.debug_tuple("Miao");
                        builder.finish()
                    }
                    (&Script::Modi,) => {
                        let mut builder = __arg_0.debug_tuple("Modi");
                        builder.finish()
                    }
                    (&Script::Mongolian,) => {
                        let mut builder = __arg_0.debug_tuple("Mongolian");
                        builder.finish()
                    }
                    (&Script::Mro,) => {
                        let mut builder = __arg_0.debug_tuple("Mro");
                        builder.finish()
                    }
                    (&Script::Multani,) => {
                        let mut builder = __arg_0.debug_tuple("Multani");
                        builder.finish()
                    }
                    (&Script::MusicalSymbols,) => {
                        let mut builder =
                            __arg_0.debug_tuple("MusicalSymbols");
                        builder.finish()
                    }
                    (&Script::Myanmar,) => {
                        let mut builder = __arg_0.debug_tuple("Myanmar");
                        builder.finish()
                    }
                    (&Script::MyanmarV2,) => {
                        let mut builder = __arg_0.debug_tuple("MyanmarV2");
                        builder.finish()
                    }
                    (&Script::Nabataean,) => {
                        let mut builder = __arg_0.debug_tuple("Nabataean");
                        builder.finish()
                    }
                    (&Script::Newa,) => {
                        let mut builder = __arg_0.debug_tuple("Newa");
                        builder.finish()
                    }
                    (&Script::NewTaiLue,) => {
                        let mut builder = __arg_0.debug_tuple("NewTaiLue");
                        builder.finish()
                    }
                    (&Script::NKo,) => {
                        let mut builder = __arg_0.debug_tuple("NKo");
                        builder.finish()
                    }
                    (&Script::Odia,) => {
                        let mut builder = __arg_0.debug_tuple("Odia");
                        builder.finish()
                    }
                    (&Script::OdiaV2,) => {
                        let mut builder = __arg_0.debug_tuple("OdiaV2");
                        builder.finish()
                    }
                    (&Script::Ogham,) => {
                        let mut builder = __arg_0.debug_tuple("Ogham");
                        builder.finish()
                    }
                    (&Script::OlChiki,) => {
                        let mut builder = __arg_0.debug_tuple("OlChiki");
                        builder.finish()
                    }
                    (&Script::OldItalic,) => {
                        let mut builder = __arg_0.debug_tuple("OldItalic");
                        builder.finish()
                    }
                    (&Script::OldHungarian,) => {
                        let mut builder = __arg_0.debug_tuple("OldHungarian");
                        builder.finish()
                    }
                    (&Script::OldNorthArabian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("OldNorthArabian");
                        builder.finish()
                    }
                    (&Script::OldPermic,) => {
                        let mut builder = __arg_0.debug_tuple("OldPermic");
                        builder.finish()
                    }
                    (&Script::OldPersianCuneiform,) => {
                        let mut builder =
                            __arg_0.debug_tuple("OldPersianCuneiform");
                        builder.finish()
                    }
                    (&Script::OldSouthArabian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("OldSouthArabian");
                        builder.finish()
                    }
                    (&Script::OldTurkic,) => {
                        let mut builder = __arg_0.debug_tuple("OldTurkic");
                        builder.finish()
                    }
                    (&Script::Osage,) => {
                        let mut builder = __arg_0.debug_tuple("Osage");
                        builder.finish()
                    }
                    (&Script::Osmanya,) => {
                        let mut builder = __arg_0.debug_tuple("Osmanya");
                        builder.finish()
                    }
                    (&Script::PahawhHmong,) => {
                        let mut builder = __arg_0.debug_tuple("PahawhHmong");
                        builder.finish()
                    }
                    (&Script::Palmyrene,) => {
                        let mut builder = __arg_0.debug_tuple("Palmyrene");
                        builder.finish()
                    }
                    (&Script::PauCinHau,) => {
                        let mut builder = __arg_0.debug_tuple("PauCinHau");
                        builder.finish()
                    }
                    (&Script::Phagspa,) => {
                        let mut builder = __arg_0.debug_tuple("Phagspa");
                        builder.finish()
                    }
                    (&Script::Phoenician,) => {
                        let mut builder = __arg_0.debug_tuple("Phoenician");
                        builder.finish()
                    }
                    (&Script::PsalterPahlavi,) => {
                        let mut builder =
                            __arg_0.debug_tuple("PsalterPahlavi");
                        builder.finish()
                    }
                    (&Script::Rejang,) => {
                        let mut builder = __arg_0.debug_tuple("Rejang");
                        builder.finish()
                    }
                    (&Script::Runic,) => {
                        let mut builder = __arg_0.debug_tuple("Runic");
                        builder.finish()
                    }
                    (&Script::Samaritan,) => {
                        let mut builder = __arg_0.debug_tuple("Samaritan");
                        builder.finish()
                    }
                    (&Script::Saurashtra,) => {
                        let mut builder = __arg_0.debug_tuple("Saurashtra");
                        builder.finish()
                    }
                    (&Script::Sharada,) => {
                        let mut builder = __arg_0.debug_tuple("Sharada");
                        builder.finish()
                    }
                    (&Script::Shavian,) => {
                        let mut builder = __arg_0.debug_tuple("Shavian");
                        builder.finish()
                    }
                    (&Script::Siddham,) => {
                        let mut builder = __arg_0.debug_tuple("Siddham");
                        builder.finish()
                    }
                    (&Script::SignWriting,) => {
                        let mut builder = __arg_0.debug_tuple("SignWriting");
                        builder.finish()
                    }
                    (&Script::Sinhala,) => {
                        let mut builder = __arg_0.debug_tuple("Sinhala");
                        builder.finish()
                    }
                    (&Script::SoraSompeng,) => {
                        let mut builder = __arg_0.debug_tuple("SoraSompeng");
                        builder.finish()
                    }
                    (&Script::SumeroAkkadianCuneiform,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SumeroAkkadianCuneiform");
                        builder.finish()
                    }
                    (&Script::Sundanese,) => {
                        let mut builder = __arg_0.debug_tuple("Sundanese");
                        builder.finish()
                    }
                    (&Script::SylotiNagri,) => {
                        let mut builder = __arg_0.debug_tuple("SylotiNagri");
                        builder.finish()
                    }
                    (&Script::Syriac,) => {
                        let mut builder = __arg_0.debug_tuple("Syriac");
                        builder.finish()
                    }
                    (&Script::Tagalog,) => {
                        let mut builder = __arg_0.debug_tuple("Tagalog");
                        builder.finish()
                    }
                    (&Script::Tagbanwa,) => {
                        let mut builder = __arg_0.debug_tuple("Tagbanwa");
                        builder.finish()
                    }
                    (&Script::TaiLe,) => {
                        let mut builder = __arg_0.debug_tuple("TaiLe");
                        builder.finish()
                    }
                    (&Script::TaiTham,) => {
                        let mut builder = __arg_0.debug_tuple("TaiTham");
                        builder.finish()
                    }
                    (&Script::TaiViet,) => {
                        let mut builder = __arg_0.debug_tuple("TaiViet");
                        builder.finish()
                    }
                    (&Script::Takri,) => {
                        let mut builder = __arg_0.debug_tuple("Takri");
                        builder.finish()
                    }
                    (&Script::Tamil,) => {
                        let mut builder = __arg_0.debug_tuple("Tamil");
                        builder.finish()
                    }
                    (&Script::TamilV2,) => {
                        let mut builder = __arg_0.debug_tuple("TamilV2");
                        builder.finish()
                    }
                    (&Script::Tangut,) => {
                        let mut builder = __arg_0.debug_tuple("Tangut");
                        builder.finish()
                    }
                    (&Script::Telugu,) => {
                        let mut builder = __arg_0.debug_tuple("Telugu");
                        builder.finish()
                    }
                    (&Script::TeluguV2,) => {
                        let mut builder = __arg_0.debug_tuple("TeluguV2");
                        builder.finish()
                    }
                    (&Script::Thaana,) => {
                        let mut builder = __arg_0.debug_tuple("Thaana");
                        builder.finish()
                    }
                    (&Script::Thai,) => {
                        let mut builder = __arg_0.debug_tuple("Thai");
                        builder.finish()
                    }
                    (&Script::Tibetan,) => {
                        let mut builder = __arg_0.debug_tuple("Tibetan");
                        builder.finish()
                    }
                    (&Script::Tifinagh,) => {
                        let mut builder = __arg_0.debug_tuple("Tifinagh");
                        builder.finish()
                    }
                    (&Script::Tirhuta,) => {
                        let mut builder = __arg_0.debug_tuple("Tirhuta");
                        builder.finish()
                    }
                    (&Script::UgariticCuneiform,) => {
                        let mut builder =
                            __arg_0.debug_tuple("UgariticCuneiform");
                        builder.finish()
                    }
                    (&Script::Vai,) => {
                        let mut builder = __arg_0.debug_tuple("Vai");
                        builder.finish()
                    }
                    (&Script::WarangCiti,) => {
                        let mut builder = __arg_0.debug_tuple("WarangCiti");
                        builder.finish()
                    }
                    (&Script::Yi,) => {
                        let mut builder = __arg_0.debug_tuple("Yi");
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Script {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Script {
            #[inline]
            fn eq(&self, __arg_0: &Script) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        impl Script {
            /// Return the tag.
            pub fn tag(&self) -> Tag {
                use self::Script::*;
                match *self {
                    Adlam => Tag(*b"adlm"),
                    Ahom => Tag(*b"ahom"),
                    AnatolianHieroglyphs => Tag(*b"hluw"),
                    Arabic => Tag(*b"arab"),
                    Armenian => Tag(*b"armn"),
                    Avestan => Tag(*b"avst"),
                    Balinese => Tag(*b"bali"),
                    Bamum => Tag(*b"bamu"),
                    BassaVah => Tag(*b"bass"),
                    Batak => Tag(*b"batk"),
                    Bengali => Tag(*b"beng"),
                    BengaliV2 => Tag(*b"bng2"),
                    Bhaiksuki => Tag(*b"bhks"),
                    Bopomofo => Tag(*b"bopo"),
                    Brahmi => Tag(*b"brah"),
                    Braille => Tag(*b"brai"),
                    Buginese => Tag(*b"bugi"),
                    Buhid => Tag(*b"buhd"),
                    ByzantineMusic => Tag(*b"byzm"),
                    CanadianSyllabics => Tag(*b"cans"),
                    Carian => Tag(*b"cari"),
                    CaucasianAlbanian => Tag(*b"aghb"),
                    Chakma => Tag(*b"cakm"),
                    Cham => Tag(*b"cham"),
                    Cherokee => Tag(*b"cher"),
                    CJKIdeographic => Tag(*b"hani"),
                    Coptic => Tag(*b"copt"),
                    CypriotSyllabary => Tag(*b"cprt"),
                    Cyrillic => Tag(*b"cyrl"),
                    Default => Tag(*b"DFLT"),
                    Deseret => Tag(*b"dsrt"),
                    Devanagari => Tag(*b"deva"),
                    DevanagariV2 => Tag(*b"dev2"),
                    Duployan => Tag(*b"dupl"),
                    EgyptianHieroglyphs => Tag(*b"egyp"),
                    Elbasan => Tag(*b"elba"),
                    Ethiopic => Tag(*b"ethi"),
                    Georgian => Tag(*b"geor"),
                    Glagolitic => Tag(*b"glag"),
                    Gothic => Tag(*b"goth"),
                    Grantha => Tag(*b"gran"),
                    Greek => Tag(*b"grek"),
                    Gujarati => Tag(*b"gujr"),
                    GujaratiV2 => Tag(*b"gjr2"),
                    Gurmukhi => Tag(*b"guru"),
                    GurmukhiV2 => Tag(*b"gur2"),
                    Hangul => Tag(*b"hang"),
                    HangulJamo => Tag(*b"jamo"),
                    Hanunoo => Tag(*b"hano"),
                    Hatran => Tag(*b"hatr"),
                    Hebrew => Tag(*b"hebr"),
                    Hiragana => Tag(*b"kana"),
                    ImperialAramaic => Tag(*b"armi"),
                    InscriptionalPahlavi => Tag(*b"phli"),
                    InscriptionalParthian => Tag(*b"prti"),
                    Javanese => Tag(*b"java"),
                    Kaithi => Tag(*b"kthi"),
                    Kannada => Tag(*b"knda"),
                    KannadaV2 => Tag(*b"knd2"),
                    Katakana => Tag(*b"kana"),
                    KayahLi => Tag(*b"kali"),
                    Kharosthi => Tag(*b"khar"),
                    Khmer => Tag(*b"khmr"),
                    Khojki => Tag(*b"khoj"),
                    Khudawadi => Tag(*b"sind"),
                    Lao => Tag(*b"lao "),
                    Latin => Tag(*b"latn"),
                    Lepcha => Tag(*b"lepc"),
                    Limbu => Tag(*b"limb"),
                    LinearA => Tag(*b"lina"),
                    LinearB => Tag(*b"linb"),
                    Lisu => Tag(*b"lisu"),
                    Lycian => Tag(*b"lyci"),
                    Lydian => Tag(*b"lydi"),
                    Mahajani => Tag(*b"mahj"),
                    Malayalam => Tag(*b"mlym"),
                    MalayalamV2 => Tag(*b"mlm2"),
                    Mandaic => Tag(*b"mand"),
                    Manichaean => Tag(*b"mani"),
                    Marchen => Tag(*b"marc"),
                    MathematicalAlphanumericSymbols => Tag(*b"math"),
                    MeiteiMayek => Tag(*b"mtei"),
                    MendeKikakui => Tag(*b"mend"),
                    MeroiticCursive => Tag(*b"merc"),
                    MeroiticHieroglyphs => Tag(*b"mero"),
                    Miao => Tag(*b"plrd"),
                    Modi => Tag(*b"modi"),
                    Mongolian => Tag(*b"mong"),
                    Mro => Tag(*b"mroo"),
                    Multani => Tag(*b"mult"),
                    MusicalSymbols => Tag(*b"musc"),
                    Myanmar => Tag(*b"mymr"),
                    MyanmarV2 => Tag(*b"mym2"),
                    Nabataean => Tag(*b"nbat"),
                    Newa => Tag(*b"newa"),
                    NewTaiLue => Tag(*b"talu"),
                    NKo => Tag(*b"nko "),
                    Odia => Tag(*b"orya"),
                    OdiaV2 => Tag(*b"ory2"),
                    Ogham => Tag(*b"ogam"),
                    OlChiki => Tag(*b"olck"),
                    OldItalic => Tag(*b"ital"),
                    OldHungarian => Tag(*b"hung"),
                    OldNorthArabian => Tag(*b"narb"),
                    OldPermic => Tag(*b"perm"),
                    OldPersianCuneiform => Tag(*b"xpeo"),
                    OldSouthArabian => Tag(*b"sarb"),
                    OldTurkic => Tag(*b"orkh"),
                    Osage => Tag(*b"osge"),
                    Osmanya => Tag(*b"osma"),
                    PahawhHmong => Tag(*b"hmng"),
                    Palmyrene => Tag(*b"palm"),
                    PauCinHau => Tag(*b"pauc"),
                    Phagspa => Tag(*b"phag"),
                    Phoenician => Tag(*b"phnx"),
                    PsalterPahlavi => Tag(*b"phlp"),
                    Rejang => Tag(*b"rjng"),
                    Runic => Tag(*b"runr"),
                    Samaritan => Tag(*b"samr"),
                    Saurashtra => Tag(*b"saur"),
                    Sharada => Tag(*b"shrd"),
                    Shavian => Tag(*b"shaw"),
                    Siddham => Tag(*b"sidd"),
                    SignWriting => Tag(*b"sgnw"),
                    Sinhala => Tag(*b"sinh"),
                    SoraSompeng => Tag(*b"sora"),
                    SumeroAkkadianCuneiform => Tag(*b"xsux"),
                    Sundanese => Tag(*b"sund"),
                    SylotiNagri => Tag(*b"sylo"),
                    Syriac => Tag(*b"syrc"),
                    Tagalog => Tag(*b"tglg"),
                    Tagbanwa => Tag(*b"tagb"),
                    TaiLe => Tag(*b"tale"),
                    TaiTham => Tag(*b"lana"),
                    TaiViet => Tag(*b"tavt"),
                    Takri => Tag(*b"takr"),
                    Tamil => Tag(*b"taml"),
                    TamilV2 => Tag(*b"tml2"),
                    Tangut => Tag(*b"tang"),
                    Telugu => Tag(*b"telu"),
                    TeluguV2 => Tag(*b"tel2"),
                    Thaana => Tag(*b"thaa"),
                    Thai => Tag(*b"thai"),
                    Tibetan => Tag(*b"tibt"),
                    Tifinagh => Tag(*b"tfng"),
                    Tirhuta => Tag(*b"tirh"),
                    UgariticCuneiform => Tag(*b"ugar"),
                    Vai => Tag(*b"vai "),
                    WarangCiti => Tag(*b"wara"),
                    Yi => Tag(*b"yi  "),
                }
            }
        }
        impl Scripts {
            /// Return the record of a script if present.
            pub fn get(&self, script: Script) -> Option<&Record> {
                let tag = script.tag();
                for (i, header) in self.headers.iter().enumerate() {
                    if header.tag == tag { return Some(&self.records[i]); }
                }
                None
            }
        }
        /// A language system.
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub enum Language {

            #[doc = "Abaza"]
            Abaza,

            #[doc = "Abkhazian"]
            Abkhazian,

            #[doc = "Acholi"]
            Acholi,

            #[doc = "Achi"]
            Achi,

            #[doc = "Adyghe"]
            Adyghe,

            #[doc = "Afrikaans"]
            Afrikaans,

            #[doc = "Afar"]
            Afar,

            #[doc = "Agaw"]
            Agaw,

            #[doc = "Aiton"]
            Aiton,

            #[doc = "Akan"]
            Akan,

            #[doc = "Alsatian"]
            Alsatian,

            #[doc = "Altai"]
            Altai,

            #[doc = "Amharic"]
            Amharic,

            #[doc = "Anglo-Saxon"]
            AngloSaxon,

            #[doc = "Phonetic transcription, Americanist"]
            AmericanistPhoneticNotation,

            #[doc = "Arabic"]
            Arabic,

            #[doc = "Aragonese"]
            Aragonese,

            #[doc = "Aari"]
            Aari,

            #[doc = "Rakhine"]
            Rakhine,

            #[doc = "Assamese"]
            Assamese,

            #[doc = "Asturian"]
            Asturian,

            #[doc = "Athapaskan"]
            Athapaskan,

            #[doc = "Avar"]
            Avar,

            #[doc = "Awadhi"]
            Awadhi,

            #[doc = "Aymara"]
            Aymara,

            #[doc = "Torki"]
            Torki,

            #[doc = "Azerbaijani"]
            Azerbaijani,

            #[doc = "Badaga"]
            Badaga,

            #[doc = "Banda"]
            Banda,

            #[doc = "Baghelkhandi"]
            Baghelkhandi,

            #[doc = "Balkar"]
            Balkar,

            #[doc = "Balinese"]
            Balinese,

            #[doc = "Bavarian"]
            Bavarian,

            #[doc = "Baul\u{e9}"]
            Baule,

            #[doc = "Batak Toba"]
            BatakToba,

            #[doc = "Berber"]
            Berber,

            #[doc = "Bench"]
            Bench,

            #[doc = "Bible Cree"]
            BibleCree,

            #[doc = "Bandjalang"]
            Bandjalang,

            #[doc = "Belarussian"]
            Belarussian,

            #[doc = "Bemba"]
            Bemba,

            #[doc = "Bengali"]
            Bengali,

            #[doc = "Haryanvi"]
            Haryanvi,

            #[doc = "Bagri"]
            Bagri,

            #[doc = "Bulgarian"]
            Bulgarian,

            #[doc = "Bhili"]
            Bhili,

            #[doc = "Bhojpuri"]
            Bhojpuri,

            #[doc = "Bikol"]
            Bikol,

            #[doc = "Bilen"]
            Bilen,

            #[doc = "Bislama"]
            Bislama,

            #[doc = "Kanauji"]
            Kanauji,

            #[doc = "Blackfoot"]
            Blackfoot,

            #[doc = "Baluchi"]
            Baluchi,

            #[doc = "Pa\u{2019}o Karen"]
            PaoKaren,

            #[doc = "Balante"]
            Balante,

            #[doc = "Balti"]
            Balti,

            #[doc = "Bambara (Bamanankan)"]
            Bambara,

            #[doc = "Bamileke"]
            Bamileke,

            #[doc = "Bosnian"]
            Bosnian,

            #[doc = "Bishnupriya Manipuri"]
            BishnupriyaManipuri,

            #[doc = "Breton"]
            Breton,

            #[doc = "Brahui"]
            Brahui,

            #[doc = "Braj Bhasha"]
            BrajBhasha,

            #[doc = "Burmese"]
            Burmese,

            #[doc = "Bodo"]
            Bodo,

            #[doc = "Bashkir"]
            Bashkir,

            #[doc = "Burushaski"]
            Burushaski,

            #[doc = "Beti"]
            Beti,

            #[doc = "Batak Simalungun"]
            BatakSimalungun,

            #[doc = "Bugis"]
            Bugis,

            #[doc = "Medumba"]
            Medumba,

            #[doc = "Kaqchikel"]
            Kaqchikel,

            #[doc = "Catalan"]
            Catalan,

            #[doc = "Zamboanga Chavacano"]
            ZamboangaChavacano,

            #[doc = "Cebuano"]
            Cebuano,

            #[doc = "Chechen"]
            Chechen,

            #[doc = "Chaha Gurage"]
            ChahaGurage,

            #[doc = "Chattisgarhi"]
            Chattisgarhi,

            #[doc = "Chichewa (Chewa, Nyanja)"]
            Chichewa,

            #[doc = "Chukchi"]
            Chukchi,

            #[doc = "Chuukese"]
            Chuukese,

            #[doc = "Choctaw"]
            Choctaw,

            #[doc = "Chipewyan"]
            Chipewyan,

            #[doc = "Cherokee"]
            Cherokee,

            #[doc = "Chamorro"]
            Chamorro,

            #[doc = "Chuvash"]
            Chuvash,

            #[doc = "Cheyenne"]
            Cheyenne,

            #[doc = "Chiga"]
            Chiga,

            #[doc = "Comorian"]
            Comorian,

            #[doc = "Coptic"]
            Coptic,

            #[doc = "Cornish"]
            Cornish,

            #[doc = "Corsican"]
            Corsican,

            #[doc = "Creoles"]
            Creoles,

            #[doc = "Cree"]
            Cree,

            #[doc = "Carrier"]
            Carrier,

            #[doc = "Crimean Tatar"]
            CrimeanTatar,

            #[doc = "Kashubian"]
            Kashubian,

            #[doc = "Church Slavonic"]
            ChurchSlavonic,

            #[doc = "Czech"]
            Czech,

            #[doc = "Chittagonian"]
            Chittagonian,

            #[doc = "San Blas Kuna"]
            SanBlasKuna,

            #[doc = "Danish"]
            Danish,

            #[doc = "Dargwa"]
            Dargwa,

            #[doc = "Dayi"]
            Dayi,

            #[doc = "Woods Cree"]
            WoodsCree,

            #[doc = "German"]
            German,

            #[doc = "Dogri"]
            Dogri,

            #[doc = "Dogri"]
            DogriMacrolanguage,

            #[doc = "Dhangu"]
            Dhangu,

            #[doc = "Divehi (Dhivehi, Maldivian)"]
            DivehiDeprecated,

            #[doc = "Dimli"]
            Dimli,

            #[doc = "Divehi (Dhivehi, Maldivian)"]
            Divehi,

            #[doc = "Zarma"]
            Zarma,

            #[doc = "Djambarrpuyngu"]
            Djambarrpuyngu,

            #[doc = "Dangme"]
            Dangme,

            #[doc = "Dan"]
            Dan,

            #[doc = "Dinka"]
            Dinka,

            #[doc = "Dari"]
            Dari,

            #[doc = "Dhuwal"]
            Dhuwal,

            #[doc = "Dungan"]
            Dungan,

            #[doc = "Dzongkha"]
            Dzongkha,

            #[doc = "Ebira"]
            Ebira,

            #[doc = "Eastern Cree"]
            EasternCree,

            #[doc = "Edo"]
            Edo,

            #[doc = "Efik"]
            Efik,

            #[doc = "Greek"]
            Greek,

            #[doc = "Eastern Maninkakan"]
            EasternManinkakan,

            #[doc = "English"]
            English,

            #[doc = "Erzya"]
            Erzya,

            #[doc = "Spanish"]
            Spanish,

            #[doc = "Central Yupik"]
            CentralYupik,

            #[doc = "Estonian"]
            Estonian,

            #[doc = "Basque"]
            Basque,

            #[doc = "Evenki"]
            Evenki,

            #[doc = "Even"]
            Even,

            #[doc = "Ewe"]
            Ewe,

            #[doc = "French Antillean"]
            FrenchAntillean,

            #[doc = "Fang"]
            Fang,

            #[doc = "Persian"]
            Persian,

            #[doc = "Fanti"]
            Fanti,

            #[doc = "Finnish"]
            Finnish,

            #[doc = "Fijian"]
            Fijian,

            #[doc = "Dutch (Flemish)"]
            DutchFlemish,

            #[doc = "Fe\u{2019}fe\u{2019}"]
            Fefe,

            #[doc = "Forest Nenets"]
            ForestNenets,

            #[doc = "Fon"]
            Fon,

            #[doc = "Faroese"]
            Faroese,

            #[doc = "French"]
            French,

            #[doc = "Cajun French"]
            CajunFrench,

            #[doc = "Frisian"]
            Frisian,

            #[doc = "Friulian"]
            Friulian,

            #[doc = "Arpitan"]
            Arpitan,

            #[doc = "Futa"]
            Futa,

            #[doc = "Fulah"]
            Fulah,

            #[doc = "Nigerian Fulfulde"]
            NigerianFulfulde,

            #[doc = "Ga"]
            Ga,

            #[doc = "Scottish Gaelic (Gaelic)"]
            ScottishGaelic,

            #[doc = "Gagauz"]
            Gagauz,

            #[doc = "Galician"]
            Galician,

            #[doc = "Garshuni"]
            Garshuni,

            #[doc = "Garhwali"]
            Garhwali,

            #[doc = "Ge\u{2019}ez"]
            Geez,

            #[doc = "Githabul"]
            Githabul,

            #[doc = "Gilyak"]
            Gilyak,

            #[doc = "Kiribati (Gilbertese)"]
            Kiribati,

            #[doc = "Kpelle (Guinea)"]
            KpelleGuinea,

            #[doc = "Gilaki"]
            Gilaki,

            #[doc = "Gumuz"]
            Gumuz,

            #[doc = "Gumatj"]
            Gumatj,

            #[doc = "Gogo"]
            Gogo,

            #[doc = "Gondi"]
            Gondi,

            #[doc = "Greenlandic"]
            Greenlandic,

            #[doc = "Garo"]
            Garo,

            #[doc = "Guarani"]
            Guarani,

            #[doc = "Wayuu"]
            Wayuu,

            #[doc = "Gupapuyngu"]
            Gupapuyngu,

            #[doc = "Gujarati"]
            Gujarati,

            #[doc = "Gusii"]
            Gusii,

            #[doc = "Haitian (Haitian Creole)"]
            Haitian,

            #[doc = "Halam"]
            Halam,

            #[doc = "Harauti"]
            Harauti,

            #[doc = "Hausa"]
            Hausa,

            #[doc = "Hawaiian"]
            Hawaiian,

            #[doc = "Haya"]
            Haya,

            #[doc = "Hazaragi"]
            Hazaragi,

            #[doc = "Hammer-Banna"]
            HammerBanna,

            #[doc = "Herero"]
            Herero,

            #[doc = "Hiligaynon"]
            Hiligaynon,

            #[doc = "Hindi"]
            Hindi,

            #[doc = "High Mari"]
            HighMari,

            #[doc = "Hmong"]
            Hmong,

            #[doc = "Hiri Motu"]
            HiriMotu,

            #[doc = "Hindko"]
            Hindko,

            #[doc = "Ho"]
            Ho,

            #[doc = "Harari"]
            Harari,

            #[doc = "Croatian"]
            Croatian,

            #[doc = "Hungarian"]
            Hungarian,

            #[doc = "Armenian"]
            Armenian,

            #[doc = "Armenian East"]
            ArmenianEast,

            #[doc = "Iban"]
            Iban,

            #[doc = "Ibibio"]
            Ibibio,

            #[doc = "Igbo"]
            Igbo,

            #[doc = "Ijo languages"]
            Ijolanguages,

            #[doc = "Ido"]
            Ido,

            #[doc = "Interlingue"]
            Interlingue,

            #[doc = "Ilokano"]
            Ilokano,

            #[doc = "Interlingua"]
            Interlingua,

            #[doc = "Indonesian"]
            Indonesian,

            #[doc = "Ingush"]
            Ingush,

            #[doc = "Inuktitut"]
            Inuktitut,

            #[doc = "Inupiat"]
            Inupiat,

            #[doc = "Phonetic transcription, IPA"]
            InternationalPhoneticAlphabet,

            #[doc = "Irish"]
            Irish,

            #[doc = "Irish Traditional"]
            IrishTraditional,

            #[doc = "Icelandic"]
            Icelandic,

            #[doc = "Inari Sami"]
            InariSami,

            #[doc = "Italian"]
            Italian,

            #[doc = "Hebrew"]
            Hebrew,

            #[doc = "Jamaican Creole"]
            JamaicanCreole,

            #[doc = "Japanese"]
            Japanese,

            #[doc = "Javanese"]
            Javanese,

            #[doc = "Lojban"]
            Lojban,

            #[doc = "Krymchak"]
            Krymchak,

            #[doc = "Yiddish"]
            Yiddish,

            #[doc = "Ladino"]
            Ladino,

            #[doc = "Jula"]
            Jula,

            #[doc = "Kabardian"]
            Kabardian,

            #[doc = "Kabyle"]
            Kabyle,

            #[doc = "Kachchi"]
            Kachchi,

            #[doc = "Kalenjin"]
            Kalenjin,

            #[doc = "Kannada"]
            Kannada,

            #[doc = "Karachay"]
            Karachay,

            #[doc = "Georgian"]
            Georgian,

            #[doc = "Kazakh"]
            Kazakh,

            #[doc = "Makonde"]
            Makonde,

            #[doc = "Kabuverdianu (Crioulo)"]
            Kabuverdianu,

            #[doc = "Kebena"]
            Kebena,

            #[doc = "Kekchi"]
            Kekchi,

            #[doc = "Khutsuri Georgian"]
            KhutsuriGeorgian,

            #[doc = "Khakass"]
            Khakass,

            #[doc = "Khanty-Kazim"]
            KhantyKazim,

            #[doc = "Khmer"]
            Khmer,

            #[doc = "Khanty-Shurishkar"]
            KhantyShurishkar,

            #[doc = "Khamti Shan"]
            KhamtiShan,

            #[doc = "Khanty-Vakhi"]
            KhantyVakhi,

            #[doc = "Khowar"]
            Khowar,

            #[doc = "Kikuyu (Gikuyu)"]
            Kikuyu,

            #[doc = "Kirghiz (Kyrgyz)"]
            Kirghiz,

            #[doc = "Kisii"]
            Kisii,

            #[doc = "Kirmanjki"]
            Kirmanjki,

            #[doc = "Southern Kiwai"]
            SouthernKiwai,

            #[doc = "Eastern Pwo Karen"]
            EasternPwoKaren,

            #[doc = "Kokni"]
            Kokni,

            #[doc = "Kalmyk"]
            Kalmyk,

            #[doc = "Kamba"]
            Kamba,

            #[doc = "Kumaoni"]
            Kumaoni,

            #[doc = "Komo"]
            Komo,

            #[doc = "Komso"]
            Komso,

            #[doc = "Khorasani Turkic"]
            KhorasaniTurkic,

            #[doc = "Kanuri"]
            Kanuri,

            #[doc = "Kodagu"]
            Kodagu,

            #[doc = "Korean Old Hangul"]
            KoreanOldHangul,

            #[doc = "Konkani"]
            Konkani,

            #[doc = "Kikongo"]
            Kikongo,

            #[doc = "Komi"]
            Komi,

            #[doc = "Kongo"]
            Kongo,

            #[doc = "Komi-Permyak"]
            KomiPermyak,

            #[doc = "Korean"]
            Korean,

            #[doc = "Kosraean"]
            Kosraean,

            #[doc = "Komi-Zyrian"]
            KomiZyrian,

            #[doc = "Kpelle"]
            Kpelle,

            #[doc = "Krio"]
            Krio,

            #[doc = "Karakalpak"]
            Karakalpak,

            #[doc = "Karelian"]
            Karelian,

            #[doc = "Karaim"]
            Karaim,

            #[doc = "Karen"]
            Karen,

            #[doc = "Koorete"]
            Koorete,

            #[doc = "Kashmiri"]
            Kashmiri,

            #[doc = "Ripuarian"]
            Ripuarian,

            #[doc = "Khasi"]
            Khasi,

            #[doc = "Kildin Sami"]
            KildinSami,

            #[doc = "S\u{2019}gaw Karen"]
            SgawKaren,

            #[doc = "Kuanyama"]
            Kuanyama,

            #[doc = "Kui"]
            Kui,

            #[doc = "Kulvi"]
            Kulvi,

            #[doc = "Kumyk"]
            Kumyk,

            #[doc = "Kurdish"]
            Kurdish,

            #[doc = "Kurukh"]
            Kurukh,

            #[doc = "Kuy"]
            Kuy,

            #[doc = "Koryak"]
            Koryak,

            #[doc = "Western Kayah"]
            WesternKayah,

            #[doc = "Ladin"]
            Ladin,

            #[doc = "Lahuli"]
            Lahuli,

            #[doc = "Lak"]
            Lak,

            #[doc = "Lambani"]
            Lambani,

            #[doc = "Lao"]
            Lao,

            #[doc = "Latin"]
            Latin,

            #[doc = "Laz"]
            Laz,

            #[doc = "L-Cree"]
            LCree,

            #[doc = "Ladakhi"]
            Ladakhi,

            #[doc = "Lezgi"]
            Lezgi,

            #[doc = "Ligurian"]
            Ligurian,

            #[doc = "Limburgish"]
            Limburgish,

            #[doc = "Lingala"]
            Lingala,

            #[doc = "Lisu"]
            Lisu,

            #[doc = "Lampung"]
            Lampung,

            #[doc = "Laki"]
            Laki,

            #[doc = "Low Mari"]
            LowMari,

            #[doc = "Limbu"]
            Limbu,

            #[doc = "Lombard"]
            Lombard,

            #[doc = "Lomwe"]
            Lomwe,

            #[doc = "Loma"]
            Loma,

            #[doc = "Luri"]
            Luri,

            #[doc = "Lower Sorbian"]
            LowerSorbian,

            #[doc = "Lule Sami"]
            LuleSami,

            #[doc = "Lithuanian"]
            Lithuanian,

            #[doc = "Luxembourgish"]
            Luxembourgish,

            #[doc = "Luba-Lulua"]
            LubaLulua,

            #[doc = "Luba-Katanga"]
            LubaKatanga,

            #[doc = "Ganda"]
            Ganda,

            #[doc = "Luyia"]
            Luyia,

            #[doc = "Luo"]
            Luo,

            #[doc = "Latvian"]
            Latvian,

            #[doc = "Madura"]
            Madura,

            #[doc = "Magahi"]
            Magahi,

            #[doc = "Marshallese"]
            Marshallese,

            #[doc = "Majang"]
            Majang,

            #[doc = "Makhuwa"]
            Makhuwa,

            #[doc = "Malayalam"]
            Malayalam,

            #[doc = "Mam"]
            Mam,

            #[doc = "Mansi"]
            Mansi,

            #[doc = "Mapudungun"]
            Mapudungun,

            #[doc = "Marathi"]
            Marathi,

            #[doc = "Marwari"]
            Marwari,

            #[doc = "Mbundu"]
            Mbundu,

            #[doc = "Mbo"]
            Mbo,

            #[doc = "Manchu"]
            Manchu,

            #[doc = "Moose Cree"]
            MooseCree,

            #[doc = "Mende"]
            Mende,

            #[doc = "Mandar"]
            Mandar,

            #[doc = "Me\u{2019}en"]
            Meen,

            #[doc = "Meru"]
            Meru,

            #[doc = "Morisyen"]
            Morisyen,

            #[doc = "Minangkabau"]
            Minangkabau,

            #[doc = "Mizo"]
            Mizo,

            #[doc = "Macedonian"]
            Macedonian,

            #[doc = "Makasar"]
            Makasar,

            #[doc = "Kituba"]
            Kituba,

            #[doc = "Male"]
            Male,

            #[doc = "Malagasy"]
            Malagasy,

            #[doc = "Malinke"]
            Malinke,

            #[doc = "Malayalam Reformed"]
            MalayalamReformed,

            #[doc = "Malay"]
            Malay,

            #[doc = "Mandinka"]
            Mandinka,

            #[doc = "Mongolian"]
            Mongolian,

            #[doc = "Manipuri"]
            Manipuri,

            #[doc = "Maninka"]
            Maninka,

            #[doc = "Manx"]
            Manx,

            #[doc = "Mohawk"]
            Mohawk,

            #[doc = "Moksha"]
            Moksha,

            #[doc = "Moldavian"]
            Moldavian,

            #[doc = "Mon"]
            Mon,

            #[doc = "Moroccan"]
            Moroccan,

            #[doc = "Mossi"]
            Mossi,

            #[doc = "Maori"]
            Maori,

            #[doc = "Maithili"]
            Maithili,

            #[doc = "Maltese"]
            Maltese,

            #[doc = "Mundari"]
            Mundari,

            #[doc = "Muscogee"]
            Muscogee,

            #[doc = "Mirandese"]
            Mirandese,

            #[doc = "Hmong Daw"]
            HmongDaw,

            #[doc = "Mayan"]
            Mayan,

            #[doc = "Mazanderani"]
            Mazanderani,

            #[doc = "Naga-Assamese"]
            NagaAssamese,

            #[doc = "Nahuatl"]
            Nahuatl,

            #[doc = "Nanai"]
            Nanai,

            #[doc = "Neapolitan"]
            Neapolitan,

            #[doc = "Naskapi"]
            Naskapi,

            #[doc = "Nauruan"]
            Nauruan,

            #[doc = "Navajo"]
            Navajo,

            #[doc = "N-Cree"]
            NCree,

            #[doc = "Ndebele"]
            Ndebele,

            #[doc = "Ndau"]
            Ndau,

            #[doc = "Ndonga"]
            Ndonga,

            #[doc = "Low Saxon"]
            LowSaxon,

            #[doc = "Nepali"]
            Nepali,

            #[doc = "Newari"]
            Newari,

            #[doc = "Ngbaka"]
            Ngbaka,

            #[doc = "Nagari"]
            Nagari,

            #[doc = "Norway House Cree"]
            NorwayHouseCree,

            #[doc = "Nisi"]
            Nisi,

            #[doc = "Niuean"]
            Niuean,

            #[doc = "Nyankole"]
            Nyankole,

            #[doc = "N\u{2019}Ko"]
            NKo,

            #[doc = "Dutch"]
            Dutch,

            #[doc = "Nimadi"]
            Nimadi,

            #[doc = "Nogai"]
            Nogai,

            #[doc = "Norwegian"]
            Norwegian,

            #[doc = "Novial"]
            Novial,

            #[doc = "Northern Sami"]
            NorthernSami,

            #[doc = "Sotho, Northern"]
            NorthernSotho,

            #[doc = "Northern Tai"]
            NorthernTai,

            #[doc = "Esperanto"]
            Esperanto,

            #[doc = "Nyamwezi"]
            Nyamwezi,

            #[doc = "Norwegian Nynorsk (Nynorsk, Norwegian)"]
            NorwegianNynorsk,

            #[doc = "Mbembe Tigon"]
            MbembeTigon,

            #[doc = "Occitan"]
            Occitan,

            #[doc = "Oji-Cree"]
            OjiCree,

            #[doc = "Ojibway"]
            Ojibway,

            #[doc = "Odia (formerly Oriya)"]
            Odia,

            #[doc = "Oromo"]
            Oromo,

            #[doc = "Ossetian"]
            Ossetian,

            #[doc = "Palestinian Aramaic"]
            PalestinianAramaic,

            #[doc = "Pangasinan"]
            Pangasinan,

            #[doc = "Pali"]
            Pali,

            #[doc = "Pampangan"]
            Pampangan,

            #[doc = "Punjabi"]
            Punjabi,

            #[doc = "Palpa"]
            Palpa,

            #[doc = "Papiamentu"]
            Papiamentu,

            #[doc = "Pashto"]
            Pashto,

            #[doc = "Palauan"]
            Palauan,

            #[doc = "Bouyei"]
            Bouyei,

            #[doc = "Picard"]
            Picard,

            #[doc = "Pennsylvania German"]
            PennsylvaniaGerman,

            #[doc = "Polytonic Greek"]
            PolytonicGreek,

            #[doc = "Phake"]
            Phake,

            #[doc = "Norfolk"]
            Norfolk,

            #[doc = "Filipino"]
            Filipino,

            #[doc = "Palaung"]
            Palaung,

            #[doc = "Polish"]
            Polish,

            #[doc = "Piemontese"]
            Piemontese,

            #[doc = "Western Panjabi"]
            WesternPanjabi,

            #[doc = "Pocomchi"]
            Pocomchi,

            #[doc = "Pohnpeian"]
            Pohnpeian,

            #[doc = "Provencal"]
            Provencal,

            #[doc = "Portuguese"]
            Portuguese,

            #[doc = "Western Pwo Karen"]
            WesternPwoKaren,

            #[doc = "Chin"]
            Chin,

            #[doc = "K\u{2019}iche\u{2019}"]
            Kiche,

            #[doc = "Quechua (Bolivia)"]
            QuechuaBolivia,

            #[doc = "Quechua"]
            Quechua,

            #[doc = "Quechua (Ecuador)"]
            QuechuaEcuador,

            #[doc = "Quechua (Peru)"]
            QuechuaPeru,

            #[doc = "Rajasthani"]
            Rajasthani,

            #[doc = "Rarotongan"]
            Rarotongan,

            #[doc = "Russian Buriat"]
            RussianBuriat,

            #[doc = "R-Cree"]
            RCree,

            #[doc = "Rejang"]
            Rejang,

            #[doc = "Riang"]
            Riang,

            #[doc = "Tarifit"]
            Tarifit,

            #[doc = "Ritarungo"]
            Ritarungo,

            #[doc = "Arakwal"]
            Arakwal,

            #[doc = "Romansh"]
            Romansh,

            #[doc = "Vlax Romani"]
            VlaxRomani,

            #[doc = "Romanian"]
            Romanian,

            #[doc = "Romany"]
            Romany,

            #[doc = "Rusyn"]
            Rusyn,

            #[doc = "Rotuman"]
            Rotuman,

            #[doc = "Kinyarwanda"]
            Kinyarwanda,

            #[doc = "Rundi"]
            Rundi,

            #[doc = "Aromanian"]
            Aromanian,

            #[doc = "Russian"]
            Russian,

            #[doc = "Sadri"]
            Sadri,

            #[doc = "Sanskrit"]
            Sanskrit,

            #[doc = "Sasak"]
            Sasak,

            #[doc = "Santali"]
            Santali,

            #[doc = "Sayisi"]
            Sayisi,

            #[doc = "Sicilian"]
            Sicilian,

            #[doc = "Scots"]
            Scots,

            #[doc = "Sekota"]
            Sekota,

            #[doc = "Selkup"]
            Selkup,

            #[doc = "Old Irish"]
            OldIrish,

            #[doc = "Sango"]
            Sango,

            #[doc = "Samogitian"]
            Samogitian,

            #[doc = "Tachelhit"]
            Tachelhit,

            #[doc = "Shan"]
            Shan,

            #[doc = "Sibe"]
            Sibe,

            #[doc = "Sidamo"]
            Sidamo,

            #[doc = "Silte Gurage"]
            SilteGurage,

            #[doc = "Skolt Sami"]
            SkoltSami,

            #[doc = "Slovak"]
            Slovak,

            #[doc = "North Slavey"]
            NorthSlavey,

            #[doc = "Slavey"]
            Slavey,

            #[doc = "Slovenian"]
            Slovenian,

            #[doc = "Somali"]
            Somali,

            #[doc = "Samoan"]
            Samoan,

            #[doc = "Sena"]
            Sena,

            #[doc = "Shona"]
            Shona,

            #[doc = "Sindhi"]
            Sindhi,

            #[doc = "Sinhala (Sinhalese)"]
            SinhalaSinhalese,

            #[doc = "Soninke"]
            Soninke,

            #[doc = "Sodo Gurage"]
            SodoGurage,

            #[doc = "Songe"]
            Songe,

            #[doc = "Sotho, Southern"]
            SouthernSotho,

            #[doc = "Albanian"]
            Albanian,

            #[doc = "Serbian"]
            Serbian,

            #[doc = "Sardinian"]
            Sardinian,

            #[doc = "Saraiki"]
            Saraiki,

            #[doc = "Serer"]
            Serer,

            #[doc = "South Slavey"]
            SouthSlavey,

            #[doc = "Southern Sami"]
            SouthernSami,

            #[doc = "Saterland Frisian"]
            SaterlandFrisian,

            #[doc = "Sukuma"]
            Sukuma,

            #[doc = "Sundanese"]
            Sundanese,

            #[doc = "Suri"]
            Suri,

            #[doc = "Svan"]
            Svan,

            #[doc = "Swedish"]
            Swedish,

            #[doc = "Swadaya Aramaic"]
            SwadayaAramaic,

            #[doc = "Swahili"]
            Swahili,

            #[doc = "Swati"]
            Swati,

            #[doc = "Sutu"]
            Sutu,

            #[doc = "Upper Saxon"]
            UpperSaxon,

            #[doc = "Sylheti"]
            Sylheti,

            #[doc = "Syriac"]
            Syriac,

            #[doc = "Silesian"]
            Silesian,

            #[doc = "Tabasaran"]
            Tabasaran,

            #[doc = "Tajiki"]
            Tajiki,

            #[doc = "Tamil"]
            Tamil,

            #[doc = "Tatar"]
            Tatar,

            #[doc = "TH-Cree"]
            THCree,

            #[doc = "Dehong Dai"]
            DehongDai,

            #[doc = "Telugu"]
            Telugu,

            #[doc = "Tetum"]
            Tetum,

            #[doc = "Tagalog"]
            Tagalog,

            #[doc = "Tongan"]
            Tongan,

            #[doc = "Tigre"]
            Tigre,

            #[doc = "Tigrinya"]
            Tigrinya,

            #[doc = "Thai"]
            Thai,

            #[doc = "Tahitian"]
            Tahitian,

            #[doc = "Tibetan"]
            Tibetan,

            #[doc = "Tiv"]
            Tiv,

            #[doc = "Turkmen"]
            Turkmen,

            #[doc = "Tamashek"]
            Tamashek,

            #[doc = "Temne"]
            Temne,

            #[doc = "Tswana"]
            Tswana,

            #[doc = "Tundra Nenets"]
            TundraNenets,

            #[doc = "Tonga"]
            Tonga,

            #[doc = "Todo"]
            Todo,

            #[doc = "Toma"]
            Toma,

            #[doc = "Tok Pisin"]
            TokPisin,

            #[doc = "Turkish"]
            Turkish,

            #[doc = "Tsonga"]
            Tsonga,

            #[doc = "Turoyo Aramaic"]
            TuroyoAramaic,

            #[doc = "Tulu"]
            Tulu,

            #[doc = "Tumbuka"]
            Tumbuka,

            #[doc = "Tuvin"]
            Tuvin,

            #[doc = "Tuvalu"]
            Tuvalu,

            #[doc = "Twi"]
            Twi,

            #[doc = "T\u{e0}y"]
            Tay,

            #[doc = "Tamazight"]
            Tamazight,

            #[doc = "Tzotzil"]
            Tzotzil,

            #[doc = "Udmurt"]
            Udmurt,

            #[doc = "Ukrainian"]
            Ukrainian,

            #[doc = "Umbundu"]
            Umbundu,

            #[doc = "Urdu"]
            Urdu,

            #[doc = "Upper Sorbian"]
            UpperSorbian,

            #[doc = "Uyghur"]
            Uyghur,

            #[doc = "Uzbek"]
            Uzbek,

            #[doc = "Venetian"]
            Venetian,

            #[doc = "Venda"]
            Venda,

            #[doc = "Vietnamese"]
            Vietnamese,

            #[doc = "Volap\u{fc}k"]
            Volapuk,

            #[doc = "V\u{f5}ro"]
            Voro,

            #[doc = "Wa"]
            Wa,

            #[doc = "Wagdi"]
            Wagdi,

            #[doc = "Waray-Waray"]
            WarayWaray,

            #[doc = "West-Cree"]
            WestCree,

            #[doc = "Welsh"]
            Welsh,

            #[doc = "Walloon"]
            Walloon,

            #[doc = "Wolof"]
            Wolof,

            #[doc = "Mewati"]
            Mewati,

            #[doc = "L\u{fc}"]
            Lu,

            #[doc = "Xhosa"]
            Xhosa,

            #[doc = "Minjangbal"]
            Minjangbal,

            #[doc = "Soga"]
            Soga,

            #[doc = "Kpelle (Liberia)"]
            KpelleLiberia,

            #[doc = "Sakha"]
            Sakha,

            #[doc = "Yao"]
            Yao,

            #[doc = "Yapese"]
            Yapese,

            #[doc = "Yoruba"]
            Yoruba,

            #[doc = "Y-Cree"]
            YCree,

            #[doc = "Yi Classic"]
            YiClassic,

            #[doc = "Yi Modern"]
            YiModern,

            #[doc = "Zealandic"]
            Zealandic,

            #[doc = "Standard Morrocan Tamazigh"]
            StandardMorrocanTamazigh,

            #[doc = "Zhuang"]
            Zhuang,

            #[doc = "Chinese, Hong Kong SAR"]
            Chinese,

            #[doc = "Chinese Phonetic"]
            ChinesePhonetic,

            #[doc = "Chinese Simplified"]
            ChineseSimplified,

            #[doc = "Chinese Traditional"]
            ChineseTraditional,

            #[doc = "Zande"]
            Zande,

            #[doc = "Zulu"]
            Zulu,

            #[doc = "Zazaki"]
            Zazaki,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Language {
            #[inline]
            fn clone(&self) -> Language { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Language { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Language {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&Language::Abaza,) => {
                        let mut builder = __arg_0.debug_tuple("Abaza");
                        builder.finish()
                    }
                    (&Language::Abkhazian,) => {
                        let mut builder = __arg_0.debug_tuple("Abkhazian");
                        builder.finish()
                    }
                    (&Language::Acholi,) => {
                        let mut builder = __arg_0.debug_tuple("Acholi");
                        builder.finish()
                    }
                    (&Language::Achi,) => {
                        let mut builder = __arg_0.debug_tuple("Achi");
                        builder.finish()
                    }
                    (&Language::Adyghe,) => {
                        let mut builder = __arg_0.debug_tuple("Adyghe");
                        builder.finish()
                    }
                    (&Language::Afrikaans,) => {
                        let mut builder = __arg_0.debug_tuple("Afrikaans");
                        builder.finish()
                    }
                    (&Language::Afar,) => {
                        let mut builder = __arg_0.debug_tuple("Afar");
                        builder.finish()
                    }
                    (&Language::Agaw,) => {
                        let mut builder = __arg_0.debug_tuple("Agaw");
                        builder.finish()
                    }
                    (&Language::Aiton,) => {
                        let mut builder = __arg_0.debug_tuple("Aiton");
                        builder.finish()
                    }
                    (&Language::Akan,) => {
                        let mut builder = __arg_0.debug_tuple("Akan");
                        builder.finish()
                    }
                    (&Language::Alsatian,) => {
                        let mut builder = __arg_0.debug_tuple("Alsatian");
                        builder.finish()
                    }
                    (&Language::Altai,) => {
                        let mut builder = __arg_0.debug_tuple("Altai");
                        builder.finish()
                    }
                    (&Language::Amharic,) => {
                        let mut builder = __arg_0.debug_tuple("Amharic");
                        builder.finish()
                    }
                    (&Language::AngloSaxon,) => {
                        let mut builder = __arg_0.debug_tuple("AngloSaxon");
                        builder.finish()
                    }
                    (&Language::AmericanistPhoneticNotation,) => {
                        let mut builder =
                            __arg_0.debug_tuple("AmericanistPhoneticNotation");
                        builder.finish()
                    }
                    (&Language::Arabic,) => {
                        let mut builder = __arg_0.debug_tuple("Arabic");
                        builder.finish()
                    }
                    (&Language::Aragonese,) => {
                        let mut builder = __arg_0.debug_tuple("Aragonese");
                        builder.finish()
                    }
                    (&Language::Aari,) => {
                        let mut builder = __arg_0.debug_tuple("Aari");
                        builder.finish()
                    }
                    (&Language::Rakhine,) => {
                        let mut builder = __arg_0.debug_tuple("Rakhine");
                        builder.finish()
                    }
                    (&Language::Assamese,) => {
                        let mut builder = __arg_0.debug_tuple("Assamese");
                        builder.finish()
                    }
                    (&Language::Asturian,) => {
                        let mut builder = __arg_0.debug_tuple("Asturian");
                        builder.finish()
                    }
                    (&Language::Athapaskan,) => {
                        let mut builder = __arg_0.debug_tuple("Athapaskan");
                        builder.finish()
                    }
                    (&Language::Avar,) => {
                        let mut builder = __arg_0.debug_tuple("Avar");
                        builder.finish()
                    }
                    (&Language::Awadhi,) => {
                        let mut builder = __arg_0.debug_tuple("Awadhi");
                        builder.finish()
                    }
                    (&Language::Aymara,) => {
                        let mut builder = __arg_0.debug_tuple("Aymara");
                        builder.finish()
                    }
                    (&Language::Torki,) => {
                        let mut builder = __arg_0.debug_tuple("Torki");
                        builder.finish()
                    }
                    (&Language::Azerbaijani,) => {
                        let mut builder = __arg_0.debug_tuple("Azerbaijani");
                        builder.finish()
                    }
                    (&Language::Badaga,) => {
                        let mut builder = __arg_0.debug_tuple("Badaga");
                        builder.finish()
                    }
                    (&Language::Banda,) => {
                        let mut builder = __arg_0.debug_tuple("Banda");
                        builder.finish()
                    }
                    (&Language::Baghelkhandi,) => {
                        let mut builder = __arg_0.debug_tuple("Baghelkhandi");
                        builder.finish()
                    }
                    (&Language::Balkar,) => {
                        let mut builder = __arg_0.debug_tuple("Balkar");
                        builder.finish()
                    }
                    (&Language::Balinese,) => {
                        let mut builder = __arg_0.debug_tuple("Balinese");
                        builder.finish()
                    }
                    (&Language::Bavarian,) => {
                        let mut builder = __arg_0.debug_tuple("Bavarian");
                        builder.finish()
                    }
                    (&Language::Baule,) => {
                        let mut builder = __arg_0.debug_tuple("Baule");
                        builder.finish()
                    }
                    (&Language::BatakToba,) => {
                        let mut builder = __arg_0.debug_tuple("BatakToba");
                        builder.finish()
                    }
                    (&Language::Berber,) => {
                        let mut builder = __arg_0.debug_tuple("Berber");
                        builder.finish()
                    }
                    (&Language::Bench,) => {
                        let mut builder = __arg_0.debug_tuple("Bench");
                        builder.finish()
                    }
                    (&Language::BibleCree,) => {
                        let mut builder = __arg_0.debug_tuple("BibleCree");
                        builder.finish()
                    }
                    (&Language::Bandjalang,) => {
                        let mut builder = __arg_0.debug_tuple("Bandjalang");
                        builder.finish()
                    }
                    (&Language::Belarussian,) => {
                        let mut builder = __arg_0.debug_tuple("Belarussian");
                        builder.finish()
                    }
                    (&Language::Bemba,) => {
                        let mut builder = __arg_0.debug_tuple("Bemba");
                        builder.finish()
                    }
                    (&Language::Bengali,) => {
                        let mut builder = __arg_0.debug_tuple("Bengali");
                        builder.finish()
                    }
                    (&Language::Haryanvi,) => {
                        let mut builder = __arg_0.debug_tuple("Haryanvi");
                        builder.finish()
                    }
                    (&Language::Bagri,) => {
                        let mut builder = __arg_0.debug_tuple("Bagri");
                        builder.finish()
                    }
                    (&Language::Bulgarian,) => {
                        let mut builder = __arg_0.debug_tuple("Bulgarian");
                        builder.finish()
                    }
                    (&Language::Bhili,) => {
                        let mut builder = __arg_0.debug_tuple("Bhili");
                        builder.finish()
                    }
                    (&Language::Bhojpuri,) => {
                        let mut builder = __arg_0.debug_tuple("Bhojpuri");
                        builder.finish()
                    }
                    (&Language::Bikol,) => {
                        let mut builder = __arg_0.debug_tuple("Bikol");
                        builder.finish()
                    }
                    (&Language::Bilen,) => {
                        let mut builder = __arg_0.debug_tuple("Bilen");
                        builder.finish()
                    }
                    (&Language::Bislama,) => {
                        let mut builder = __arg_0.debug_tuple("Bislama");
                        builder.finish()
                    }
                    (&Language::Kanauji,) => {
                        let mut builder = __arg_0.debug_tuple("Kanauji");
                        builder.finish()
                    }
                    (&Language::Blackfoot,) => {
                        let mut builder = __arg_0.debug_tuple("Blackfoot");
                        builder.finish()
                    }
                    (&Language::Baluchi,) => {
                        let mut builder = __arg_0.debug_tuple("Baluchi");
                        builder.finish()
                    }
                    (&Language::PaoKaren,) => {
                        let mut builder = __arg_0.debug_tuple("PaoKaren");
                        builder.finish()
                    }
                    (&Language::Balante,) => {
                        let mut builder = __arg_0.debug_tuple("Balante");
                        builder.finish()
                    }
                    (&Language::Balti,) => {
                        let mut builder = __arg_0.debug_tuple("Balti");
                        builder.finish()
                    }
                    (&Language::Bambara,) => {
                        let mut builder = __arg_0.debug_tuple("Bambara");
                        builder.finish()
                    }
                    (&Language::Bamileke,) => {
                        let mut builder = __arg_0.debug_tuple("Bamileke");
                        builder.finish()
                    }
                    (&Language::Bosnian,) => {
                        let mut builder = __arg_0.debug_tuple("Bosnian");
                        builder.finish()
                    }
                    (&Language::BishnupriyaManipuri,) => {
                        let mut builder =
                            __arg_0.debug_tuple("BishnupriyaManipuri");
                        builder.finish()
                    }
                    (&Language::Breton,) => {
                        let mut builder = __arg_0.debug_tuple("Breton");
                        builder.finish()
                    }
                    (&Language::Brahui,) => {
                        let mut builder = __arg_0.debug_tuple("Brahui");
                        builder.finish()
                    }
                    (&Language::BrajBhasha,) => {
                        let mut builder = __arg_0.debug_tuple("BrajBhasha");
                        builder.finish()
                    }
                    (&Language::Burmese,) => {
                        let mut builder = __arg_0.debug_tuple("Burmese");
                        builder.finish()
                    }
                    (&Language::Bodo,) => {
                        let mut builder = __arg_0.debug_tuple("Bodo");
                        builder.finish()
                    }
                    (&Language::Bashkir,) => {
                        let mut builder = __arg_0.debug_tuple("Bashkir");
                        builder.finish()
                    }
                    (&Language::Burushaski,) => {
                        let mut builder = __arg_0.debug_tuple("Burushaski");
                        builder.finish()
                    }
                    (&Language::Beti,) => {
                        let mut builder = __arg_0.debug_tuple("Beti");
                        builder.finish()
                    }
                    (&Language::BatakSimalungun,) => {
                        let mut builder =
                            __arg_0.debug_tuple("BatakSimalungun");
                        builder.finish()
                    }
                    (&Language::Bugis,) => {
                        let mut builder = __arg_0.debug_tuple("Bugis");
                        builder.finish()
                    }
                    (&Language::Medumba,) => {
                        let mut builder = __arg_0.debug_tuple("Medumba");
                        builder.finish()
                    }
                    (&Language::Kaqchikel,) => {
                        let mut builder = __arg_0.debug_tuple("Kaqchikel");
                        builder.finish()
                    }
                    (&Language::Catalan,) => {
                        let mut builder = __arg_0.debug_tuple("Catalan");
                        builder.finish()
                    }
                    (&Language::ZamboangaChavacano,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ZamboangaChavacano");
                        builder.finish()
                    }
                    (&Language::Cebuano,) => {
                        let mut builder = __arg_0.debug_tuple("Cebuano");
                        builder.finish()
                    }
                    (&Language::Chechen,) => {
                        let mut builder = __arg_0.debug_tuple("Chechen");
                        builder.finish()
                    }
                    (&Language::ChahaGurage,) => {
                        let mut builder = __arg_0.debug_tuple("ChahaGurage");
                        builder.finish()
                    }
                    (&Language::Chattisgarhi,) => {
                        let mut builder = __arg_0.debug_tuple("Chattisgarhi");
                        builder.finish()
                    }
                    (&Language::Chichewa,) => {
                        let mut builder = __arg_0.debug_tuple("Chichewa");
                        builder.finish()
                    }
                    (&Language::Chukchi,) => {
                        let mut builder = __arg_0.debug_tuple("Chukchi");
                        builder.finish()
                    }
                    (&Language::Chuukese,) => {
                        let mut builder = __arg_0.debug_tuple("Chuukese");
                        builder.finish()
                    }
                    (&Language::Choctaw,) => {
                        let mut builder = __arg_0.debug_tuple("Choctaw");
                        builder.finish()
                    }
                    (&Language::Chipewyan,) => {
                        let mut builder = __arg_0.debug_tuple("Chipewyan");
                        builder.finish()
                    }
                    (&Language::Cherokee,) => {
                        let mut builder = __arg_0.debug_tuple("Cherokee");
                        builder.finish()
                    }
                    (&Language::Chamorro,) => {
                        let mut builder = __arg_0.debug_tuple("Chamorro");
                        builder.finish()
                    }
                    (&Language::Chuvash,) => {
                        let mut builder = __arg_0.debug_tuple("Chuvash");
                        builder.finish()
                    }
                    (&Language::Cheyenne,) => {
                        let mut builder = __arg_0.debug_tuple("Cheyenne");
                        builder.finish()
                    }
                    (&Language::Chiga,) => {
                        let mut builder = __arg_0.debug_tuple("Chiga");
                        builder.finish()
                    }
                    (&Language::Comorian,) => {
                        let mut builder = __arg_0.debug_tuple("Comorian");
                        builder.finish()
                    }
                    (&Language::Coptic,) => {
                        let mut builder = __arg_0.debug_tuple("Coptic");
                        builder.finish()
                    }
                    (&Language::Cornish,) => {
                        let mut builder = __arg_0.debug_tuple("Cornish");
                        builder.finish()
                    }
                    (&Language::Corsican,) => {
                        let mut builder = __arg_0.debug_tuple("Corsican");
                        builder.finish()
                    }
                    (&Language::Creoles,) => {
                        let mut builder = __arg_0.debug_tuple("Creoles");
                        builder.finish()
                    }
                    (&Language::Cree,) => {
                        let mut builder = __arg_0.debug_tuple("Cree");
                        builder.finish()
                    }
                    (&Language::Carrier,) => {
                        let mut builder = __arg_0.debug_tuple("Carrier");
                        builder.finish()
                    }
                    (&Language::CrimeanTatar,) => {
                        let mut builder = __arg_0.debug_tuple("CrimeanTatar");
                        builder.finish()
                    }
                    (&Language::Kashubian,) => {
                        let mut builder = __arg_0.debug_tuple("Kashubian");
                        builder.finish()
                    }
                    (&Language::ChurchSlavonic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ChurchSlavonic");
                        builder.finish()
                    }
                    (&Language::Czech,) => {
                        let mut builder = __arg_0.debug_tuple("Czech");
                        builder.finish()
                    }
                    (&Language::Chittagonian,) => {
                        let mut builder = __arg_0.debug_tuple("Chittagonian");
                        builder.finish()
                    }
                    (&Language::SanBlasKuna,) => {
                        let mut builder = __arg_0.debug_tuple("SanBlasKuna");
                        builder.finish()
                    }
                    (&Language::Danish,) => {
                        let mut builder = __arg_0.debug_tuple("Danish");
                        builder.finish()
                    }
                    (&Language::Dargwa,) => {
                        let mut builder = __arg_0.debug_tuple("Dargwa");
                        builder.finish()
                    }
                    (&Language::Dayi,) => {
                        let mut builder = __arg_0.debug_tuple("Dayi");
                        builder.finish()
                    }
                    (&Language::WoodsCree,) => {
                        let mut builder = __arg_0.debug_tuple("WoodsCree");
                        builder.finish()
                    }
                    (&Language::German,) => {
                        let mut builder = __arg_0.debug_tuple("German");
                        builder.finish()
                    }
                    (&Language::Dogri,) => {
                        let mut builder = __arg_0.debug_tuple("Dogri");
                        builder.finish()
                    }
                    (&Language::DogriMacrolanguage,) => {
                        let mut builder =
                            __arg_0.debug_tuple("DogriMacrolanguage");
                        builder.finish()
                    }
                    (&Language::Dhangu,) => {
                        let mut builder = __arg_0.debug_tuple("Dhangu");
                        builder.finish()
                    }
                    (&Language::DivehiDeprecated,) => {
                        let mut builder =
                            __arg_0.debug_tuple("DivehiDeprecated");
                        builder.finish()
                    }
                    (&Language::Dimli,) => {
                        let mut builder = __arg_0.debug_tuple("Dimli");
                        builder.finish()
                    }
                    (&Language::Divehi,) => {
                        let mut builder = __arg_0.debug_tuple("Divehi");
                        builder.finish()
                    }
                    (&Language::Zarma,) => {
                        let mut builder = __arg_0.debug_tuple("Zarma");
                        builder.finish()
                    }
                    (&Language::Djambarrpuyngu,) => {
                        let mut builder =
                            __arg_0.debug_tuple("Djambarrpuyngu");
                        builder.finish()
                    }
                    (&Language::Dangme,) => {
                        let mut builder = __arg_0.debug_tuple("Dangme");
                        builder.finish()
                    }
                    (&Language::Dan,) => {
                        let mut builder = __arg_0.debug_tuple("Dan");
                        builder.finish()
                    }
                    (&Language::Dinka,) => {
                        let mut builder = __arg_0.debug_tuple("Dinka");
                        builder.finish()
                    }
                    (&Language::Dari,) => {
                        let mut builder = __arg_0.debug_tuple("Dari");
                        builder.finish()
                    }
                    (&Language::Dhuwal,) => {
                        let mut builder = __arg_0.debug_tuple("Dhuwal");
                        builder.finish()
                    }
                    (&Language::Dungan,) => {
                        let mut builder = __arg_0.debug_tuple("Dungan");
                        builder.finish()
                    }
                    (&Language::Dzongkha,) => {
                        let mut builder = __arg_0.debug_tuple("Dzongkha");
                        builder.finish()
                    }
                    (&Language::Ebira,) => {
                        let mut builder = __arg_0.debug_tuple("Ebira");
                        builder.finish()
                    }
                    (&Language::EasternCree,) => {
                        let mut builder = __arg_0.debug_tuple("EasternCree");
                        builder.finish()
                    }
                    (&Language::Edo,) => {
                        let mut builder = __arg_0.debug_tuple("Edo");
                        builder.finish()
                    }
                    (&Language::Efik,) => {
                        let mut builder = __arg_0.debug_tuple("Efik");
                        builder.finish()
                    }
                    (&Language::Greek,) => {
                        let mut builder = __arg_0.debug_tuple("Greek");
                        builder.finish()
                    }
                    (&Language::EasternManinkakan,) => {
                        let mut builder =
                            __arg_0.debug_tuple("EasternManinkakan");
                        builder.finish()
                    }
                    (&Language::English,) => {
                        let mut builder = __arg_0.debug_tuple("English");
                        builder.finish()
                    }
                    (&Language::Erzya,) => {
                        let mut builder = __arg_0.debug_tuple("Erzya");
                        builder.finish()
                    }
                    (&Language::Spanish,) => {
                        let mut builder = __arg_0.debug_tuple("Spanish");
                        builder.finish()
                    }
                    (&Language::CentralYupik,) => {
                        let mut builder = __arg_0.debug_tuple("CentralYupik");
                        builder.finish()
                    }
                    (&Language::Estonian,) => {
                        let mut builder = __arg_0.debug_tuple("Estonian");
                        builder.finish()
                    }
                    (&Language::Basque,) => {
                        let mut builder = __arg_0.debug_tuple("Basque");
                        builder.finish()
                    }
                    (&Language::Evenki,) => {
                        let mut builder = __arg_0.debug_tuple("Evenki");
                        builder.finish()
                    }
                    (&Language::Even,) => {
                        let mut builder = __arg_0.debug_tuple("Even");
                        builder.finish()
                    }
                    (&Language::Ewe,) => {
                        let mut builder = __arg_0.debug_tuple("Ewe");
                        builder.finish()
                    }
                    (&Language::FrenchAntillean,) => {
                        let mut builder =
                            __arg_0.debug_tuple("FrenchAntillean");
                        builder.finish()
                    }
                    (&Language::Fang,) => {
                        let mut builder = __arg_0.debug_tuple("Fang");
                        builder.finish()
                    }
                    (&Language::Persian,) => {
                        let mut builder = __arg_0.debug_tuple("Persian");
                        builder.finish()
                    }
                    (&Language::Fanti,) => {
                        let mut builder = __arg_0.debug_tuple("Fanti");
                        builder.finish()
                    }
                    (&Language::Finnish,) => {
                        let mut builder = __arg_0.debug_tuple("Finnish");
                        builder.finish()
                    }
                    (&Language::Fijian,) => {
                        let mut builder = __arg_0.debug_tuple("Fijian");
                        builder.finish()
                    }
                    (&Language::DutchFlemish,) => {
                        let mut builder = __arg_0.debug_tuple("DutchFlemish");
                        builder.finish()
                    }
                    (&Language::Fefe,) => {
                        let mut builder = __arg_0.debug_tuple("Fefe");
                        builder.finish()
                    }
                    (&Language::ForestNenets,) => {
                        let mut builder = __arg_0.debug_tuple("ForestNenets");
                        builder.finish()
                    }
                    (&Language::Fon,) => {
                        let mut builder = __arg_0.debug_tuple("Fon");
                        builder.finish()
                    }
                    (&Language::Faroese,) => {
                        let mut builder = __arg_0.debug_tuple("Faroese");
                        builder.finish()
                    }
                    (&Language::French,) => {
                        let mut builder = __arg_0.debug_tuple("French");
                        builder.finish()
                    }
                    (&Language::CajunFrench,) => {
                        let mut builder = __arg_0.debug_tuple("CajunFrench");
                        builder.finish()
                    }
                    (&Language::Frisian,) => {
                        let mut builder = __arg_0.debug_tuple("Frisian");
                        builder.finish()
                    }
                    (&Language::Friulian,) => {
                        let mut builder = __arg_0.debug_tuple("Friulian");
                        builder.finish()
                    }
                    (&Language::Arpitan,) => {
                        let mut builder = __arg_0.debug_tuple("Arpitan");
                        builder.finish()
                    }
                    (&Language::Futa,) => {
                        let mut builder = __arg_0.debug_tuple("Futa");
                        builder.finish()
                    }
                    (&Language::Fulah,) => {
                        let mut builder = __arg_0.debug_tuple("Fulah");
                        builder.finish()
                    }
                    (&Language::NigerianFulfulde,) => {
                        let mut builder =
                            __arg_0.debug_tuple("NigerianFulfulde");
                        builder.finish()
                    }
                    (&Language::Ga,) => {
                        let mut builder = __arg_0.debug_tuple("Ga");
                        builder.finish()
                    }
                    (&Language::ScottishGaelic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ScottishGaelic");
                        builder.finish()
                    }
                    (&Language::Gagauz,) => {
                        let mut builder = __arg_0.debug_tuple("Gagauz");
                        builder.finish()
                    }
                    (&Language::Galician,) => {
                        let mut builder = __arg_0.debug_tuple("Galician");
                        builder.finish()
                    }
                    (&Language::Garshuni,) => {
                        let mut builder = __arg_0.debug_tuple("Garshuni");
                        builder.finish()
                    }
                    (&Language::Garhwali,) => {
                        let mut builder = __arg_0.debug_tuple("Garhwali");
                        builder.finish()
                    }
                    (&Language::Geez,) => {
                        let mut builder = __arg_0.debug_tuple("Geez");
                        builder.finish()
                    }
                    (&Language::Githabul,) => {
                        let mut builder = __arg_0.debug_tuple("Githabul");
                        builder.finish()
                    }
                    (&Language::Gilyak,) => {
                        let mut builder = __arg_0.debug_tuple("Gilyak");
                        builder.finish()
                    }
                    (&Language::Kiribati,) => {
                        let mut builder = __arg_0.debug_tuple("Kiribati");
                        builder.finish()
                    }
                    (&Language::KpelleGuinea,) => {
                        let mut builder = __arg_0.debug_tuple("KpelleGuinea");
                        builder.finish()
                    }
                    (&Language::Gilaki,) => {
                        let mut builder = __arg_0.debug_tuple("Gilaki");
                        builder.finish()
                    }
                    (&Language::Gumuz,) => {
                        let mut builder = __arg_0.debug_tuple("Gumuz");
                        builder.finish()
                    }
                    (&Language::Gumatj,) => {
                        let mut builder = __arg_0.debug_tuple("Gumatj");
                        builder.finish()
                    }
                    (&Language::Gogo,) => {
                        let mut builder = __arg_0.debug_tuple("Gogo");
                        builder.finish()
                    }
                    (&Language::Gondi,) => {
                        let mut builder = __arg_0.debug_tuple("Gondi");
                        builder.finish()
                    }
                    (&Language::Greenlandic,) => {
                        let mut builder = __arg_0.debug_tuple("Greenlandic");
                        builder.finish()
                    }
                    (&Language::Garo,) => {
                        let mut builder = __arg_0.debug_tuple("Garo");
                        builder.finish()
                    }
                    (&Language::Guarani,) => {
                        let mut builder = __arg_0.debug_tuple("Guarani");
                        builder.finish()
                    }
                    (&Language::Wayuu,) => {
                        let mut builder = __arg_0.debug_tuple("Wayuu");
                        builder.finish()
                    }
                    (&Language::Gupapuyngu,) => {
                        let mut builder = __arg_0.debug_tuple("Gupapuyngu");
                        builder.finish()
                    }
                    (&Language::Gujarati,) => {
                        let mut builder = __arg_0.debug_tuple("Gujarati");
                        builder.finish()
                    }
                    (&Language::Gusii,) => {
                        let mut builder = __arg_0.debug_tuple("Gusii");
                        builder.finish()
                    }
                    (&Language::Haitian,) => {
                        let mut builder = __arg_0.debug_tuple("Haitian");
                        builder.finish()
                    }
                    (&Language::Halam,) => {
                        let mut builder = __arg_0.debug_tuple("Halam");
                        builder.finish()
                    }
                    (&Language::Harauti,) => {
                        let mut builder = __arg_0.debug_tuple("Harauti");
                        builder.finish()
                    }
                    (&Language::Hausa,) => {
                        let mut builder = __arg_0.debug_tuple("Hausa");
                        builder.finish()
                    }
                    (&Language::Hawaiian,) => {
                        let mut builder = __arg_0.debug_tuple("Hawaiian");
                        builder.finish()
                    }
                    (&Language::Haya,) => {
                        let mut builder = __arg_0.debug_tuple("Haya");
                        builder.finish()
                    }
                    (&Language::Hazaragi,) => {
                        let mut builder = __arg_0.debug_tuple("Hazaragi");
                        builder.finish()
                    }
                    (&Language::HammerBanna,) => {
                        let mut builder = __arg_0.debug_tuple("HammerBanna");
                        builder.finish()
                    }
                    (&Language::Herero,) => {
                        let mut builder = __arg_0.debug_tuple("Herero");
                        builder.finish()
                    }
                    (&Language::Hiligaynon,) => {
                        let mut builder = __arg_0.debug_tuple("Hiligaynon");
                        builder.finish()
                    }
                    (&Language::Hindi,) => {
                        let mut builder = __arg_0.debug_tuple("Hindi");
                        builder.finish()
                    }
                    (&Language::HighMari,) => {
                        let mut builder = __arg_0.debug_tuple("HighMari");
                        builder.finish()
                    }
                    (&Language::Hmong,) => {
                        let mut builder = __arg_0.debug_tuple("Hmong");
                        builder.finish()
                    }
                    (&Language::HiriMotu,) => {
                        let mut builder = __arg_0.debug_tuple("HiriMotu");
                        builder.finish()
                    }
                    (&Language::Hindko,) => {
                        let mut builder = __arg_0.debug_tuple("Hindko");
                        builder.finish()
                    }
                    (&Language::Ho,) => {
                        let mut builder = __arg_0.debug_tuple("Ho");
                        builder.finish()
                    }
                    (&Language::Harari,) => {
                        let mut builder = __arg_0.debug_tuple("Harari");
                        builder.finish()
                    }
                    (&Language::Croatian,) => {
                        let mut builder = __arg_0.debug_tuple("Croatian");
                        builder.finish()
                    }
                    (&Language::Hungarian,) => {
                        let mut builder = __arg_0.debug_tuple("Hungarian");
                        builder.finish()
                    }
                    (&Language::Armenian,) => {
                        let mut builder = __arg_0.debug_tuple("Armenian");
                        builder.finish()
                    }
                    (&Language::ArmenianEast,) => {
                        let mut builder = __arg_0.debug_tuple("ArmenianEast");
                        builder.finish()
                    }
                    (&Language::Iban,) => {
                        let mut builder = __arg_0.debug_tuple("Iban");
                        builder.finish()
                    }
                    (&Language::Ibibio,) => {
                        let mut builder = __arg_0.debug_tuple("Ibibio");
                        builder.finish()
                    }
                    (&Language::Igbo,) => {
                        let mut builder = __arg_0.debug_tuple("Igbo");
                        builder.finish()
                    }
                    (&Language::Ijolanguages,) => {
                        let mut builder = __arg_0.debug_tuple("Ijolanguages");
                        builder.finish()
                    }
                    (&Language::Ido,) => {
                        let mut builder = __arg_0.debug_tuple("Ido");
                        builder.finish()
                    }
                    (&Language::Interlingue,) => {
                        let mut builder = __arg_0.debug_tuple("Interlingue");
                        builder.finish()
                    }
                    (&Language::Ilokano,) => {
                        let mut builder = __arg_0.debug_tuple("Ilokano");
                        builder.finish()
                    }
                    (&Language::Interlingua,) => {
                        let mut builder = __arg_0.debug_tuple("Interlingua");
                        builder.finish()
                    }
                    (&Language::Indonesian,) => {
                        let mut builder = __arg_0.debug_tuple("Indonesian");
                        builder.finish()
                    }
                    (&Language::Ingush,) => {
                        let mut builder = __arg_0.debug_tuple("Ingush");
                        builder.finish()
                    }
                    (&Language::Inuktitut,) => {
                        let mut builder = __arg_0.debug_tuple("Inuktitut");
                        builder.finish()
                    }
                    (&Language::Inupiat,) => {
                        let mut builder = __arg_0.debug_tuple("Inupiat");
                        builder.finish()
                    }
                    (&Language::InternationalPhoneticAlphabet,) => {
                        let mut builder =
                            __arg_0.debug_tuple("InternationalPhoneticAlphabet");
                        builder.finish()
                    }
                    (&Language::Irish,) => {
                        let mut builder = __arg_0.debug_tuple("Irish");
                        builder.finish()
                    }
                    (&Language::IrishTraditional,) => {
                        let mut builder =
                            __arg_0.debug_tuple("IrishTraditional");
                        builder.finish()
                    }
                    (&Language::Icelandic,) => {
                        let mut builder = __arg_0.debug_tuple("Icelandic");
                        builder.finish()
                    }
                    (&Language::InariSami,) => {
                        let mut builder = __arg_0.debug_tuple("InariSami");
                        builder.finish()
                    }
                    (&Language::Italian,) => {
                        let mut builder = __arg_0.debug_tuple("Italian");
                        builder.finish()
                    }
                    (&Language::Hebrew,) => {
                        let mut builder = __arg_0.debug_tuple("Hebrew");
                        builder.finish()
                    }
                    (&Language::JamaicanCreole,) => {
                        let mut builder =
                            __arg_0.debug_tuple("JamaicanCreole");
                        builder.finish()
                    }
                    (&Language::Japanese,) => {
                        let mut builder = __arg_0.debug_tuple("Japanese");
                        builder.finish()
                    }
                    (&Language::Javanese,) => {
                        let mut builder = __arg_0.debug_tuple("Javanese");
                        builder.finish()
                    }
                    (&Language::Lojban,) => {
                        let mut builder = __arg_0.debug_tuple("Lojban");
                        builder.finish()
                    }
                    (&Language::Krymchak,) => {
                        let mut builder = __arg_0.debug_tuple("Krymchak");
                        builder.finish()
                    }
                    (&Language::Yiddish,) => {
                        let mut builder = __arg_0.debug_tuple("Yiddish");
                        builder.finish()
                    }
                    (&Language::Ladino,) => {
                        let mut builder = __arg_0.debug_tuple("Ladino");
                        builder.finish()
                    }
                    (&Language::Jula,) => {
                        let mut builder = __arg_0.debug_tuple("Jula");
                        builder.finish()
                    }
                    (&Language::Kabardian,) => {
                        let mut builder = __arg_0.debug_tuple("Kabardian");
                        builder.finish()
                    }
                    (&Language::Kabyle,) => {
                        let mut builder = __arg_0.debug_tuple("Kabyle");
                        builder.finish()
                    }
                    (&Language::Kachchi,) => {
                        let mut builder = __arg_0.debug_tuple("Kachchi");
                        builder.finish()
                    }
                    (&Language::Kalenjin,) => {
                        let mut builder = __arg_0.debug_tuple("Kalenjin");
                        builder.finish()
                    }
                    (&Language::Kannada,) => {
                        let mut builder = __arg_0.debug_tuple("Kannada");
                        builder.finish()
                    }
                    (&Language::Karachay,) => {
                        let mut builder = __arg_0.debug_tuple("Karachay");
                        builder.finish()
                    }
                    (&Language::Georgian,) => {
                        let mut builder = __arg_0.debug_tuple("Georgian");
                        builder.finish()
                    }
                    (&Language::Kazakh,) => {
                        let mut builder = __arg_0.debug_tuple("Kazakh");
                        builder.finish()
                    }
                    (&Language::Makonde,) => {
                        let mut builder = __arg_0.debug_tuple("Makonde");
                        builder.finish()
                    }
                    (&Language::Kabuverdianu,) => {
                        let mut builder = __arg_0.debug_tuple("Kabuverdianu");
                        builder.finish()
                    }
                    (&Language::Kebena,) => {
                        let mut builder = __arg_0.debug_tuple("Kebena");
                        builder.finish()
                    }
                    (&Language::Kekchi,) => {
                        let mut builder = __arg_0.debug_tuple("Kekchi");
                        builder.finish()
                    }
                    (&Language::KhutsuriGeorgian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("KhutsuriGeorgian");
                        builder.finish()
                    }
                    (&Language::Khakass,) => {
                        let mut builder = __arg_0.debug_tuple("Khakass");
                        builder.finish()
                    }
                    (&Language::KhantyKazim,) => {
                        let mut builder = __arg_0.debug_tuple("KhantyKazim");
                        builder.finish()
                    }
                    (&Language::Khmer,) => {
                        let mut builder = __arg_0.debug_tuple("Khmer");
                        builder.finish()
                    }
                    (&Language::KhantyShurishkar,) => {
                        let mut builder =
                            __arg_0.debug_tuple("KhantyShurishkar");
                        builder.finish()
                    }
                    (&Language::KhamtiShan,) => {
                        let mut builder = __arg_0.debug_tuple("KhamtiShan");
                        builder.finish()
                    }
                    (&Language::KhantyVakhi,) => {
                        let mut builder = __arg_0.debug_tuple("KhantyVakhi");
                        builder.finish()
                    }
                    (&Language::Khowar,) => {
                        let mut builder = __arg_0.debug_tuple("Khowar");
                        builder.finish()
                    }
                    (&Language::Kikuyu,) => {
                        let mut builder = __arg_0.debug_tuple("Kikuyu");
                        builder.finish()
                    }
                    (&Language::Kirghiz,) => {
                        let mut builder = __arg_0.debug_tuple("Kirghiz");
                        builder.finish()
                    }
                    (&Language::Kisii,) => {
                        let mut builder = __arg_0.debug_tuple("Kisii");
                        builder.finish()
                    }
                    (&Language::Kirmanjki,) => {
                        let mut builder = __arg_0.debug_tuple("Kirmanjki");
                        builder.finish()
                    }
                    (&Language::SouthernKiwai,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SouthernKiwai");
                        builder.finish()
                    }
                    (&Language::EasternPwoKaren,) => {
                        let mut builder =
                            __arg_0.debug_tuple("EasternPwoKaren");
                        builder.finish()
                    }
                    (&Language::Kokni,) => {
                        let mut builder = __arg_0.debug_tuple("Kokni");
                        builder.finish()
                    }
                    (&Language::Kalmyk,) => {
                        let mut builder = __arg_0.debug_tuple("Kalmyk");
                        builder.finish()
                    }
                    (&Language::Kamba,) => {
                        let mut builder = __arg_0.debug_tuple("Kamba");
                        builder.finish()
                    }
                    (&Language::Kumaoni,) => {
                        let mut builder = __arg_0.debug_tuple("Kumaoni");
                        builder.finish()
                    }
                    (&Language::Komo,) => {
                        let mut builder = __arg_0.debug_tuple("Komo");
                        builder.finish()
                    }
                    (&Language::Komso,) => {
                        let mut builder = __arg_0.debug_tuple("Komso");
                        builder.finish()
                    }
                    (&Language::KhorasaniTurkic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("KhorasaniTurkic");
                        builder.finish()
                    }
                    (&Language::Kanuri,) => {
                        let mut builder = __arg_0.debug_tuple("Kanuri");
                        builder.finish()
                    }
                    (&Language::Kodagu,) => {
                        let mut builder = __arg_0.debug_tuple("Kodagu");
                        builder.finish()
                    }
                    (&Language::KoreanOldHangul,) => {
                        let mut builder =
                            __arg_0.debug_tuple("KoreanOldHangul");
                        builder.finish()
                    }
                    (&Language::Konkani,) => {
                        let mut builder = __arg_0.debug_tuple("Konkani");
                        builder.finish()
                    }
                    (&Language::Kikongo,) => {
                        let mut builder = __arg_0.debug_tuple("Kikongo");
                        builder.finish()
                    }
                    (&Language::Komi,) => {
                        let mut builder = __arg_0.debug_tuple("Komi");
                        builder.finish()
                    }
                    (&Language::Kongo,) => {
                        let mut builder = __arg_0.debug_tuple("Kongo");
                        builder.finish()
                    }
                    (&Language::KomiPermyak,) => {
                        let mut builder = __arg_0.debug_tuple("KomiPermyak");
                        builder.finish()
                    }
                    (&Language::Korean,) => {
                        let mut builder = __arg_0.debug_tuple("Korean");
                        builder.finish()
                    }
                    (&Language::Kosraean,) => {
                        let mut builder = __arg_0.debug_tuple("Kosraean");
                        builder.finish()
                    }
                    (&Language::KomiZyrian,) => {
                        let mut builder = __arg_0.debug_tuple("KomiZyrian");
                        builder.finish()
                    }
                    (&Language::Kpelle,) => {
                        let mut builder = __arg_0.debug_tuple("Kpelle");
                        builder.finish()
                    }
                    (&Language::Krio,) => {
                        let mut builder = __arg_0.debug_tuple("Krio");
                        builder.finish()
                    }
                    (&Language::Karakalpak,) => {
                        let mut builder = __arg_0.debug_tuple("Karakalpak");
                        builder.finish()
                    }
                    (&Language::Karelian,) => {
                        let mut builder = __arg_0.debug_tuple("Karelian");
                        builder.finish()
                    }
                    (&Language::Karaim,) => {
                        let mut builder = __arg_0.debug_tuple("Karaim");
                        builder.finish()
                    }
                    (&Language::Karen,) => {
                        let mut builder = __arg_0.debug_tuple("Karen");
                        builder.finish()
                    }
                    (&Language::Koorete,) => {
                        let mut builder = __arg_0.debug_tuple("Koorete");
                        builder.finish()
                    }
                    (&Language::Kashmiri,) => {
                        let mut builder = __arg_0.debug_tuple("Kashmiri");
                        builder.finish()
                    }
                    (&Language::Ripuarian,) => {
                        let mut builder = __arg_0.debug_tuple("Ripuarian");
                        builder.finish()
                    }
                    (&Language::Khasi,) => {
                        let mut builder = __arg_0.debug_tuple("Khasi");
                        builder.finish()
                    }
                    (&Language::KildinSami,) => {
                        let mut builder = __arg_0.debug_tuple("KildinSami");
                        builder.finish()
                    }
                    (&Language::SgawKaren,) => {
                        let mut builder = __arg_0.debug_tuple("SgawKaren");
                        builder.finish()
                    }
                    (&Language::Kuanyama,) => {
                        let mut builder = __arg_0.debug_tuple("Kuanyama");
                        builder.finish()
                    }
                    (&Language::Kui,) => {
                        let mut builder = __arg_0.debug_tuple("Kui");
                        builder.finish()
                    }
                    (&Language::Kulvi,) => {
                        let mut builder = __arg_0.debug_tuple("Kulvi");
                        builder.finish()
                    }
                    (&Language::Kumyk,) => {
                        let mut builder = __arg_0.debug_tuple("Kumyk");
                        builder.finish()
                    }
                    (&Language::Kurdish,) => {
                        let mut builder = __arg_0.debug_tuple("Kurdish");
                        builder.finish()
                    }
                    (&Language::Kurukh,) => {
                        let mut builder = __arg_0.debug_tuple("Kurukh");
                        builder.finish()
                    }
                    (&Language::Kuy,) => {
                        let mut builder = __arg_0.debug_tuple("Kuy");
                        builder.finish()
                    }
                    (&Language::Koryak,) => {
                        let mut builder = __arg_0.debug_tuple("Koryak");
                        builder.finish()
                    }
                    (&Language::WesternKayah,) => {
                        let mut builder = __arg_0.debug_tuple("WesternKayah");
                        builder.finish()
                    }
                    (&Language::Ladin,) => {
                        let mut builder = __arg_0.debug_tuple("Ladin");
                        builder.finish()
                    }
                    (&Language::Lahuli,) => {
                        let mut builder = __arg_0.debug_tuple("Lahuli");
                        builder.finish()
                    }
                    (&Language::Lak,) => {
                        let mut builder = __arg_0.debug_tuple("Lak");
                        builder.finish()
                    }
                    (&Language::Lambani,) => {
                        let mut builder = __arg_0.debug_tuple("Lambani");
                        builder.finish()
                    }
                    (&Language::Lao,) => {
                        let mut builder = __arg_0.debug_tuple("Lao");
                        builder.finish()
                    }
                    (&Language::Latin,) => {
                        let mut builder = __arg_0.debug_tuple("Latin");
                        builder.finish()
                    }
                    (&Language::Laz,) => {
                        let mut builder = __arg_0.debug_tuple("Laz");
                        builder.finish()
                    }
                    (&Language::LCree,) => {
                        let mut builder = __arg_0.debug_tuple("LCree");
                        builder.finish()
                    }
                    (&Language::Ladakhi,) => {
                        let mut builder = __arg_0.debug_tuple("Ladakhi");
                        builder.finish()
                    }
                    (&Language::Lezgi,) => {
                        let mut builder = __arg_0.debug_tuple("Lezgi");
                        builder.finish()
                    }
                    (&Language::Ligurian,) => {
                        let mut builder = __arg_0.debug_tuple("Ligurian");
                        builder.finish()
                    }
                    (&Language::Limburgish,) => {
                        let mut builder = __arg_0.debug_tuple("Limburgish");
                        builder.finish()
                    }
                    (&Language::Lingala,) => {
                        let mut builder = __arg_0.debug_tuple("Lingala");
                        builder.finish()
                    }
                    (&Language::Lisu,) => {
                        let mut builder = __arg_0.debug_tuple("Lisu");
                        builder.finish()
                    }
                    (&Language::Lampung,) => {
                        let mut builder = __arg_0.debug_tuple("Lampung");
                        builder.finish()
                    }
                    (&Language::Laki,) => {
                        let mut builder = __arg_0.debug_tuple("Laki");
                        builder.finish()
                    }
                    (&Language::LowMari,) => {
                        let mut builder = __arg_0.debug_tuple("LowMari");
                        builder.finish()
                    }
                    (&Language::Limbu,) => {
                        let mut builder = __arg_0.debug_tuple("Limbu");
                        builder.finish()
                    }
                    (&Language::Lombard,) => {
                        let mut builder = __arg_0.debug_tuple("Lombard");
                        builder.finish()
                    }
                    (&Language::Lomwe,) => {
                        let mut builder = __arg_0.debug_tuple("Lomwe");
                        builder.finish()
                    }
                    (&Language::Loma,) => {
                        let mut builder = __arg_0.debug_tuple("Loma");
                        builder.finish()
                    }
                    (&Language::Luri,) => {
                        let mut builder = __arg_0.debug_tuple("Luri");
                        builder.finish()
                    }
                    (&Language::LowerSorbian,) => {
                        let mut builder = __arg_0.debug_tuple("LowerSorbian");
                        builder.finish()
                    }
                    (&Language::LuleSami,) => {
                        let mut builder = __arg_0.debug_tuple("LuleSami");
                        builder.finish()
                    }
                    (&Language::Lithuanian,) => {
                        let mut builder = __arg_0.debug_tuple("Lithuanian");
                        builder.finish()
                    }
                    (&Language::Luxembourgish,) => {
                        let mut builder =
                            __arg_0.debug_tuple("Luxembourgish");
                        builder.finish()
                    }
                    (&Language::LubaLulua,) => {
                        let mut builder = __arg_0.debug_tuple("LubaLulua");
                        builder.finish()
                    }
                    (&Language::LubaKatanga,) => {
                        let mut builder = __arg_0.debug_tuple("LubaKatanga");
                        builder.finish()
                    }
                    (&Language::Ganda,) => {
                        let mut builder = __arg_0.debug_tuple("Ganda");
                        builder.finish()
                    }
                    (&Language::Luyia,) => {
                        let mut builder = __arg_0.debug_tuple("Luyia");
                        builder.finish()
                    }
                    (&Language::Luo,) => {
                        let mut builder = __arg_0.debug_tuple("Luo");
                        builder.finish()
                    }
                    (&Language::Latvian,) => {
                        let mut builder = __arg_0.debug_tuple("Latvian");
                        builder.finish()
                    }
                    (&Language::Madura,) => {
                        let mut builder = __arg_0.debug_tuple("Madura");
                        builder.finish()
                    }
                    (&Language::Magahi,) => {
                        let mut builder = __arg_0.debug_tuple("Magahi");
                        builder.finish()
                    }
                    (&Language::Marshallese,) => {
                        let mut builder = __arg_0.debug_tuple("Marshallese");
                        builder.finish()
                    }
                    (&Language::Majang,) => {
                        let mut builder = __arg_0.debug_tuple("Majang");
                        builder.finish()
                    }
                    (&Language::Makhuwa,) => {
                        let mut builder = __arg_0.debug_tuple("Makhuwa");
                        builder.finish()
                    }
                    (&Language::Malayalam,) => {
                        let mut builder = __arg_0.debug_tuple("Malayalam");
                        builder.finish()
                    }
                    (&Language::Mam,) => {
                        let mut builder = __arg_0.debug_tuple("Mam");
                        builder.finish()
                    }
                    (&Language::Mansi,) => {
                        let mut builder = __arg_0.debug_tuple("Mansi");
                        builder.finish()
                    }
                    (&Language::Mapudungun,) => {
                        let mut builder = __arg_0.debug_tuple("Mapudungun");
                        builder.finish()
                    }
                    (&Language::Marathi,) => {
                        let mut builder = __arg_0.debug_tuple("Marathi");
                        builder.finish()
                    }
                    (&Language::Marwari,) => {
                        let mut builder = __arg_0.debug_tuple("Marwari");
                        builder.finish()
                    }
                    (&Language::Mbundu,) => {
                        let mut builder = __arg_0.debug_tuple("Mbundu");
                        builder.finish()
                    }
                    (&Language::Mbo,) => {
                        let mut builder = __arg_0.debug_tuple("Mbo");
                        builder.finish()
                    }
                    (&Language::Manchu,) => {
                        let mut builder = __arg_0.debug_tuple("Manchu");
                        builder.finish()
                    }
                    (&Language::MooseCree,) => {
                        let mut builder = __arg_0.debug_tuple("MooseCree");
                        builder.finish()
                    }
                    (&Language::Mende,) => {
                        let mut builder = __arg_0.debug_tuple("Mende");
                        builder.finish()
                    }
                    (&Language::Mandar,) => {
                        let mut builder = __arg_0.debug_tuple("Mandar");
                        builder.finish()
                    }
                    (&Language::Meen,) => {
                        let mut builder = __arg_0.debug_tuple("Meen");
                        builder.finish()
                    }
                    (&Language::Meru,) => {
                        let mut builder = __arg_0.debug_tuple("Meru");
                        builder.finish()
                    }
                    (&Language::Morisyen,) => {
                        let mut builder = __arg_0.debug_tuple("Morisyen");
                        builder.finish()
                    }
                    (&Language::Minangkabau,) => {
                        let mut builder = __arg_0.debug_tuple("Minangkabau");
                        builder.finish()
                    }
                    (&Language::Mizo,) => {
                        let mut builder = __arg_0.debug_tuple("Mizo");
                        builder.finish()
                    }
                    (&Language::Macedonian,) => {
                        let mut builder = __arg_0.debug_tuple("Macedonian");
                        builder.finish()
                    }
                    (&Language::Makasar,) => {
                        let mut builder = __arg_0.debug_tuple("Makasar");
                        builder.finish()
                    }
                    (&Language::Kituba,) => {
                        let mut builder = __arg_0.debug_tuple("Kituba");
                        builder.finish()
                    }
                    (&Language::Male,) => {
                        let mut builder = __arg_0.debug_tuple("Male");
                        builder.finish()
                    }
                    (&Language::Malagasy,) => {
                        let mut builder = __arg_0.debug_tuple("Malagasy");
                        builder.finish()
                    }
                    (&Language::Malinke,) => {
                        let mut builder = __arg_0.debug_tuple("Malinke");
                        builder.finish()
                    }
                    (&Language::MalayalamReformed,) => {
                        let mut builder =
                            __arg_0.debug_tuple("MalayalamReformed");
                        builder.finish()
                    }
                    (&Language::Malay,) => {
                        let mut builder = __arg_0.debug_tuple("Malay");
                        builder.finish()
                    }
                    (&Language::Mandinka,) => {
                        let mut builder = __arg_0.debug_tuple("Mandinka");
                        builder.finish()
                    }
                    (&Language::Mongolian,) => {
                        let mut builder = __arg_0.debug_tuple("Mongolian");
                        builder.finish()
                    }
                    (&Language::Manipuri,) => {
                        let mut builder = __arg_0.debug_tuple("Manipuri");
                        builder.finish()
                    }
                    (&Language::Maninka,) => {
                        let mut builder = __arg_0.debug_tuple("Maninka");
                        builder.finish()
                    }
                    (&Language::Manx,) => {
                        let mut builder = __arg_0.debug_tuple("Manx");
                        builder.finish()
                    }
                    (&Language::Mohawk,) => {
                        let mut builder = __arg_0.debug_tuple("Mohawk");
                        builder.finish()
                    }
                    (&Language::Moksha,) => {
                        let mut builder = __arg_0.debug_tuple("Moksha");
                        builder.finish()
                    }
                    (&Language::Moldavian,) => {
                        let mut builder = __arg_0.debug_tuple("Moldavian");
                        builder.finish()
                    }
                    (&Language::Mon,) => {
                        let mut builder = __arg_0.debug_tuple("Mon");
                        builder.finish()
                    }
                    (&Language::Moroccan,) => {
                        let mut builder = __arg_0.debug_tuple("Moroccan");
                        builder.finish()
                    }
                    (&Language::Mossi,) => {
                        let mut builder = __arg_0.debug_tuple("Mossi");
                        builder.finish()
                    }
                    (&Language::Maori,) => {
                        let mut builder = __arg_0.debug_tuple("Maori");
                        builder.finish()
                    }
                    (&Language::Maithili,) => {
                        let mut builder = __arg_0.debug_tuple("Maithili");
                        builder.finish()
                    }
                    (&Language::Maltese,) => {
                        let mut builder = __arg_0.debug_tuple("Maltese");
                        builder.finish()
                    }
                    (&Language::Mundari,) => {
                        let mut builder = __arg_0.debug_tuple("Mundari");
                        builder.finish()
                    }
                    (&Language::Muscogee,) => {
                        let mut builder = __arg_0.debug_tuple("Muscogee");
                        builder.finish()
                    }
                    (&Language::Mirandese,) => {
                        let mut builder = __arg_0.debug_tuple("Mirandese");
                        builder.finish()
                    }
                    (&Language::HmongDaw,) => {
                        let mut builder = __arg_0.debug_tuple("HmongDaw");
                        builder.finish()
                    }
                    (&Language::Mayan,) => {
                        let mut builder = __arg_0.debug_tuple("Mayan");
                        builder.finish()
                    }
                    (&Language::Mazanderani,) => {
                        let mut builder = __arg_0.debug_tuple("Mazanderani");
                        builder.finish()
                    }
                    (&Language::NagaAssamese,) => {
                        let mut builder = __arg_0.debug_tuple("NagaAssamese");
                        builder.finish()
                    }
                    (&Language::Nahuatl,) => {
                        let mut builder = __arg_0.debug_tuple("Nahuatl");
                        builder.finish()
                    }
                    (&Language::Nanai,) => {
                        let mut builder = __arg_0.debug_tuple("Nanai");
                        builder.finish()
                    }
                    (&Language::Neapolitan,) => {
                        let mut builder = __arg_0.debug_tuple("Neapolitan");
                        builder.finish()
                    }
                    (&Language::Naskapi,) => {
                        let mut builder = __arg_0.debug_tuple("Naskapi");
                        builder.finish()
                    }
                    (&Language::Nauruan,) => {
                        let mut builder = __arg_0.debug_tuple("Nauruan");
                        builder.finish()
                    }
                    (&Language::Navajo,) => {
                        let mut builder = __arg_0.debug_tuple("Navajo");
                        builder.finish()
                    }
                    (&Language::NCree,) => {
                        let mut builder = __arg_0.debug_tuple("NCree");
                        builder.finish()
                    }
                    (&Language::Ndebele,) => {
                        let mut builder = __arg_0.debug_tuple("Ndebele");
                        builder.finish()
                    }
                    (&Language::Ndau,) => {
                        let mut builder = __arg_0.debug_tuple("Ndau");
                        builder.finish()
                    }
                    (&Language::Ndonga,) => {
                        let mut builder = __arg_0.debug_tuple("Ndonga");
                        builder.finish()
                    }
                    (&Language::LowSaxon,) => {
                        let mut builder = __arg_0.debug_tuple("LowSaxon");
                        builder.finish()
                    }
                    (&Language::Nepali,) => {
                        let mut builder = __arg_0.debug_tuple("Nepali");
                        builder.finish()
                    }
                    (&Language::Newari,) => {
                        let mut builder = __arg_0.debug_tuple("Newari");
                        builder.finish()
                    }
                    (&Language::Ngbaka,) => {
                        let mut builder = __arg_0.debug_tuple("Ngbaka");
                        builder.finish()
                    }
                    (&Language::Nagari,) => {
                        let mut builder = __arg_0.debug_tuple("Nagari");
                        builder.finish()
                    }
                    (&Language::NorwayHouseCree,) => {
                        let mut builder =
                            __arg_0.debug_tuple("NorwayHouseCree");
                        builder.finish()
                    }
                    (&Language::Nisi,) => {
                        let mut builder = __arg_0.debug_tuple("Nisi");
                        builder.finish()
                    }
                    (&Language::Niuean,) => {
                        let mut builder = __arg_0.debug_tuple("Niuean");
                        builder.finish()
                    }
                    (&Language::Nyankole,) => {
                        let mut builder = __arg_0.debug_tuple("Nyankole");
                        builder.finish()
                    }
                    (&Language::NKo,) => {
                        let mut builder = __arg_0.debug_tuple("NKo");
                        builder.finish()
                    }
                    (&Language::Dutch,) => {
                        let mut builder = __arg_0.debug_tuple("Dutch");
                        builder.finish()
                    }
                    (&Language::Nimadi,) => {
                        let mut builder = __arg_0.debug_tuple("Nimadi");
                        builder.finish()
                    }
                    (&Language::Nogai,) => {
                        let mut builder = __arg_0.debug_tuple("Nogai");
                        builder.finish()
                    }
                    (&Language::Norwegian,) => {
                        let mut builder = __arg_0.debug_tuple("Norwegian");
                        builder.finish()
                    }
                    (&Language::Novial,) => {
                        let mut builder = __arg_0.debug_tuple("Novial");
                        builder.finish()
                    }
                    (&Language::NorthernSami,) => {
                        let mut builder = __arg_0.debug_tuple("NorthernSami");
                        builder.finish()
                    }
                    (&Language::NorthernSotho,) => {
                        let mut builder =
                            __arg_0.debug_tuple("NorthernSotho");
                        builder.finish()
                    }
                    (&Language::NorthernTai,) => {
                        let mut builder = __arg_0.debug_tuple("NorthernTai");
                        builder.finish()
                    }
                    (&Language::Esperanto,) => {
                        let mut builder = __arg_0.debug_tuple("Esperanto");
                        builder.finish()
                    }
                    (&Language::Nyamwezi,) => {
                        let mut builder = __arg_0.debug_tuple("Nyamwezi");
                        builder.finish()
                    }
                    (&Language::NorwegianNynorsk,) => {
                        let mut builder =
                            __arg_0.debug_tuple("NorwegianNynorsk");
                        builder.finish()
                    }
                    (&Language::MbembeTigon,) => {
                        let mut builder = __arg_0.debug_tuple("MbembeTigon");
                        builder.finish()
                    }
                    (&Language::Occitan,) => {
                        let mut builder = __arg_0.debug_tuple("Occitan");
                        builder.finish()
                    }
                    (&Language::OjiCree,) => {
                        let mut builder = __arg_0.debug_tuple("OjiCree");
                        builder.finish()
                    }
                    (&Language::Ojibway,) => {
                        let mut builder = __arg_0.debug_tuple("Ojibway");
                        builder.finish()
                    }
                    (&Language::Odia,) => {
                        let mut builder = __arg_0.debug_tuple("Odia");
                        builder.finish()
                    }
                    (&Language::Oromo,) => {
                        let mut builder = __arg_0.debug_tuple("Oromo");
                        builder.finish()
                    }
                    (&Language::Ossetian,) => {
                        let mut builder = __arg_0.debug_tuple("Ossetian");
                        builder.finish()
                    }
                    (&Language::PalestinianAramaic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("PalestinianAramaic");
                        builder.finish()
                    }
                    (&Language::Pangasinan,) => {
                        let mut builder = __arg_0.debug_tuple("Pangasinan");
                        builder.finish()
                    }
                    (&Language::Pali,) => {
                        let mut builder = __arg_0.debug_tuple("Pali");
                        builder.finish()
                    }
                    (&Language::Pampangan,) => {
                        let mut builder = __arg_0.debug_tuple("Pampangan");
                        builder.finish()
                    }
                    (&Language::Punjabi,) => {
                        let mut builder = __arg_0.debug_tuple("Punjabi");
                        builder.finish()
                    }
                    (&Language::Palpa,) => {
                        let mut builder = __arg_0.debug_tuple("Palpa");
                        builder.finish()
                    }
                    (&Language::Papiamentu,) => {
                        let mut builder = __arg_0.debug_tuple("Papiamentu");
                        builder.finish()
                    }
                    (&Language::Pashto,) => {
                        let mut builder = __arg_0.debug_tuple("Pashto");
                        builder.finish()
                    }
                    (&Language::Palauan,) => {
                        let mut builder = __arg_0.debug_tuple("Palauan");
                        builder.finish()
                    }
                    (&Language::Bouyei,) => {
                        let mut builder = __arg_0.debug_tuple("Bouyei");
                        builder.finish()
                    }
                    (&Language::Picard,) => {
                        let mut builder = __arg_0.debug_tuple("Picard");
                        builder.finish()
                    }
                    (&Language::PennsylvaniaGerman,) => {
                        let mut builder =
                            __arg_0.debug_tuple("PennsylvaniaGerman");
                        builder.finish()
                    }
                    (&Language::PolytonicGreek,) => {
                        let mut builder =
                            __arg_0.debug_tuple("PolytonicGreek");
                        builder.finish()
                    }
                    (&Language::Phake,) => {
                        let mut builder = __arg_0.debug_tuple("Phake");
                        builder.finish()
                    }
                    (&Language::Norfolk,) => {
                        let mut builder = __arg_0.debug_tuple("Norfolk");
                        builder.finish()
                    }
                    (&Language::Filipino,) => {
                        let mut builder = __arg_0.debug_tuple("Filipino");
                        builder.finish()
                    }
                    (&Language::Palaung,) => {
                        let mut builder = __arg_0.debug_tuple("Palaung");
                        builder.finish()
                    }
                    (&Language::Polish,) => {
                        let mut builder = __arg_0.debug_tuple("Polish");
                        builder.finish()
                    }
                    (&Language::Piemontese,) => {
                        let mut builder = __arg_0.debug_tuple("Piemontese");
                        builder.finish()
                    }
                    (&Language::WesternPanjabi,) => {
                        let mut builder =
                            __arg_0.debug_tuple("WesternPanjabi");
                        builder.finish()
                    }
                    (&Language::Pocomchi,) => {
                        let mut builder = __arg_0.debug_tuple("Pocomchi");
                        builder.finish()
                    }
                    (&Language::Pohnpeian,) => {
                        let mut builder = __arg_0.debug_tuple("Pohnpeian");
                        builder.finish()
                    }
                    (&Language::Provencal,) => {
                        let mut builder = __arg_0.debug_tuple("Provencal");
                        builder.finish()
                    }
                    (&Language::Portuguese,) => {
                        let mut builder = __arg_0.debug_tuple("Portuguese");
                        builder.finish()
                    }
                    (&Language::WesternPwoKaren,) => {
                        let mut builder =
                            __arg_0.debug_tuple("WesternPwoKaren");
                        builder.finish()
                    }
                    (&Language::Chin,) => {
                        let mut builder = __arg_0.debug_tuple("Chin");
                        builder.finish()
                    }
                    (&Language::Kiche,) => {
                        let mut builder = __arg_0.debug_tuple("Kiche");
                        builder.finish()
                    }
                    (&Language::QuechuaBolivia,) => {
                        let mut builder =
                            __arg_0.debug_tuple("QuechuaBolivia");
                        builder.finish()
                    }
                    (&Language::Quechua,) => {
                        let mut builder = __arg_0.debug_tuple("Quechua");
                        builder.finish()
                    }
                    (&Language::QuechuaEcuador,) => {
                        let mut builder =
                            __arg_0.debug_tuple("QuechuaEcuador");
                        builder.finish()
                    }
                    (&Language::QuechuaPeru,) => {
                        let mut builder = __arg_0.debug_tuple("QuechuaPeru");
                        builder.finish()
                    }
                    (&Language::Rajasthani,) => {
                        let mut builder = __arg_0.debug_tuple("Rajasthani");
                        builder.finish()
                    }
                    (&Language::Rarotongan,) => {
                        let mut builder = __arg_0.debug_tuple("Rarotongan");
                        builder.finish()
                    }
                    (&Language::RussianBuriat,) => {
                        let mut builder =
                            __arg_0.debug_tuple("RussianBuriat");
                        builder.finish()
                    }
                    (&Language::RCree,) => {
                        let mut builder = __arg_0.debug_tuple("RCree");
                        builder.finish()
                    }
                    (&Language::Rejang,) => {
                        let mut builder = __arg_0.debug_tuple("Rejang");
                        builder.finish()
                    }
                    (&Language::Riang,) => {
                        let mut builder = __arg_0.debug_tuple("Riang");
                        builder.finish()
                    }
                    (&Language::Tarifit,) => {
                        let mut builder = __arg_0.debug_tuple("Tarifit");
                        builder.finish()
                    }
                    (&Language::Ritarungo,) => {
                        let mut builder = __arg_0.debug_tuple("Ritarungo");
                        builder.finish()
                    }
                    (&Language::Arakwal,) => {
                        let mut builder = __arg_0.debug_tuple("Arakwal");
                        builder.finish()
                    }
                    (&Language::Romansh,) => {
                        let mut builder = __arg_0.debug_tuple("Romansh");
                        builder.finish()
                    }
                    (&Language::VlaxRomani,) => {
                        let mut builder = __arg_0.debug_tuple("VlaxRomani");
                        builder.finish()
                    }
                    (&Language::Romanian,) => {
                        let mut builder = __arg_0.debug_tuple("Romanian");
                        builder.finish()
                    }
                    (&Language::Romany,) => {
                        let mut builder = __arg_0.debug_tuple("Romany");
                        builder.finish()
                    }
                    (&Language::Rusyn,) => {
                        let mut builder = __arg_0.debug_tuple("Rusyn");
                        builder.finish()
                    }
                    (&Language::Rotuman,) => {
                        let mut builder = __arg_0.debug_tuple("Rotuman");
                        builder.finish()
                    }
                    (&Language::Kinyarwanda,) => {
                        let mut builder = __arg_0.debug_tuple("Kinyarwanda");
                        builder.finish()
                    }
                    (&Language::Rundi,) => {
                        let mut builder = __arg_0.debug_tuple("Rundi");
                        builder.finish()
                    }
                    (&Language::Aromanian,) => {
                        let mut builder = __arg_0.debug_tuple("Aromanian");
                        builder.finish()
                    }
                    (&Language::Russian,) => {
                        let mut builder = __arg_0.debug_tuple("Russian");
                        builder.finish()
                    }
                    (&Language::Sadri,) => {
                        let mut builder = __arg_0.debug_tuple("Sadri");
                        builder.finish()
                    }
                    (&Language::Sanskrit,) => {
                        let mut builder = __arg_0.debug_tuple("Sanskrit");
                        builder.finish()
                    }
                    (&Language::Sasak,) => {
                        let mut builder = __arg_0.debug_tuple("Sasak");
                        builder.finish()
                    }
                    (&Language::Santali,) => {
                        let mut builder = __arg_0.debug_tuple("Santali");
                        builder.finish()
                    }
                    (&Language::Sayisi,) => {
                        let mut builder = __arg_0.debug_tuple("Sayisi");
                        builder.finish()
                    }
                    (&Language::Sicilian,) => {
                        let mut builder = __arg_0.debug_tuple("Sicilian");
                        builder.finish()
                    }
                    (&Language::Scots,) => {
                        let mut builder = __arg_0.debug_tuple("Scots");
                        builder.finish()
                    }
                    (&Language::Sekota,) => {
                        let mut builder = __arg_0.debug_tuple("Sekota");
                        builder.finish()
                    }
                    (&Language::Selkup,) => {
                        let mut builder = __arg_0.debug_tuple("Selkup");
                        builder.finish()
                    }
                    (&Language::OldIrish,) => {
                        let mut builder = __arg_0.debug_tuple("OldIrish");
                        builder.finish()
                    }
                    (&Language::Sango,) => {
                        let mut builder = __arg_0.debug_tuple("Sango");
                        builder.finish()
                    }
                    (&Language::Samogitian,) => {
                        let mut builder = __arg_0.debug_tuple("Samogitian");
                        builder.finish()
                    }
                    (&Language::Tachelhit,) => {
                        let mut builder = __arg_0.debug_tuple("Tachelhit");
                        builder.finish()
                    }
                    (&Language::Shan,) => {
                        let mut builder = __arg_0.debug_tuple("Shan");
                        builder.finish()
                    }
                    (&Language::Sibe,) => {
                        let mut builder = __arg_0.debug_tuple("Sibe");
                        builder.finish()
                    }
                    (&Language::Sidamo,) => {
                        let mut builder = __arg_0.debug_tuple("Sidamo");
                        builder.finish()
                    }
                    (&Language::SilteGurage,) => {
                        let mut builder = __arg_0.debug_tuple("SilteGurage");
                        builder.finish()
                    }
                    (&Language::SkoltSami,) => {
                        let mut builder = __arg_0.debug_tuple("SkoltSami");
                        builder.finish()
                    }
                    (&Language::Slovak,) => {
                        let mut builder = __arg_0.debug_tuple("Slovak");
                        builder.finish()
                    }
                    (&Language::NorthSlavey,) => {
                        let mut builder = __arg_0.debug_tuple("NorthSlavey");
                        builder.finish()
                    }
                    (&Language::Slavey,) => {
                        let mut builder = __arg_0.debug_tuple("Slavey");
                        builder.finish()
                    }
                    (&Language::Slovenian,) => {
                        let mut builder = __arg_0.debug_tuple("Slovenian");
                        builder.finish()
                    }
                    (&Language::Somali,) => {
                        let mut builder = __arg_0.debug_tuple("Somali");
                        builder.finish()
                    }
                    (&Language::Samoan,) => {
                        let mut builder = __arg_0.debug_tuple("Samoan");
                        builder.finish()
                    }
                    (&Language::Sena,) => {
                        let mut builder = __arg_0.debug_tuple("Sena");
                        builder.finish()
                    }
                    (&Language::Shona,) => {
                        let mut builder = __arg_0.debug_tuple("Shona");
                        builder.finish()
                    }
                    (&Language::Sindhi,) => {
                        let mut builder = __arg_0.debug_tuple("Sindhi");
                        builder.finish()
                    }
                    (&Language::SinhalaSinhalese,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SinhalaSinhalese");
                        builder.finish()
                    }
                    (&Language::Soninke,) => {
                        let mut builder = __arg_0.debug_tuple("Soninke");
                        builder.finish()
                    }
                    (&Language::SodoGurage,) => {
                        let mut builder = __arg_0.debug_tuple("SodoGurage");
                        builder.finish()
                    }
                    (&Language::Songe,) => {
                        let mut builder = __arg_0.debug_tuple("Songe");
                        builder.finish()
                    }
                    (&Language::SouthernSotho,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SouthernSotho");
                        builder.finish()
                    }
                    (&Language::Albanian,) => {
                        let mut builder = __arg_0.debug_tuple("Albanian");
                        builder.finish()
                    }
                    (&Language::Serbian,) => {
                        let mut builder = __arg_0.debug_tuple("Serbian");
                        builder.finish()
                    }
                    (&Language::Sardinian,) => {
                        let mut builder = __arg_0.debug_tuple("Sardinian");
                        builder.finish()
                    }
                    (&Language::Saraiki,) => {
                        let mut builder = __arg_0.debug_tuple("Saraiki");
                        builder.finish()
                    }
                    (&Language::Serer,) => {
                        let mut builder = __arg_0.debug_tuple("Serer");
                        builder.finish()
                    }
                    (&Language::SouthSlavey,) => {
                        let mut builder = __arg_0.debug_tuple("SouthSlavey");
                        builder.finish()
                    }
                    (&Language::SouthernSami,) => {
                        let mut builder = __arg_0.debug_tuple("SouthernSami");
                        builder.finish()
                    }
                    (&Language::SaterlandFrisian,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SaterlandFrisian");
                        builder.finish()
                    }
                    (&Language::Sukuma,) => {
                        let mut builder = __arg_0.debug_tuple("Sukuma");
                        builder.finish()
                    }
                    (&Language::Sundanese,) => {
                        let mut builder = __arg_0.debug_tuple("Sundanese");
                        builder.finish()
                    }
                    (&Language::Suri,) => {
                        let mut builder = __arg_0.debug_tuple("Suri");
                        builder.finish()
                    }
                    (&Language::Svan,) => {
                        let mut builder = __arg_0.debug_tuple("Svan");
                        builder.finish()
                    }
                    (&Language::Swedish,) => {
                        let mut builder = __arg_0.debug_tuple("Swedish");
                        builder.finish()
                    }
                    (&Language::SwadayaAramaic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("SwadayaAramaic");
                        builder.finish()
                    }
                    (&Language::Swahili,) => {
                        let mut builder = __arg_0.debug_tuple("Swahili");
                        builder.finish()
                    }
                    (&Language::Swati,) => {
                        let mut builder = __arg_0.debug_tuple("Swati");
                        builder.finish()
                    }
                    (&Language::Sutu,) => {
                        let mut builder = __arg_0.debug_tuple("Sutu");
                        builder.finish()
                    }
                    (&Language::UpperSaxon,) => {
                        let mut builder = __arg_0.debug_tuple("UpperSaxon");
                        builder.finish()
                    }
                    (&Language::Sylheti,) => {
                        let mut builder = __arg_0.debug_tuple("Sylheti");
                        builder.finish()
                    }
                    (&Language::Syriac,) => {
                        let mut builder = __arg_0.debug_tuple("Syriac");
                        builder.finish()
                    }
                    (&Language::Silesian,) => {
                        let mut builder = __arg_0.debug_tuple("Silesian");
                        builder.finish()
                    }
                    (&Language::Tabasaran,) => {
                        let mut builder = __arg_0.debug_tuple("Tabasaran");
                        builder.finish()
                    }
                    (&Language::Tajiki,) => {
                        let mut builder = __arg_0.debug_tuple("Tajiki");
                        builder.finish()
                    }
                    (&Language::Tamil,) => {
                        let mut builder = __arg_0.debug_tuple("Tamil");
                        builder.finish()
                    }
                    (&Language::Tatar,) => {
                        let mut builder = __arg_0.debug_tuple("Tatar");
                        builder.finish()
                    }
                    (&Language::THCree,) => {
                        let mut builder = __arg_0.debug_tuple("THCree");
                        builder.finish()
                    }
                    (&Language::DehongDai,) => {
                        let mut builder = __arg_0.debug_tuple("DehongDai");
                        builder.finish()
                    }
                    (&Language::Telugu,) => {
                        let mut builder = __arg_0.debug_tuple("Telugu");
                        builder.finish()
                    }
                    (&Language::Tetum,) => {
                        let mut builder = __arg_0.debug_tuple("Tetum");
                        builder.finish()
                    }
                    (&Language::Tagalog,) => {
                        let mut builder = __arg_0.debug_tuple("Tagalog");
                        builder.finish()
                    }
                    (&Language::Tongan,) => {
                        let mut builder = __arg_0.debug_tuple("Tongan");
                        builder.finish()
                    }
                    (&Language::Tigre,) => {
                        let mut builder = __arg_0.debug_tuple("Tigre");
                        builder.finish()
                    }
                    (&Language::Tigrinya,) => {
                        let mut builder = __arg_0.debug_tuple("Tigrinya");
                        builder.finish()
                    }
                    (&Language::Thai,) => {
                        let mut builder = __arg_0.debug_tuple("Thai");
                        builder.finish()
                    }
                    (&Language::Tahitian,) => {
                        let mut builder = __arg_0.debug_tuple("Tahitian");
                        builder.finish()
                    }
                    (&Language::Tibetan,) => {
                        let mut builder = __arg_0.debug_tuple("Tibetan");
                        builder.finish()
                    }
                    (&Language::Tiv,) => {
                        let mut builder = __arg_0.debug_tuple("Tiv");
                        builder.finish()
                    }
                    (&Language::Turkmen,) => {
                        let mut builder = __arg_0.debug_tuple("Turkmen");
                        builder.finish()
                    }
                    (&Language::Tamashek,) => {
                        let mut builder = __arg_0.debug_tuple("Tamashek");
                        builder.finish()
                    }
                    (&Language::Temne,) => {
                        let mut builder = __arg_0.debug_tuple("Temne");
                        builder.finish()
                    }
                    (&Language::Tswana,) => {
                        let mut builder = __arg_0.debug_tuple("Tswana");
                        builder.finish()
                    }
                    (&Language::TundraNenets,) => {
                        let mut builder = __arg_0.debug_tuple("TundraNenets");
                        builder.finish()
                    }
                    (&Language::Tonga,) => {
                        let mut builder = __arg_0.debug_tuple("Tonga");
                        builder.finish()
                    }
                    (&Language::Todo,) => {
                        let mut builder = __arg_0.debug_tuple("Todo");
                        builder.finish()
                    }
                    (&Language::Toma,) => {
                        let mut builder = __arg_0.debug_tuple("Toma");
                        builder.finish()
                    }
                    (&Language::TokPisin,) => {
                        let mut builder = __arg_0.debug_tuple("TokPisin");
                        builder.finish()
                    }
                    (&Language::Turkish,) => {
                        let mut builder = __arg_0.debug_tuple("Turkish");
                        builder.finish()
                    }
                    (&Language::Tsonga,) => {
                        let mut builder = __arg_0.debug_tuple("Tsonga");
                        builder.finish()
                    }
                    (&Language::TuroyoAramaic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("TuroyoAramaic");
                        builder.finish()
                    }
                    (&Language::Tulu,) => {
                        let mut builder = __arg_0.debug_tuple("Tulu");
                        builder.finish()
                    }
                    (&Language::Tumbuka,) => {
                        let mut builder = __arg_0.debug_tuple("Tumbuka");
                        builder.finish()
                    }
                    (&Language::Tuvin,) => {
                        let mut builder = __arg_0.debug_tuple("Tuvin");
                        builder.finish()
                    }
                    (&Language::Tuvalu,) => {
                        let mut builder = __arg_0.debug_tuple("Tuvalu");
                        builder.finish()
                    }
                    (&Language::Twi,) => {
                        let mut builder = __arg_0.debug_tuple("Twi");
                        builder.finish()
                    }
                    (&Language::Tay,) => {
                        let mut builder = __arg_0.debug_tuple("Tay");
                        builder.finish()
                    }
                    (&Language::Tamazight,) => {
                        let mut builder = __arg_0.debug_tuple("Tamazight");
                        builder.finish()
                    }
                    (&Language::Tzotzil,) => {
                        let mut builder = __arg_0.debug_tuple("Tzotzil");
                        builder.finish()
                    }
                    (&Language::Udmurt,) => {
                        let mut builder = __arg_0.debug_tuple("Udmurt");
                        builder.finish()
                    }
                    (&Language::Ukrainian,) => {
                        let mut builder = __arg_0.debug_tuple("Ukrainian");
                        builder.finish()
                    }
                    (&Language::Umbundu,) => {
                        let mut builder = __arg_0.debug_tuple("Umbundu");
                        builder.finish()
                    }
                    (&Language::Urdu,) => {
                        let mut builder = __arg_0.debug_tuple("Urdu");
                        builder.finish()
                    }
                    (&Language::UpperSorbian,) => {
                        let mut builder = __arg_0.debug_tuple("UpperSorbian");
                        builder.finish()
                    }
                    (&Language::Uyghur,) => {
                        let mut builder = __arg_0.debug_tuple("Uyghur");
                        builder.finish()
                    }
                    (&Language::Uzbek,) => {
                        let mut builder = __arg_0.debug_tuple("Uzbek");
                        builder.finish()
                    }
                    (&Language::Venetian,) => {
                        let mut builder = __arg_0.debug_tuple("Venetian");
                        builder.finish()
                    }
                    (&Language::Venda,) => {
                        let mut builder = __arg_0.debug_tuple("Venda");
                        builder.finish()
                    }
                    (&Language::Vietnamese,) => {
                        let mut builder = __arg_0.debug_tuple("Vietnamese");
                        builder.finish()
                    }
                    (&Language::Volapuk,) => {
                        let mut builder = __arg_0.debug_tuple("Volapuk");
                        builder.finish()
                    }
                    (&Language::Voro,) => {
                        let mut builder = __arg_0.debug_tuple("Voro");
                        builder.finish()
                    }
                    (&Language::Wa,) => {
                        let mut builder = __arg_0.debug_tuple("Wa");
                        builder.finish()
                    }
                    (&Language::Wagdi,) => {
                        let mut builder = __arg_0.debug_tuple("Wagdi");
                        builder.finish()
                    }
                    (&Language::WarayWaray,) => {
                        let mut builder = __arg_0.debug_tuple("WarayWaray");
                        builder.finish()
                    }
                    (&Language::WestCree,) => {
                        let mut builder = __arg_0.debug_tuple("WestCree");
                        builder.finish()
                    }
                    (&Language::Welsh,) => {
                        let mut builder = __arg_0.debug_tuple("Welsh");
                        builder.finish()
                    }
                    (&Language::Walloon,) => {
                        let mut builder = __arg_0.debug_tuple("Walloon");
                        builder.finish()
                    }
                    (&Language::Wolof,) => {
                        let mut builder = __arg_0.debug_tuple("Wolof");
                        builder.finish()
                    }
                    (&Language::Mewati,) => {
                        let mut builder = __arg_0.debug_tuple("Mewati");
                        builder.finish()
                    }
                    (&Language::Lu,) => {
                        let mut builder = __arg_0.debug_tuple("Lu");
                        builder.finish()
                    }
                    (&Language::Xhosa,) => {
                        let mut builder = __arg_0.debug_tuple("Xhosa");
                        builder.finish()
                    }
                    (&Language::Minjangbal,) => {
                        let mut builder = __arg_0.debug_tuple("Minjangbal");
                        builder.finish()
                    }
                    (&Language::Soga,) => {
                        let mut builder = __arg_0.debug_tuple("Soga");
                        builder.finish()
                    }
                    (&Language::KpelleLiberia,) => {
                        let mut builder =
                            __arg_0.debug_tuple("KpelleLiberia");
                        builder.finish()
                    }
                    (&Language::Sakha,) => {
                        let mut builder = __arg_0.debug_tuple("Sakha");
                        builder.finish()
                    }
                    (&Language::Yao,) => {
                        let mut builder = __arg_0.debug_tuple("Yao");
                        builder.finish()
                    }
                    (&Language::Yapese,) => {
                        let mut builder = __arg_0.debug_tuple("Yapese");
                        builder.finish()
                    }
                    (&Language::Yoruba,) => {
                        let mut builder = __arg_0.debug_tuple("Yoruba");
                        builder.finish()
                    }
                    (&Language::YCree,) => {
                        let mut builder = __arg_0.debug_tuple("YCree");
                        builder.finish()
                    }
                    (&Language::YiClassic,) => {
                        let mut builder = __arg_0.debug_tuple("YiClassic");
                        builder.finish()
                    }
                    (&Language::YiModern,) => {
                        let mut builder = __arg_0.debug_tuple("YiModern");
                        builder.finish()
                    }
                    (&Language::Zealandic,) => {
                        let mut builder = __arg_0.debug_tuple("Zealandic");
                        builder.finish()
                    }
                    (&Language::StandardMorrocanTamazigh,) => {
                        let mut builder =
                            __arg_0.debug_tuple("StandardMorrocanTamazigh");
                        builder.finish()
                    }
                    (&Language::Zhuang,) => {
                        let mut builder = __arg_0.debug_tuple("Zhuang");
                        builder.finish()
                    }
                    (&Language::Chinese,) => {
                        let mut builder = __arg_0.debug_tuple("Chinese");
                        builder.finish()
                    }
                    (&Language::ChinesePhonetic,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ChinesePhonetic");
                        builder.finish()
                    }
                    (&Language::ChineseSimplified,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ChineseSimplified");
                        builder.finish()
                    }
                    (&Language::ChineseTraditional,) => {
                        let mut builder =
                            __arg_0.debug_tuple("ChineseTraditional");
                        builder.finish()
                    }
                    (&Language::Zande,) => {
                        let mut builder = __arg_0.debug_tuple("Zande");
                        builder.finish()
                    }
                    (&Language::Zulu,) => {
                        let mut builder = __arg_0.debug_tuple("Zulu");
                        builder.finish()
                    }
                    (&Language::Zazaki,) => {
                        let mut builder = __arg_0.debug_tuple("Zazaki");
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Language {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () { { } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Language {
            #[inline]
            fn eq(&self, __arg_0: &Language) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as isize;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) { _ => true, }
                    } else { false }
                }
            }
        }
        impl Language {
            /// Return the tag.
            pub fn tag(&self) -> Tag {
                use self::Language::*;
                match *self {
                    Abaza => Tag(*b"ABA "),
                    Abkhazian => Tag(*b"ABK "),
                    Acholi => Tag(*b"ACH "),
                    Achi => Tag(*b"ACR "),
                    Adyghe => Tag(*b"ADY "),
                    Afrikaans => Tag(*b"AFK "),
                    Afar => Tag(*b"AFR "),
                    Agaw => Tag(*b"AGW "),
                    Aiton => Tag(*b"AIO "),
                    Akan => Tag(*b"AKA "),
                    Alsatian => Tag(*b"ALS "),
                    Altai => Tag(*b"ALT "),
                    Amharic => Tag(*b"AMH "),
                    AngloSaxon => Tag(*b"ANG "),
                    AmericanistPhoneticNotation => Tag(*b"APPH"),
                    Arabic => Tag(*b"ARA "),
                    Aragonese => Tag(*b"ARG "),
                    Aari => Tag(*b"ARI "),
                    Rakhine => Tag(*b"ARK "),
                    Assamese => Tag(*b"ASM "),
                    Asturian => Tag(*b"AST "),
                    Athapaskan => Tag(*b"ATH "),
                    Avar => Tag(*b"AVR "),
                    Awadhi => Tag(*b"AWA "),
                    Aymara => Tag(*b"AYM "),
                    Torki => Tag(*b"AZB "),
                    Azerbaijani => Tag(*b"AZE "),
                    Badaga => Tag(*b"BAD "),
                    Banda => Tag(*b"BAD0"),
                    Baghelkhandi => Tag(*b"BAG "),
                    Balkar => Tag(*b"BAL "),
                    Balinese => Tag(*b"BAN "),
                    Bavarian => Tag(*b"BAR "),
                    Baule => Tag(*b"BAU "),
                    BatakToba => Tag(*b"BBC "),
                    Berber => Tag(*b"BBR "),
                    Bench => Tag(*b"BCH "),
                    BibleCree => Tag(*b"BCR "),
                    Bandjalang => Tag(*b"BDY "),
                    Belarussian => Tag(*b"BEL "),
                    Bemba => Tag(*b"BEM "),
                    Bengali => Tag(*b"BEN "),
                    Haryanvi => Tag(*b"BGC "),
                    Bagri => Tag(*b"BGQ "),
                    Bulgarian => Tag(*b"BGR "),
                    Bhili => Tag(*b"BHI "),
                    Bhojpuri => Tag(*b"BHO "),
                    Bikol => Tag(*b"BIK "),
                    Bilen => Tag(*b"BIL "),
                    Bislama => Tag(*b"BIS "),
                    Kanauji => Tag(*b"BJJ "),
                    Blackfoot => Tag(*b"BKF "),
                    Baluchi => Tag(*b"BLI "),
                    PaoKaren => Tag(*b"BLK "),
                    Balante => Tag(*b"BLN "),
                    Balti => Tag(*b"BLT "),
                    Bambara => Tag(*b"BMB "),
                    Bamileke => Tag(*b"BML "),
                    Bosnian => Tag(*b"BOS "),
                    BishnupriyaManipuri => Tag(*b"BPY "),
                    Breton => Tag(*b"BRE "),
                    Brahui => Tag(*b"BRH "),
                    BrajBhasha => Tag(*b"BRI "),
                    Burmese => Tag(*b"BRM "),
                    Bodo => Tag(*b"BRX "),
                    Bashkir => Tag(*b"BSH "),
                    Burushaski => Tag(*b"BSK "),
                    Beti => Tag(*b"BTI "),
                    BatakSimalungun => Tag(*b"BTS "),
                    Bugis => Tag(*b"BUG "),
                    Medumba => Tag(*b"BYV "),
                    Kaqchikel => Tag(*b"CAK "),
                    Catalan => Tag(*b"CAT "),
                    ZamboangaChavacano => Tag(*b"CBK "),
                    Cebuano => Tag(*b"CEB "),
                    Chechen => Tag(*b"CHE "),
                    ChahaGurage => Tag(*b"CHG "),
                    Chattisgarhi => Tag(*b"CHH "),
                    Chichewa => Tag(*b"CHI "),
                    Chukchi => Tag(*b"CHK "),
                    Chuukese => Tag(*b"CHK0"),
                    Choctaw => Tag(*b"CHO "),
                    Chipewyan => Tag(*b"CHP "),
                    Cherokee => Tag(*b"CHR "),
                    Chamorro => Tag(*b"CHA "),
                    Chuvash => Tag(*b"CHU "),
                    Cheyenne => Tag(*b"CHY "),
                    Chiga => Tag(*b"CGG "),
                    Comorian => Tag(*b"CMR "),
                    Coptic => Tag(*b"COP "),
                    Cornish => Tag(*b"COR "),
                    Corsican => Tag(*b"COS "),
                    Creoles => Tag(*b"CPP "),
                    Cree => Tag(*b"CRE "),
                    Carrier => Tag(*b"CRR "),
                    CrimeanTatar => Tag(*b"CRT "),
                    Kashubian => Tag(*b"CSB "),
                    ChurchSlavonic => Tag(*b"CSL "),
                    Czech => Tag(*b"CSY "),
                    Chittagonian => Tag(*b"CTG "),
                    SanBlasKuna => Tag(*b"CUK "),
                    Danish => Tag(*b"DAN "),
                    Dargwa => Tag(*b"DAR "),
                    Dayi => Tag(*b"DAX "),
                    WoodsCree => Tag(*b"DCR "),
                    German => Tag(*b"DEU "),
                    Dogri => Tag(*b"DGO "),
                    DogriMacrolanguage => Tag(*b"DGR "),
                    Dhangu => Tag(*b"DHG "),
                    DivehiDeprecated => Tag(*b"DHV "),
                    Dimli => Tag(*b"DIQ "),
                    Divehi => Tag(*b"DIV "),
                    Zarma => Tag(*b"DJR "),
                    Djambarrpuyngu => Tag(*b"DJR0"),
                    Dangme => Tag(*b"DNG "),
                    Dan => Tag(*b"DNJ "),
                    Dinka => Tag(*b"DNK "),
                    Dari => Tag(*b"DRI "),
                    Dhuwal => Tag(*b"DUJ "),
                    Dungan => Tag(*b"DUN "),
                    Dzongkha => Tag(*b"DZN "),
                    Ebira => Tag(*b"EBI "),
                    EasternCree => Tag(*b"ECR "),
                    Edo => Tag(*b"EDO "),
                    Efik => Tag(*b"EFI "),
                    Greek => Tag(*b"ELL "),
                    EasternManinkakan => Tag(*b"EMK "),
                    English => Tag(*b"ENG "),
                    Erzya => Tag(*b"ERZ "),
                    Spanish => Tag(*b"ESP "),
                    CentralYupik => Tag(*b"ESU "),
                    Estonian => Tag(*b"ETI "),
                    Basque => Tag(*b"EUQ "),
                    Evenki => Tag(*b"EVK "),
                    Even => Tag(*b"EVN "),
                    Ewe => Tag(*b"EWE "),
                    FrenchAntillean => Tag(*b"FAN "),
                    Fang => Tag(*b"FAN0"),
                    Persian => Tag(*b"FAR "),
                    Fanti => Tag(*b"FAT "),
                    Finnish => Tag(*b"FIN "),
                    Fijian => Tag(*b"FJI "),
                    DutchFlemish => Tag(*b"FLE "),
                    Fefe => Tag(*b"FMP "),
                    ForestNenets => Tag(*b"FNE "),
                    Fon => Tag(*b"FON "),
                    Faroese => Tag(*b"FOS "),
                    French => Tag(*b"FRA "),
                    CajunFrench => Tag(*b"FRC "),
                    Frisian => Tag(*b"FRI "),
                    Friulian => Tag(*b"FRL "),
                    Arpitan => Tag(*b"FRP "),
                    Futa => Tag(*b"FTA "),
                    Fulah => Tag(*b"FUL "),
                    NigerianFulfulde => Tag(*b"FUV "),
                    Ga => Tag(*b"GAD "),
                    ScottishGaelic => Tag(*b"GAE "),
                    Gagauz => Tag(*b"GAG "),
                    Galician => Tag(*b"GAL "),
                    Garshuni => Tag(*b"GAR "),
                    Garhwali => Tag(*b"GAW "),
                    Geez => Tag(*b"GEZ "),
                    Githabul => Tag(*b"GIH "),
                    Gilyak => Tag(*b"GIL "),
                    Kiribati => Tag(*b"GIL0"),
                    KpelleGuinea => Tag(*b"GKP "),
                    Gilaki => Tag(*b"GLK "),
                    Gumuz => Tag(*b"GMZ "),
                    Gumatj => Tag(*b"GNN "),
                    Gogo => Tag(*b"GOG "),
                    Gondi => Tag(*b"GON "),
                    Greenlandic => Tag(*b"GRN "),
                    Garo => Tag(*b"GRO "),
                    Guarani => Tag(*b"GUA "),
                    Wayuu => Tag(*b"GUC "),
                    Gupapuyngu => Tag(*b"GUF "),
                    Gujarati => Tag(*b"GUJ "),
                    Gusii => Tag(*b"GUZ "),
                    Haitian => Tag(*b"HAI "),
                    Halam => Tag(*b"HAL "),
                    Harauti => Tag(*b"HAR "),
                    Hausa => Tag(*b"HAU "),
                    Hawaiian => Tag(*b"HAW "),
                    Haya => Tag(*b"HAY "),
                    Hazaragi => Tag(*b"HAZ "),
                    HammerBanna => Tag(*b"HBN "),
                    Herero => Tag(*b"HER "),
                    Hiligaynon => Tag(*b"HIL "),
                    Hindi => Tag(*b"HIN "),
                    HighMari => Tag(*b"HMA "),
                    Hmong => Tag(*b"HMN "),
                    HiriMotu => Tag(*b"HMO "),
                    Hindko => Tag(*b"HND "),
                    Ho => Tag(*b"HO  "),
                    Harari => Tag(*b"HRI "),
                    Croatian => Tag(*b"HRV "),
                    Hungarian => Tag(*b"HUN "),
                    Armenian => Tag(*b"HYE "),
                    ArmenianEast => Tag(*b"HYE0"),
                    Iban => Tag(*b"IBA "),
                    Ibibio => Tag(*b"IBB "),
                    Igbo => Tag(*b"IBO "),
                    Ijolanguages => Tag(*b"IJO "),
                    Ido => Tag(*b"IDO "),
                    Interlingue => Tag(*b"ILE "),
                    Ilokano => Tag(*b"ILO "),
                    Interlingua => Tag(*b"INA "),
                    Indonesian => Tag(*b"IND "),
                    Ingush => Tag(*b"ING "),
                    Inuktitut => Tag(*b"INU "),
                    Inupiat => Tag(*b"IPK "),
                    InternationalPhoneticAlphabet => Tag(*b"IPPH"),
                    Irish => Tag(*b"IRI "),
                    IrishTraditional => Tag(*b"IRT "),
                    Icelandic => Tag(*b"ISL "),
                    InariSami => Tag(*b"ISM "),
                    Italian => Tag(*b"ITA "),
                    Hebrew => Tag(*b"IWR "),
                    JamaicanCreole => Tag(*b"JAM "),
                    Japanese => Tag(*b"JAN "),
                    Javanese => Tag(*b"JAV "),
                    Lojban => Tag(*b"JBO "),
                    Krymchak => Tag(*b"JCT "),
                    Yiddish => Tag(*b"JII "),
                    Ladino => Tag(*b"JUD "),
                    Jula => Tag(*b"JUL "),
                    Kabardian => Tag(*b"KAB "),
                    Kabyle => Tag(*b"KAB0"),
                    Kachchi => Tag(*b"KAC "),
                    Kalenjin => Tag(*b"KAL "),
                    Kannada => Tag(*b"KAN "),
                    Karachay => Tag(*b"KAR "),
                    Georgian => Tag(*b"KAT "),
                    Kazakh => Tag(*b"KAZ "),
                    Makonde => Tag(*b"KDE "),
                    Kabuverdianu => Tag(*b"KEA "),
                    Kebena => Tag(*b"KEB "),
                    Kekchi => Tag(*b"KEK "),
                    KhutsuriGeorgian => Tag(*b"KGE "),
                    Khakass => Tag(*b"KHA "),
                    KhantyKazim => Tag(*b"KHK "),
                    Khmer => Tag(*b"KHM "),
                    KhantyShurishkar => Tag(*b"KHS "),
                    KhamtiShan => Tag(*b"KHT "),
                    KhantyVakhi => Tag(*b"KHV "),
                    Khowar => Tag(*b"KHW "),
                    Kikuyu => Tag(*b"KIK "),
                    Kirghiz => Tag(*b"KIR "),
                    Kisii => Tag(*b"KIS "),
                    Kirmanjki => Tag(*b"KIU "),
                    SouthernKiwai => Tag(*b"KJD "),
                    EasternPwoKaren => Tag(*b"KJP "),
                    Kokni => Tag(*b"KKN "),
                    Kalmyk => Tag(*b"KLM "),
                    Kamba => Tag(*b"KMB "),
                    Kumaoni => Tag(*b"KMN "),
                    Komo => Tag(*b"KMO "),
                    Komso => Tag(*b"KMS "),
                    KhorasaniTurkic => Tag(*b"KMZ "),
                    Kanuri => Tag(*b"KNR "),
                    Kodagu => Tag(*b"KOD "),
                    KoreanOldHangul => Tag(*b"KOH "),
                    Konkani => Tag(*b"KOK "),
                    Kikongo => Tag(*b"KON "),
                    Komi => Tag(*b"KOM "),
                    Kongo => Tag(*b"KON0"),
                    KomiPermyak => Tag(*b"KOP "),
                    Korean => Tag(*b"KOR "),
                    Kosraean => Tag(*b"KOS "),
                    KomiZyrian => Tag(*b"KOZ "),
                    Kpelle => Tag(*b"KPL "),
                    Krio => Tag(*b"KRI "),
                    Karakalpak => Tag(*b"KRK "),
                    Karelian => Tag(*b"KRL "),
                    Karaim => Tag(*b"KRM "),
                    Karen => Tag(*b"KRN "),
                    Koorete => Tag(*b"KRT "),
                    Kashmiri => Tag(*b"KSH "),
                    Ripuarian => Tag(*b"KSH0"),
                    Khasi => Tag(*b"KSI "),
                    KildinSami => Tag(*b"KSM "),
                    SgawKaren => Tag(*b"KSW "),
                    Kuanyama => Tag(*b"KUA "),
                    Kui => Tag(*b"KUI "),
                    Kulvi => Tag(*b"KUL "),
                    Kumyk => Tag(*b"KUM "),
                    Kurdish => Tag(*b"KUR "),
                    Kurukh => Tag(*b"KUU "),
                    Kuy => Tag(*b"KUY "),
                    Koryak => Tag(*b"KYK "),
                    WesternKayah => Tag(*b"KYU "),
                    Ladin => Tag(*b"LAD "),
                    Lahuli => Tag(*b"LAH "),
                    Lak => Tag(*b"LAK "),
                    Lambani => Tag(*b"LAM "),
                    Lao => Tag(*b"LAO "),
                    Latin => Tag(*b"LAT "),
                    Laz => Tag(*b"LAZ "),
                    LCree => Tag(*b"LCR "),
                    Ladakhi => Tag(*b"LDK "),
                    Lezgi => Tag(*b"LEZ "),
                    Ligurian => Tag(*b"LIJ "),
                    Limburgish => Tag(*b"LIM "),
                    Lingala => Tag(*b"LIN "),
                    Lisu => Tag(*b"LIS "),
                    Lampung => Tag(*b"LJP "),
                    Laki => Tag(*b"LKI "),
                    LowMari => Tag(*b"LMA "),
                    Limbu => Tag(*b"LMB "),
                    Lombard => Tag(*b"LMO "),
                    Lomwe => Tag(*b"LMW "),
                    Loma => Tag(*b"LOM "),
                    Luri => Tag(*b"LRC "),
                    LowerSorbian => Tag(*b"LSB "),
                    LuleSami => Tag(*b"LSM "),
                    Lithuanian => Tag(*b"LTH "),
                    Luxembourgish => Tag(*b"LTZ "),
                    LubaLulua => Tag(*b"LUA "),
                    LubaKatanga => Tag(*b"LUB "),
                    Ganda => Tag(*b"LUG "),
                    Luyia => Tag(*b"LUH "),
                    Luo => Tag(*b"LUO "),
                    Latvian => Tag(*b"LVI "),
                    Madura => Tag(*b"MAD "),
                    Magahi => Tag(*b"MAG "),
                    Marshallese => Tag(*b"MAH "),
                    Majang => Tag(*b"MAJ "),
                    Makhuwa => Tag(*b"MAK "),
                    Malayalam => Tag(*b"MAL "),
                    Mam => Tag(*b"MAM "),
                    Mansi => Tag(*b"MAN "),
                    Mapudungun => Tag(*b"MAP "),
                    Marathi => Tag(*b"MAR "),
                    Marwari => Tag(*b"MAW "),
                    Mbundu => Tag(*b"MBN "),
                    Mbo => Tag(*b"MBO "),
                    Manchu => Tag(*b"MCH "),
                    MooseCree => Tag(*b"MCR "),
                    Mende => Tag(*b"MDE "),
                    Mandar => Tag(*b"MDR "),
                    Meen => Tag(*b"MEN "),
                    Meru => Tag(*b"MER "),
                    Morisyen => Tag(*b"MFE "),
                    Minangkabau => Tag(*b"MIN "),
                    Mizo => Tag(*b"MIZ "),
                    Macedonian => Tag(*b"MKD "),
                    Makasar => Tag(*b"MKR "),
                    Kituba => Tag(*b"MKW "),
                    Male => Tag(*b"MLE "),
                    Malagasy => Tag(*b"MLG "),
                    Malinke => Tag(*b"MLN "),
                    MalayalamReformed => Tag(*b"MLR "),
                    Malay => Tag(*b"MLY "),
                    Mandinka => Tag(*b"MND "),
                    Mongolian => Tag(*b"MNG "),
                    Manipuri => Tag(*b"MNI "),
                    Maninka => Tag(*b"MNK "),
                    Manx => Tag(*b"MNX "),
                    Mohawk => Tag(*b"MOH "),
                    Moksha => Tag(*b"MOK "),
                    Moldavian => Tag(*b"MOL "),
                    Mon => Tag(*b"MON "),
                    Moroccan => Tag(*b"MOR "),
                    Mossi => Tag(*b"MOS "),
                    Maori => Tag(*b"MRI "),
                    Maithili => Tag(*b"MTH "),
                    Maltese => Tag(*b"MTS "),
                    Mundari => Tag(*b"MUN "),
                    Muscogee => Tag(*b"MUS "),
                    Mirandese => Tag(*b"MWL "),
                    HmongDaw => Tag(*b"MWW "),
                    Mayan => Tag(*b"MYN "),
                    Mazanderani => Tag(*b"MZN "),
                    NagaAssamese => Tag(*b"NAG "),
                    Nahuatl => Tag(*b"NAH "),
                    Nanai => Tag(*b"NAN "),
                    Neapolitan => Tag(*b"NAP "),
                    Naskapi => Tag(*b"NAS "),
                    Nauruan => Tag(*b"NAU "),
                    Navajo => Tag(*b"NAV "),
                    NCree => Tag(*b"NCR "),
                    Ndebele => Tag(*b"NDB "),
                    Ndau => Tag(*b"NDC "),
                    Ndonga => Tag(*b"NDG "),
                    LowSaxon => Tag(*b"NDS "),
                    Nepali => Tag(*b"NEP "),
                    Newari => Tag(*b"NEW "),
                    Ngbaka => Tag(*b"NGA "),
                    Nagari => Tag(*b"NGR "),
                    NorwayHouseCree => Tag(*b"NHC "),
                    Nisi => Tag(*b"NIS "),
                    Niuean => Tag(*b"NIU "),
                    Nyankole => Tag(*b"NKL "),
                    NKo => Tag(*b"NKO "),
                    Dutch => Tag(*b"NLD "),
                    Nimadi => Tag(*b"NOE "),
                    Nogai => Tag(*b"NOG "),
                    Norwegian => Tag(*b"NOR "),
                    Novial => Tag(*b"NOV "),
                    NorthernSami => Tag(*b"NSM "),
                    NorthernSotho => Tag(*b"NSO "),
                    NorthernTai => Tag(*b"NTA "),
                    Esperanto => Tag(*b"NTO "),
                    Nyamwezi => Tag(*b"NYM "),
                    NorwegianNynorsk => Tag(*b"NYN "),
                    MbembeTigon => Tag(*b"NZA "),
                    Occitan => Tag(*b"OCI "),
                    OjiCree => Tag(*b"OCR "),
                    Ojibway => Tag(*b"OJB "),
                    Odia => Tag(*b"ORI "),
                    Oromo => Tag(*b"ORO "),
                    Ossetian => Tag(*b"OSS "),
                    PalestinianAramaic => Tag(*b"PAA "),
                    Pangasinan => Tag(*b"PAG "),
                    Pali => Tag(*b"PAL "),
                    Pampangan => Tag(*b"PAM "),
                    Punjabi => Tag(*b"PAN "),
                    Palpa => Tag(*b"PAP "),
                    Papiamentu => Tag(*b"PAP0"),
                    Pashto => Tag(*b"PAS "),
                    Palauan => Tag(*b"PAU "),
                    Bouyei => Tag(*b"PCC "),
                    Picard => Tag(*b"PCD "),
                    PennsylvaniaGerman => Tag(*b"PDC "),
                    PolytonicGreek => Tag(*b"PGR "),
                    Phake => Tag(*b"PHK "),
                    Norfolk => Tag(*b"PIH "),
                    Filipino => Tag(*b"PIL "),
                    Palaung => Tag(*b"PLG "),
                    Polish => Tag(*b"PLK "),
                    Piemontese => Tag(*b"PMS "),
                    WesternPanjabi => Tag(*b"PNB "),
                    Pocomchi => Tag(*b"POH "),
                    Pohnpeian => Tag(*b"PON "),
                    Provencal => Tag(*b"PRO "),
                    Portuguese => Tag(*b"PTG "),
                    WesternPwoKaren => Tag(*b"PWO "),
                    Chin => Tag(*b"QIN "),
                    Kiche => Tag(*b"QUC "),
                    QuechuaBolivia => Tag(*b"QUH "),
                    Quechua => Tag(*b"QUZ "),
                    QuechuaEcuador => Tag(*b"QVI "),
                    QuechuaPeru => Tag(*b"QWH "),
                    Rajasthani => Tag(*b"RAJ "),
                    Rarotongan => Tag(*b"RAR "),
                    RussianBuriat => Tag(*b"RBU "),
                    RCree => Tag(*b"RCR "),
                    Rejang => Tag(*b"REJ "),
                    Riang => Tag(*b"RIA "),
                    Tarifit => Tag(*b"RIF "),
                    Ritarungo => Tag(*b"RIT "),
                    Arakwal => Tag(*b"RKW "),
                    Romansh => Tag(*b"RMS "),
                    VlaxRomani => Tag(*b"RMY "),
                    Romanian => Tag(*b"ROM "),
                    Romany => Tag(*b"ROY "),
                    Rusyn => Tag(*b"RSY "),
                    Rotuman => Tag(*b"RTM "),
                    Kinyarwanda => Tag(*b"RUA "),
                    Rundi => Tag(*b"RUN "),
                    Aromanian => Tag(*b"RUP "),
                    Russian => Tag(*b"RUS "),
                    Sadri => Tag(*b"SAD "),
                    Sanskrit => Tag(*b"SAN "),
                    Sasak => Tag(*b"SAS "),
                    Santali => Tag(*b"SAT "),
                    Sayisi => Tag(*b"SAY "),
                    Sicilian => Tag(*b"SCN "),
                    Scots => Tag(*b"SCO "),
                    Sekota => Tag(*b"SEK "),
                    Selkup => Tag(*b"SEL "),
                    OldIrish => Tag(*b"SGA "),
                    Sango => Tag(*b"SGO "),
                    Samogitian => Tag(*b"SGS "),
                    Tachelhit => Tag(*b"SHI "),
                    Shan => Tag(*b"SHN "),
                    Sibe => Tag(*b"SIB "),
                    Sidamo => Tag(*b"SID "),
                    SilteGurage => Tag(*b"SIG "),
                    SkoltSami => Tag(*b"SKS "),
                    Slovak => Tag(*b"SKY "),
                    NorthSlavey => Tag(*b"SCS "),
                    Slavey => Tag(*b"SLA "),
                    Slovenian => Tag(*b"SLV "),
                    Somali => Tag(*b"SML "),
                    Samoan => Tag(*b"SMO "),
                    Sena => Tag(*b"SNA "),
                    Shona => Tag(*b"SNA0"),
                    Sindhi => Tag(*b"SND "),
                    SinhalaSinhalese => Tag(*b"SNH "),
                    Soninke => Tag(*b"SNK "),
                    SodoGurage => Tag(*b"SOG "),
                    Songe => Tag(*b"SOP "),
                    SouthernSotho => Tag(*b"SOT "),
                    Albanian => Tag(*b"SQI "),
                    Serbian => Tag(*b"SRB "),
                    Sardinian => Tag(*b"SRD "),
                    Saraiki => Tag(*b"SRK "),
                    Serer => Tag(*b"SRR "),
                    SouthSlavey => Tag(*b"SSL "),
                    SouthernSami => Tag(*b"SSM "),
                    SaterlandFrisian => Tag(*b"STQ "),
                    Sukuma => Tag(*b"SUK "),
                    Sundanese => Tag(*b"SUN "),
                    Suri => Tag(*b"SUR "),
                    Svan => Tag(*b"SVA "),
                    Swedish => Tag(*b"SVE "),
                    SwadayaAramaic => Tag(*b"SWA "),
                    Swahili => Tag(*b"SWK "),
                    Swati => Tag(*b"SWZ "),
                    Sutu => Tag(*b"SXT "),
                    UpperSaxon => Tag(*b"SXU "),
                    Sylheti => Tag(*b"SYL "),
                    Syriac => Tag(*b"SYR "),
                    Silesian => Tag(*b"SZL "),
                    Tabasaran => Tag(*b"TAB "),
                    Tajiki => Tag(*b"TAJ "),
                    Tamil => Tag(*b"TAM "),
                    Tatar => Tag(*b"TAT "),
                    THCree => Tag(*b"TCR "),
                    DehongDai => Tag(*b"TDD "),
                    Telugu => Tag(*b"TEL "),
                    Tetum => Tag(*b"TET "),
                    Tagalog => Tag(*b"TGL "),
                    Tongan => Tag(*b"TGN "),
                    Tigre => Tag(*b"TGR "),
                    Tigrinya => Tag(*b"TGY "),
                    Thai => Tag(*b"THA "),
                    Tahitian => Tag(*b"THT "),
                    Tibetan => Tag(*b"TIB "),
                    Tiv => Tag(*b"TIV "),
                    Turkmen => Tag(*b"TKM "),
                    Tamashek => Tag(*b"TMH "),
                    Temne => Tag(*b"TMN "),
                    Tswana => Tag(*b"TNA "),
                    TundraNenets => Tag(*b"TNE "),
                    Tonga => Tag(*b"TNG "),
                    Todo => Tag(*b"TOD "),
                    Toma => Tag(*b"TOD0"),
                    TokPisin => Tag(*b"TPI "),
                    Turkish => Tag(*b"TRK "),
                    Tsonga => Tag(*b"TSG "),
                    TuroyoAramaic => Tag(*b"TUA "),
                    Tulu => Tag(*b"TUM "),
                    Tumbuka => Tag(*b"TUL "),
                    Tuvin => Tag(*b"TUV "),
                    Tuvalu => Tag(*b"TVL "),
                    Twi => Tag(*b"TWI "),
                    Tay => Tag(*b"TYZ "),
                    Tamazight => Tag(*b"TZM "),
                    Tzotzil => Tag(*b"TZO "),
                    Udmurt => Tag(*b"UDM "),
                    Ukrainian => Tag(*b"UKR "),
                    Umbundu => Tag(*b"UMB "),
                    Urdu => Tag(*b"URD "),
                    UpperSorbian => Tag(*b"USB "),
                    Uyghur => Tag(*b"UYG "),
                    Uzbek => Tag(*b"UZB "),
                    Venetian => Tag(*b"VEC "),
                    Venda => Tag(*b"VEN "),
                    Vietnamese => Tag(*b"VIT "),
                    Volapuk => Tag(*b"VOL "),
                    Voro => Tag(*b"VRO "),
                    Wa => Tag(*b"WA  "),
                    Wagdi => Tag(*b"WAG "),
                    WarayWaray => Tag(*b"WAR "),
                    WestCree => Tag(*b"WCR "),
                    Welsh => Tag(*b"WEL "),
                    Walloon => Tag(*b"WLN "),
                    Wolof => Tag(*b"WLF "),
                    Mewati => Tag(*b"WTM "),
                    Lu => Tag(*b"XBD "),
                    Xhosa => Tag(*b"XHS "),
                    Minjangbal => Tag(*b"XJB "),
                    Soga => Tag(*b"XOG "),
                    KpelleLiberia => Tag(*b"XPE "),
                    Sakha => Tag(*b"YAK "),
                    Yao => Tag(*b"YAO "),
                    Yapese => Tag(*b"YAP "),
                    Yoruba => Tag(*b"YBA "),
                    YCree => Tag(*b"YCR "),
                    YiClassic => Tag(*b"YIC "),
                    YiModern => Tag(*b"YIM "),
                    Zealandic => Tag(*b"ZEA "),
                    StandardMorrocanTamazigh => Tag(*b"ZGH "),
                    Zhuang => Tag(*b"ZHA "),
                    Chinese => Tag(*b"ZHH "),
                    ChinesePhonetic => Tag(*b"ZHP "),
                    ChineseSimplified => Tag(*b"ZHS "),
                    ChineseTraditional => Tag(*b"ZHT "),
                    Zande => Tag(*b"ZND "),
                    Zulu => Tag(*b"ZUL "),
                    Zazaki => Tag(*b"ZZA "),
                }
            }
        }
        impl Record {
            /// Return the record of a language system if present.
            pub fn get(&self, language: Language) -> Option<&LanguageRecord> {
                let tag = language.tag();
                for (i, header) in self.language_headers.iter().enumerate() {
                    if header.tag == tag {
                        return Some(&self.language_records[i]);
                    }
                }
                None
            }
        }
    }
    pub use self::class::{Class, Class1, Class2, ClassRange};
    pub use self::coverage::{Coverage, Coverage1, Coverage2, CoverageRange};
    pub use self::device::Device;
    pub use self::directory::{Directory, Header};
    pub use self::feature::Features;
    pub use self::lookup::Lookups;
    pub use self::script::Scripts;
}
pub mod variation {
    //! The [common font-variation tables][1].
    //!
    //! [1]: https://www.microsoft.com/typography/otspec/otvarcommonformats.htm
}
pub use file::File;
pub use font::Font;
pub use glyph_definition::GlyphDefinition;
pub use glyph_positioning::GlyphPositioning;
pub use glyph_substitution::GlyphSubstitution;
pub use table::Table;
